{"remainingRequest":"C:\\Users\\Jwan\\Desktop\\SEP6-master\\Nycflights\\Nycflights\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Jwan\\Desktop\\SEP6-master\\Nycflights\\Nycflights\\ClientApp\\src\\assets\\canvasjs.min.js","dependencies":[{"path":"C:\\Users\\Jwan\\Desktop\\SEP6-master\\Nycflights\\Nycflights\\ClientApp\\src\\assets\\canvasjs.min.js","mtime":1590915820000},{"path":"C:\\Users\\Jwan\\Desktop\\SEP6-master\\Nycflights\\Nycflights\\ClientApp\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1510929699000},{"path":"C:\\Users\\Jwan\\Desktop\\SEP6-master\\Nycflights\\Nycflights\\ClientApp\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["/*\r\n CanvasJS HTML5 & JavaScript Charts - v2.1.3 GA - https://canvasjs.com/\r\n Copyright 2018 fenopix\r\n\r\n  --------------------- License Information --------------------\r\n CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.\r\n     https://canvasjs.com/license/\r\n\r\n*/\r\n/*eslint-disable*/\r\n/*jshint ignore:start*/\r\n(function () {\r\n    function oa(m, q) { m.prototype = ab(q.prototype); m.prototype.constructor = m; m.base = q.prototype; }\r\n    function ab(m) { function q() { } q.prototype = m; return new q; }\r\n    function Ua(m, q, s) {\r\n        \"millisecond\" === s ? m.setMilliseconds(m.getMilliseconds() + 1 * q) : \"second\" === s ? m.setSeconds(m.getSeconds() + 1 * q) : \"minute\" === s ? m.setMinutes(m.getMinutes() + 1 * q) : \"hour\" === s ? m.setHours(m.getHours() + 1 * q) : \"day\" === s ? m.setDate(m.getDate() + 1 * q) : \"week\" === s ? m.setDate(m.getDate() + 7 * q) : \"month\" === s ? m.setMonth(m.getMonth() + 1 * q) : \"year\" === s && m.setFullYear(m.getFullYear() +\r\n            1 * q);\r\n        return m;\r\n    }\r\n    function ha(m, q) { var s = !1; 0 > m && (s = !0, m *= -1); m = \"\" + m; for (q = q ? q : 1; m.length < q;)\r\n        m = \"0\" + m; return s ? \"-\" + m : m; }\r\n    function Ga(m) { if (!m)\r\n        return m; m = m.replace(/^\\s\\s*/, \"\"); for (var q = /\\s/, s = m.length; q.test(m.charAt(--s));)\r\n        ; return m.slice(0, s + 1); }\r\n    function Ca(m) {\r\n        m.roundRect = function (m, s, v, y, x, z, R, C) {\r\n            R && (this.fillStyle = R);\r\n            C && (this.strokeStyle = C);\r\n            \"undefined\" === typeof x && (x = 5);\r\n            this.lineWidth = z;\r\n            this.beginPath();\r\n            this.moveTo(m + x, s);\r\n            this.lineTo(m + v - x, s);\r\n            this.quadraticCurveTo(m + v, s, m + v, s + x);\r\n            this.lineTo(m + v, s + y -\r\n                x);\r\n            this.quadraticCurveTo(m + v, s + y, m + v - x, s + y);\r\n            this.lineTo(m + x, s + y);\r\n            this.quadraticCurveTo(m, s + y, m, s + y - x);\r\n            this.lineTo(m, s + x);\r\n            this.quadraticCurveTo(m, s, m + x, s);\r\n            this.closePath();\r\n            R && this.fill();\r\n            C && 0 < z && this.stroke();\r\n        };\r\n    }\r\n    function Qa(m, q) { return m - q; }\r\n    function S(m) { var q = ((m & 16711680) >> 16).toString(16), s = ((m & 65280) >> 8).toString(16); m = ((m & 255) >> 0).toString(16); q = 2 > q.length ? \"0\" + q : q; s = 2 > s.length ? \"0\" + s : s; m = 2 > m.length ? \"0\" + m : m; return \"#\" + q + s + m; }\r\n    function bb(m, q) {\r\n        var s = this.length >>> 0, v = Number(q) || 0, v = 0 > v ? Math.ceil(v) : Math.floor(v);\r\n        for (0 > v && (v += s); v < s; v++)\r\n            if (v in this && this[v] === m)\r\n                return v;\r\n        return -1;\r\n    }\r\n    function y(m) { return null === m || \"undefined\" === typeof m; }\r\n    function Da(m) { m.indexOf || (m.indexOf = bb); return m; }\r\n    function cb(m) { if ($.fSDec)\r\n        m[ja(\"`eeDwdouMhrudods\")](ja(\"e`u`@ohl`uhnoHuds`uhnoDoe\"), function () { $._fTWm && $._fTWm(m); }); }\r\n    function Va(m, q, s) {\r\n        s = s || \"normal\";\r\n        var v = m + \"_\" + q + \"_\" + s, y = Wa[v];\r\n        if (isNaN(y)) {\r\n            try {\r\n                m = \"position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:\" + m + \"; font-size:\" +\r\n                    q + \"px; font-weight:\" + s + \";\";\r\n                if (!qa) {\r\n                    var x = document.body;\r\n                    qa = document.createElement(\"span\");\r\n                    qa.innerHTML = \"\";\r\n                    var z = document.createTextNode(\"Mpgyi\");\r\n                    qa.appendChild(z);\r\n                    x.appendChild(qa);\r\n                }\r\n                qa.style.display = \"\";\r\n                qa.setAttribute(\"style\", m);\r\n                y = Math.round(qa.offsetHeight);\r\n                qa.style.display = \"none\";\r\n            }\r\n            catch (R) {\r\n                y = Math.ceil(1.1 * q);\r\n            }\r\n            y = Math.max(y, q);\r\n            Wa[v] = y;\r\n        }\r\n        return y;\r\n    }\r\n    function G(m, q) {\r\n        var s = [];\r\n        if (s = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1,\r\n                2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[m || \"solid\"])\r\n            for (var v = 0; v < s.length; v++)\r\n                s[v] *= q;\r\n        else\r\n            s = [];\r\n        return s;\r\n    }\r\n    function O(m, q, s, v) { return m.addEventListener ? (m.addEventListener(q, s, v || !1), s) : m.attachEvent ? (v = function (q) { q = q || window.event; q.preventDefault = q.preventDefault || function () { q.returnValue = !1; }; q.stopPropagation = q.stopPropagation || function () { q.cancelBubble = !0; }; s.call(m, q); }, m.attachEvent(\"on\" + q, v), v) : !1; }\r\n    function Xa(m, q, s) {\r\n        m *= ga;\r\n        q *= ga;\r\n        m = s.getImageData(m, q, 2, 2).data;\r\n        q =\r\n            !0;\r\n        for (s = 0; 4 > s; s++)\r\n            if (m[s] !== m[s + 4] | m[s] !== m[s + 8] | m[s] !== m[s + 12]) {\r\n                q = !1;\r\n                break;\r\n            }\r\n        return q ? m[0] << 16 | m[1] << 8 | m[2] : 0;\r\n    }\r\n    function ma(m, q, s) { return m in q ? q[m] : s[m]; }\r\n    function Ha(m, q, s) { if (v && Ya) {\r\n        var y = m.getContext(\"2d\");\r\n        Ma = y.webkitBackingStorePixelRatio || y.mozBackingStorePixelRatio || y.msBackingStorePixelRatio || y.oBackingStorePixelRatio || y.backingStorePixelRatio || 1;\r\n        ga = Ra / Ma;\r\n        m.width = q * ga;\r\n        m.height = s * ga;\r\n        Ra !== Ma && (m.style.width = q + \"px\", m.style.height = s + \"px\", y.scale(ga, ga));\r\n    }\r\n    else\r\n        m.width = q, m.height = s; }\r\n    function db(m) {\r\n        if (!Za) {\r\n            var q = !1, s = !1;\r\n            \"undefined\" === typeof ra.Chart.creditHref ? (m.creditHref = ja(\"iuuqr;..b`ow`rkr/bnl.\"), m.creditText = ja(\"B`ow`rKR/bnl\")) : (q = m.updateOption(\"creditText\"), s = m.updateOption(\"creditHref\"));\r\n            if (m.creditHref && m.creditText) {\r\n                m._creditLink || (m._creditLink = document.createElement(\"a\"), m._creditLink.setAttribute(\"class\", \"canvasjs-chart-credit\"), m._creditLink.setAttribute(\"style\", \"outline:none;margin:0px;position:absolute;right:2px;top:\" + (m.height - 14) + \"px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif\"),\r\n                    m._creditLink.setAttribute(\"tabIndex\", -1), m._creditLink.setAttribute(\"target\", \"_blank\"));\r\n                if (0 === m.renderCount || q || s)\r\n                    m._creditLink.setAttribute(\"href\", m.creditHref), m._creditLink.innerHTML = m.creditText;\r\n                m._creditLink && m.creditHref && m.creditText ? (m._creditLink.parentElement || m._canvasJSContainer.appendChild(m._creditLink), m._creditLink.style.top = m.height - 14 + \"px\") : m._creditLink.parentElement && m._canvasJSContainer.removeChild(m._creditLink);\r\n            }\r\n        }\r\n    }\r\n    function ua(m, q) {\r\n        var s = document.createElement(\"canvas\");\r\n        s.setAttribute(\"class\", \"canvasjs-chart-canvas\");\r\n        Ha(s, m, q);\r\n        v || \"undefined\" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(s);\r\n        return s;\r\n    }\r\n    function pa(m, q, s) { for (var v in s)\r\n        q.style[v] = s[v]; }\r\n    function va(m, q, s) {\r\n        q.getAttribute(\"state\") || (q.style.backgroundColor = m.toolbar.backgroundColor, q.style.color = m.toolbar.fontColor, q.style.border = \"none\", pa(m, q, { WebkitUserSelect: \"none\", MozUserSelect: \"none\", msUserSelect: \"none\", userSelect: \"none\" }));\r\n        q.getAttribute(\"state\") !== s && (q.setAttribute(\"state\", s), q.setAttribute(\"type\", \"button\"),\r\n            pa(m, q, { padding: \"5px 12px\", cursor: \"pointer\", \"float\": \"left\", width: \"40px\", height: \"25px\", outline: \"0px\", verticalAlign: \"baseline\", lineHeight: \"0\" }), q.setAttribute(\"title\", m._cultureInfo[s + \"Text\"]), q.innerHTML = \"<img style='height:95%;' src='\" + eb[s].image + \"' alt='\" + m._cultureInfo[s + \"Text\"] + \"' />\");\r\n    }\r\n    function Na() { for (var m = null, q = 0; q < arguments.length; q++)\r\n        m = arguments[q], m.style && (m.style.display = \"inline\"); }\r\n    function wa() { for (var m = null, q = 0; q < arguments.length; q++)\r\n        (m = arguments[q]) && m.style && (m.style.display = \"none\"); }\r\n    function Y(m, q, s, v, x) {\r\n        this._defaultsKey = m;\r\n        this._themeOptionsKey = q;\r\n        this._index = v;\r\n        this.parent = x;\r\n        this._eventListeners = [];\r\n        m = {};\r\n        this.theme && y(q) && y(v) ? m = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[q]) && (null === v ? m = this.parent.themeOptions[q] : 0 < this.parent.themeOptions[q].length && (v = Math.min(this.parent.themeOptions[q].length - 1, v), m = this.parent.themeOptions[q][v]));\r\n        this.themeOptions = m;\r\n        this.options = s ? s : { _isPlaceholder: !0 };\r\n        this.setOptions(this.options, m);\r\n    }\r\n    function Ea(m, q, s, v, y) { \"undefined\" === typeof y && (y = 0); this._padding = y; this._x1 = m; this._y1 = q; this._x2 = s; this._y2 = v; this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding; }\r\n    function ka(m, q) { ka.base.constructor.call(this, \"TextBlock\", null, q, null, null); this.ctx = m; this._isDirty = !0; this._wrappedText = null; this._initialize(); }\r\n    function Sa(m, q) {\r\n        Sa.base.constructor.call(this, \"Toolbar\", \"toolbar\", q, null, m);\r\n        this.chart = m;\r\n        this.canvas = m.canvas;\r\n        this.ctx = this.chart.ctx;\r\n        this.optionsName =\r\n            \"toolbar\";\r\n    }\r\n    function Ia(m, q) {\r\n        Ia.base.constructor.call(this, \"Title\", \"title\", q, null, m);\r\n        this.chart = m;\r\n        this.canvas = m.canvas;\r\n        this.ctx = this.chart.ctx;\r\n        this.optionsName = \"title\";\r\n        if (y(this.options.margin) && m.options.subtitles)\r\n            for (var s = m.options.subtitles, v = 0; v < s.length; v++)\r\n                if ((y(s[v].horizontalAlign) && \"center\" === this.horizontalAlign || s[v].horizontalAlign === this.horizontalAlign) && (y(s[v].verticalAlign) && \"top\" === this.verticalAlign || s[v].verticalAlign === this.verticalAlign) && !s[v].dockInsidePlotArea === !this.dockInsidePlotArea) {\r\n                    this.margin =\r\n                        0;\r\n                    break;\r\n                }\r\n        \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\r\n        this.height = this.width = null;\r\n        this.bounds = { x1: null, y1: null, x2: null, y2: null };\r\n    }\r\n    function Oa(m, q, s) {\r\n        Oa.base.constructor.call(this, \"Subtitle\", \"subtitles\", q, s, m);\r\n        this.chart = m;\r\n        this.canvas = m.canvas;\r\n        this.ctx = this.chart.ctx;\r\n        this.optionsName = \"subtitles\";\r\n        this.isOptionsInArray = !0;\r\n        \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\r\n        this.height = this.width = null;\r\n        this.bounds = { x1: null, y1: null, x2: null, y2: null };\r\n    }\r\n    function Ja(m) { var q; m && Ka[m] && (q = Ka[m]); Ja.base.constructor.call(this, \"CultureInfo\", null, q, null, null); }\r\n    var $ = {}, v = !!document.createElement(\"canvas\").getContext, ra = { Chart: { width: 500, height: 400, zoomEnabled: !1, zoomType: \"x\", backgroundColor: \"white\", theme: \"light1\", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: \"colorSet1\", culture: \"en\", creditHref: \"\", creditText: \"CanvasJS\", interactivityEnabled: !0,\r\n            exportEnabled: !1, exportFileName: \"Chart\", rangeChanging: null, rangeChanged: null, publicProperties: { title: \"readWrite\", subtitles: \"readWrite\", toolbar: \"readWrite\", toolTip: \"readWrite\", legend: \"readWrite\", axisX: \"readWrite\", axisY: \"readWrite\", axisX2: \"readWrite\", axisY2: \"readWrite\", data: \"readWrite\", options: \"readWrite\", bounds: \"readOnly\", container: \"readOnly\" } }, Title: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 20, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\",\r\n            borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: v ? \"transparent\" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Subtitle: { padding: 0, text: null, verticalAlign: \"top\", horizontalAlign: \"center\", fontSize: 14, fontFamily: \"Calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1,\r\n            publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, Toolbar: { backgroundColor: \"white\", backgroundColorOnHover: \"#2196f3\", borderColor: \"#2196f3\", borderThickness: 1, fontColor: \"black\", fontColorOnHover: \"white\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Legend: { name: null, verticalAlign: \"center\", horizontalAlign: \"right\", fontSize: 14, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null,\r\n            itemclick: null, dockInsidePlotArea: !1, reversed: !1, backgroundColor: v ? \"transparent\" : null, borderColor: v ? \"transparent\" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null, markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, ToolTip: { enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", borderColor: null,\r\n            borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: \"black\", fontFamily: \"Calibri, Arial, Georgia, serif;\", fontWeight: \"normal\", fontStyle: \"italic\", publicProperties: { options: \"readWrite\", chart: \"readOnly\" } }, Axis: { minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: \"black\", titleFontSize: 20, titleFontFamily: \"arial\", titleFontWeight: \"normal\", titleFontStyle: \"normal\", titleWrap: !0, titleMaxWidth: null,\r\n            titleBackgroundColor: v ? \"transparent\" : null, titleBorderColor: v ? \"transparent\" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: \"arial\", labelFontColor: \"black\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: v ? \"transparent\" : null, labelBorderColor: v ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: \"outside\", prefix: \"\", suffix: \"\", includeZero: !0, tickLength: 5,\r\n            tickColor: \"black\", tickThickness: 1, lineColor: \"black\", lineThickness: 1, lineDashType: \"solid\", gridColor: \"A0A0A0\", gridThickness: 0, gridDashType: \"solid\", interlacedColor: v ? \"transparent\" : null, valueFormatString: null, margin: 2, publicProperties: { options: \"readWrite\", stripLines: \"readWrite\", scaleBreaks: \"readWrite\", crosshair: \"readWrite\", bounds: \"readOnly\", chart: \"readOnly\" } }, StripLine: { value: null, startValue: null, endValue: null, color: \"orange\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\", labelPlacement: \"inside\",\r\n            labelAlign: \"far\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: v ? \"transparent\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: \"arial\", labelFontColor: \"orange\", labelFontSize: 12, labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, showOnTop: !1, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, ScaleBreaks: { autoCalculate: !1, collapsibleThreshold: \"25%\", maxNumberOfAutoBreaks: 2, spacing: 8, type: \"straight\",\r\n            color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", customBreaks: \"readWrite\", axis: \"readOnly\", autoBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Break: { startValue: null, endValue: null, spacing: 8, type: \"straight\", color: \"#FFFFFF\", fillOpacity: 0.9, lineThickness: 2, lineColor: \"#E16E6E\", lineDashType: \"solid\", publicProperties: { options: \"readWrite\", scaleBreaks: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } }, Crosshair: { enabled: !1, snapToDataPoint: !1,\r\n            color: \"grey\", opacity: null, thickness: 2, lineDashType: \"solid\", label: \"\", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: v ? \"grey\" : null, labelBorderColor: v ? \"grey\" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: v ? \"Calibri, Optima, Candara, Verdana, Geneva, sans-serif\" : \"calibri\", labelFontSize: 12, labelFontColor: \"#fff\", labelFontWeight: \"normal\", labelFontStyle: \"normal\", labelFormatter: null, valueFormatString: null, publicProperties: { options: \"readWrite\", axis: \"readOnly\", bounds: \"readOnly\", chart: \"readOnly\" } },\r\n        DataSeries: { name: null, dataPoints: null, label: \"\", bevelEnabled: !1, highlightEnabled: !0, cursor: \"default\", indexLabel: \"\", indexLabelPlacement: \"auto\", indexLabelOrientation: \"horizontal\", indexLabelFontColor: \"black\", indexLabelFontSize: 12, indexLabelFontStyle: \"normal\", indexLabelFontFamily: \"Arial\", indexLabelFontWeight: \"normal\", indexLabelBackgroundColor: null, indexLabelLineColor: \"gray\", indexLabelLineThickness: 1, indexLabelLineDashType: \"solid\", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2,\r\n            lineDashType: \"solid\", connectNullData: !1, nullDataLineDashType: \"dash\", color: null, lineColor: null, risingColor: \"white\", fallingColor: \"red\", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: \"solid\", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: \"solid\", upperBoxColor: \"white\", lowerBoxColor: \"white\", type: \"column\", xValueType: \"number\", axisXType: \"primary\",\r\n            axisYType: \"primary\", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: v ? \"transparent\" : null, legendMarkerBorderThickness: 0, markerType: \"circle\", markerColor: null, markerSize: null, markerBorderColor: v ? \"transparent\" : null, markerBorderThickness: 0, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0, publicProperties: { options: \"readWrite\",\r\n                axisX: \"readWrite\", axisY: \"readWrite\", chart: \"readOnly\" } }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: \"\", horizontalAlign: \"center\", fontSize: 12, fontFamily: \"calibri\", fontWeight: \"normal\", fontColor: \"black\", fontStyle: \"normal\", borderThickness: 0, borderColor: \"black\", cornerRadius: 0, backgroundColor: null, textBaseline: \"top\" }, CultureInfo: { decimalSeparator: \".\", digitGroupSeparator: \",\", zoomText: \"Zoom\", panText: \"Pan\", resetText: \"Reset\", menuText: \"More Options\", saveJPGText: \"Save as JPEG\",\r\n            savePNGText: \"Save as PNG\", printText: \"Print\", days: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), shortDays: \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), months: \"January February March April May June July August September October November December\".split(\" \"), shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \") } }, Ka = { en: {} }, x = v ? \"Trebuchet MS, Helvetica, sans-serif\" : \"Arial\", Fa = v ? \"Impact, Charcoal, sans-serif\" : \"Arial\", Aa = { colorSet1: \"#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566\".split(\" \"),\r\n        colorSet2: \"#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C\".split(\" \"), colorSet3: \"#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970\".split(\" \") }, P, fa, U, Z, ea;\r\n    fa = \"#333333\";\r\n    U = \"#000000\";\r\n    P = \"#666666\";\r\n    ea = Z = \"#000000\";\r\n    var ba = 20, z = 14, Ta = { colorSet: \"colorSet1\", backgroundColor: \"#FFFFFF\", title: { fontFamily: Fa, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\",\r\n            margin: 5 }, subtitles: [{ fontFamily: Fa, fontSize: z, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: fa, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x,\r\n                        labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z,\r\n                labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1,\r\n                    lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\",\r\n                    labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: fa, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\",\r\n                        labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };\r\n    U = fa = \"#F5F5F5\";\r\n    P = \"#FFFFFF\";\r\n    Z = \"#40BAF1\";\r\n    ea = \"#F5F5F5\";\r\n    var ba = 20, z = 14, $a = { colorSet: \"colorSet2\", title: { fontFamily: x, fontSize: 33, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: x, fontSize: z, fontColor: \"#3A3A3A\", fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: \"#666666\", indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: \"#666666\",\r\n                titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickThickness: 1, tickColor: \"#BBBBBB\", gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\",\r\n                    thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 1, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\",\r\n                        labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], axisY: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\",\r\n                lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1,\r\n                    lineDashType: \"solid\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: \"#666666\", titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: \"#666666\", labelFontWeight: \"normal\", lineThickness: 0, lineColor: \"#BBBBBB\", tickColor: \"#BBBBBB\", tickThickness: 1, gridThickness: 1, gridColor: \"#BBBBBB\", stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FFA500\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FFA500\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z,\r\n                    labelFontColor: \"#EEEEEE\", labelFontWeight: \"normal\", labelBackgroundColor: \"black\", color: \"black\", thickness: 1, lineDashType: \"dot\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#BBBBBB\", lineThickness: 1, lineDashType: \"solid\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: \"#3A3A3A\", fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1 } };\r\n    U = fa = \"#F5F5F5\";\r\n    P = \"#FFFFFF\";\r\n    Z = \"#40BAF1\";\r\n    ea = \"#F5F5F5\";\r\n    ba = 20;\r\n    z = 14;\r\n    Fa = { colorSet: \"colorSet12\",\r\n        backgroundColor: \"#2A2A2A\", title: { fontFamily: Fa, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: Fa, fontSize: z, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: U, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }],\r\n        axisX: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea,\r\n                    color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null,\r\n                        color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1,\r\n                tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: ba,\r\n                titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" },\r\n                scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: U, backgroundColor: \"rgba(0, 0, 0, .7)\" } };\r\n    P = \"#FFFFFF\";\r\n    U = fa = \"#FAFAFA\";\r\n    Z = \"#40BAF1\";\r\n    ea = \"#F5F5F5\";\r\n    var ba = 20, z = 14, ya = { light1: Ta, light2: $a, dark1: Fa, dark2: { colorSet: \"colorSet2\", backgroundColor: \"#32373A\",\r\n            title: { fontFamily: x, fontSize: 32, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }, subtitles: [{ fontFamily: x, fontSize: z, fontColor: fa, fontWeight: \"normal\", verticalAlign: \"top\", margin: 5 }], toolbar: { backgroundColor: \"#666666\", backgroundColorOnHover: \"#FF7372\", borderColor: \"#FF7372\", borderThickness: 1, fontColor: \"#F5F5F5\", fontColorOnHover: \"#F5F5F5\" }, data: [{ indexLabelFontFamily: x, indexLabelFontSize: z, indexLabelFontColor: U, indexLabelFontWeight: \"normal\", indexLabelLineThickness: 1 }], axisX: [{ titleFontFamily: x,\r\n                    titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1,\r\n                        lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisX2: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 1, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 0, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null,\r\n                            color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY: [{ titleFontFamily: x, titleFontSize: ba, titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 0, lineColor: P, tickThickness: 1,\r\n                    tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" }, scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], axisY2: [{ titleFontFamily: x, titleFontSize: ba,\r\n                    titleFontColor: U, titleFontWeight: \"normal\", labelFontFamily: x, labelFontSize: z, labelFontColor: U, labelFontWeight: \"normal\", lineThickness: 0, lineColor: P, tickThickness: 1, tickColor: P, gridThickness: 1, gridColor: P, stripLines: [{ labelFontFamily: x, labelFontSize: z, labelFontColor: \"#FF7300\", labelFontWeight: \"normal\", labelBackgroundColor: null, color: \"#FF7300\", thickness: 1 }], crosshair: { labelFontFamily: x, labelFontSize: z, labelFontColor: \"#000000\", labelFontWeight: \"normal\", labelBackgroundColor: ea, color: Z, thickness: 1, lineDashType: \"dash\" },\r\n                    scaleBreaks: { type: \"zigzag\", spacing: \"2%\", lineColor: \"#777777\", lineThickness: 1, lineDashType: \"solid\", color: \"#111111\" } }], legend: { fontFamily: x, fontSize: 14, fontColor: fa, fontWeight: \"bold\", verticalAlign: \"bottom\", horizontalAlign: \"center\" }, toolTip: { fontFamily: x, fontSize: 14, fontStyle: \"normal\", cornerRadius: 0, borderThickness: 1, fontColor: U, backgroundColor: \"rgba(0, 0, 0, .7)\" } }, theme1: Ta, theme2: $a, theme3: Ta }, V = { numberDuration: 1, yearDuration: 314496E5, monthDuration: 2592E6, weekDuration: 6048E5, dayDuration: 864E5, hourDuration: 36E5,\r\n        minuteDuration: 6E4, secondDuration: 1E3, millisecondDuration: 1, dayOfWeekFromInt: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \") };\r\n    (function () {\r\n        $.fSDec = function (m) { for (var q = \"\", s = 0; s < m.length; s++)\r\n            q += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(s)); return q; };\r\n        $.obj = { trVs: \"Ush`m!Wdsrhno\", fntStr: \"qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg\", txtBl: \"udyuC`rdmhod\", fnt: \"gnou\", fSy: \"ghmmRuxmd\", fTx: \"ghmmUdyu\", grClr: \"fsdx\", cntx: \"buy\", tp: \"unq\" };\r\n        delete ra[$.fSDec(\"Bi`su\")][$.fSDec(\"bsdehuIsdg\")];\r\n        $.pro = { sCH: ra[$.fSDec(\"Bi`su\")][$.fSDec(\"bsdehuIsdg\")] };\r\n        $._fTWm = function (m) { if (\"undefined\" === typeof $.pro.sCH && !Za)\r\n            try {\r\n                var q = m[$.fSDec($.obj.cntx)];\r\n                q[$.fSDec($.obj.txtBl)] = $.fSDec($.obj.tp);\r\n                q[$.fSDec($.obj.fnt)] = 11 + $.fSDec($.obj.fntStr);\r\n                q[$.fSDec($.obj.fSy)] = $.fSDec($.obj.grClr);\r\n                q[$.fSDec($.obj.fTx)]($.fSDec($.obj.trVs), 2, m.height - 11 - 2);\r\n            }\r\n            catch (s) { } };\r\n    })();\r\n    var Wa = {}, qa = null, Ba = function () {\r\n        var m = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|\"[^\"]*\"|'[^']*'/g, q = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), s = \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"), v = \"January February March April May June July August September October November December\".split(\" \"), y = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"), x = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g, z = /[^-+\\dA-Z]/g;\r\n        return function (R, C, Q) {\r\n            var G = Q ? Q.days : q, P = Q ? Q.months : v, S = Q ? Q.shortDays : s, O = Q ? Q.shortMonths : y;\r\n            Q = \"\";\r\n            var V = !1;\r\n            R = R && R.getTime ? R : R ? new Date(R) : new Date;\r\n            if (isNaN(R))\r\n                throw SyntaxError(\"invalid date\");\r\n            \"UTC:\" === C.slice(0, 4) && (C = C.slice(4), V = !0);\r\n            Q = V ? \"getUTC\" : \"get\";\r\n            var $ = R[Q + \"Date\"](), W = R[Q + \"Day\"](), Y = R[Q + \"Month\"](), U = R[Q + \"FullYear\"](), I = R[Q + \"Hours\"](), X = R[Q + \"Minutes\"](), a = R[Q + \"Seconds\"](), f = R[Q + \"Milliseconds\"](), b = V ? 0 : R.getTimezoneOffset();\r\n            return Q = C.replace(m, function (c) {\r\n                switch (c) {\r\n                    case \"D\": return $;\r\n                    case \"DD\": return ha($, 2);\r\n                    case \"DDD\": return S[W];\r\n                    case \"DDDD\": return G[W];\r\n                    case \"M\": return Y + 1;\r\n                    case \"MM\": return ha(Y + 1, 2);\r\n                    case \"MMM\": return O[Y];\r\n                    case \"MMMM\": return P[Y];\r\n                    case \"Y\": return parseInt(String(U).slice(-2));\r\n                    case \"YY\": return ha(String(U).slice(-2), 2);\r\n                    case \"YYY\": return ha(String(U).slice(-3), 3);\r\n                    case \"YYYY\": return ha(U, 4);\r\n                    case \"h\": return I % 12 || 12;\r\n                    case \"hh\": return ha(I % 12 || 12, 2);\r\n                    case \"H\": return I;\r\n                    case \"HH\": return ha(I, 2);\r\n                    case \"m\": return X;\r\n                    case \"mm\": return ha(X, 2);\r\n                    case \"s\": return a;\r\n                    case \"ss\": return ha(a, 2);\r\n                    case \"f\": return String(f).slice(0, 1);\r\n                    case \"ff\": return ha(String(f).slice(0, 2), 2);\r\n                    case \"fff\": return ha(String(f).slice(0, 3), 3);\r\n                    case \"t\": return 12 > I ? \"a\" : \"p\";\r\n                    case \"tt\": return 12 > I ? \"am\" : \"pm\";\r\n                    case \"T\": return 12 > I ? \"A\" : \"P\";\r\n                    case \"TT\": return 12 > I ? \"AM\" : \"PM\";\r\n                    case \"K\": return V ? \"UTC\" : (String(R).match(x) || [\"\"]).pop().replace(z, \"\");\r\n                    case \"z\": return (0 < b ? \"-\" : \"+\") + Math.floor(Math.abs(b) / 60);\r\n                    case \"zz\": return (0 < b ? \"-\" : \"+\") + ha(Math.floor(Math.abs(b) / 60), 2);\r\n                    case \"zzz\": return (0 < b ? \"-\" : \"+\") + ha(Math.floor(Math.abs(b) / 60), 2) + ha(Math.abs(b) % 60, 2);\r\n                    default: return c.slice(1, c.length - 1);\r\n                }\r\n            });\r\n        };\r\n    }(), X = function (m, q, s) {\r\n        if (null === m)\r\n            return \"\";\r\n        if (!isFinite(m))\r\n            return m;\r\n        m = Number(m);\r\n        var v = 0 > m ? !0 :\r\n            !1;\r\n        v && (m *= -1);\r\n        var y = s ? s.decimalSeparator : \".\", x = s ? s.digitGroupSeparator : \",\", z = \"\";\r\n        q = String(q);\r\n        var z = 1, R = s = \"\", C = -1, Q = [], G = [], P = 0, S = 0, V = 0, O = !1, $ = 0, R = q.match(/\"[^\"]*\"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\\u2030|./g);\r\n        q = null;\r\n        for (var W = 0; R && W < R.length; W++)\r\n            if (q = R[W], \".\" === q && 0 > C)\r\n                C = W;\r\n            else {\r\n                if (\"%\" === q)\r\n                    z *= 100;\r\n                else if (\"\\u2030\" === q) {\r\n                    z *= 1E3;\r\n                    continue;\r\n                }\r\n                else if (\",\" === q[0] && \".\" === q[q.length - 1]) {\r\n                    z /= Math.pow(1E3, q.length - 1);\r\n                    C = W + q.length - 1;\r\n                    continue;\r\n                }\r\n                else\r\n                    \"E\" !== q[0] && \"e\" !== q[0] || \"0\" !== q[q.length - 1] || (O = !0);\r\n                0 > C ? (Q.push(q), \"#\" === q ||\r\n                    \"0\" === q ? P++ : \",\" === q && V++) : (G.push(q), \"#\" !== q && \"0\" !== q || S++);\r\n            }\r\n        O && (q = Math.floor(m), R = -Math.floor(Math.log(m) / Math.LN10 + 1), $ = 0 === m ? 0 : 0 === q ? -(P + R) : String(q).length - P, z /= Math.pow(10, $));\r\n        0 > C && (C = W);\r\n        z = (m * z).toFixed(S);\r\n        q = z.split(\".\");\r\n        z = (q[0] + \"\").split(\"\");\r\n        m = (q[1] + \"\").split(\"\");\r\n        z && \"0\" === z[0] && z.shift();\r\n        for (O = R = W = S = C = 0; 0 < Q.length;)\r\n            if (q = Q.pop(), \"#\" === q || \"0\" === q)\r\n                if (C++, C === P) {\r\n                    var Y = z, z = [];\r\n                    if (\"0\" === q)\r\n                        for (q = P - S - (Y ? Y.length : 0); 0 < q;)\r\n                            Y.unshift(\"0\"), q--;\r\n                    for (; 0 < Y.length;)\r\n                        s = Y.pop() + s, O++, 0 === O % R && (W === V && 0 < Y.length) &&\r\n                            (s = x + s);\r\n                }\r\n                else\r\n                    0 < z.length ? (s = z.pop() + s, S++, O++) : \"0\" === q && (s = \"0\" + s, S++, O++), 0 === O % R && (W === V && 0 < z.length) && (s = x + s);\r\n            else\r\n                \"E\" !== q[0] && \"e\" !== q[0] || \"0\" !== q[q.length - 1] || !/[eE][+-]*[0]+/.test(q) ? \",\" === q ? (W++, R = O, O = 0, 0 < z.length && (s = x + s)) : s = 1 < q.length && ('\"' === q[0] && '\"' === q[q.length - 1] || \"'\" === q[0] && \"'\" === q[q.length - 1]) ? q.slice(1, q.length - 1) + s : q + s : (q = 0 > $ ? q.replace(\"+\", \"\").replace(\"-\", \"\") : q.replace(\"-\", \"\"), s += q.replace(/[0]+/, function (m) { return ha($, m.length); }));\r\n        x = \"\";\r\n        for (Q = !1; 0 < G.length;)\r\n            q = G.shift(), \"#\" === q || \"0\" ===\r\n                q ? 0 < m.length && 0 !== Number(m.join(\"\")) ? (x += m.shift(), Q = !0) : \"0\" === q && (x += \"0\", Q = !0) : 1 < q.length && ('\"' === q[0] && '\"' === q[q.length - 1] || \"'\" === q[0] && \"'\" === q[q.length - 1]) ? x += q.slice(1, q.length - 1) : \"E\" !== q[0] && \"e\" !== q[0] || \"0\" !== q[q.length - 1] || !/[eE][+-]*[0]+/.test(q) ? x += q : (q = 0 > $ ? q.replace(\"+\", \"\").replace(\"-\", \"\") : q.replace(\"-\", \"\"), x += q.replace(/[0]+/, function (m) { return ha($, m.length); }));\r\n        s += (Q ? y : \"\") + x;\r\n        return v ? \"-\" + s : s;\r\n    }, Pa = function (m) {\r\n        var q = 0, s = 0;\r\n        m = m || window.event;\r\n        m.offsetX || 0 === m.offsetX ? (q = m.offsetX, s = m.offsetY) :\r\n            m.layerX || 0 == m.layerX ? (q = m.layerX, s = m.layerY) : (q = m.pageX - m.target.offsetLeft, s = m.pageY - m.target.offsetTop);\r\n        return { x: q, y: s };\r\n    }, Ya = !0, Ra = window.devicePixelRatio || 1, Ma = 1, ga = Ya ? Ra / Ma : 1, ja = function (m) { for (var q = \"\", s = 0; s < m.length; s++)\r\n        q += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(s)); return q; }, Za = window && window[ja(\"mnb`uhno\")] && window[ja(\"mnb`uhno\")].href && window[ja(\"mnb`uhno\")].href.indexOf && (-1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"b`ow`rkr/bnl\")) || -1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"gdonqhy/bnl\")) ||\r\n        -1 !== window[ja(\"mnb`uhno\")].href.indexOf(ja(\"gheemd\"))), eb = { reset: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==\" },\r\n        pan: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC\" },\r\n        zoom: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=\" },\r\n        menu: { image: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC\" } };\r\n    Y.prototype.setOptions = function (m, q) { if (ra[this._defaultsKey]) {\r\n        var s = ra[this._defaultsKey], v;\r\n        for (v in s)\r\n            \"publicProperties\" !== v && s.hasOwnProperty(v) && (this[v] = m && v in m ? m[v] : q && v in q ? q[v] : s[v]);\r\n    } };\r\n    Y.prototype.get = function (m) { var q = ra[this._defaultsKey]; if (\"options\" === m)\r\n        return this.options && this.options._isPlaceholder ? null : this.options; if (q.hasOwnProperty(m) || q.publicProperties && q.publicProperties.hasOwnProperty(m))\r\n        return this[m]; window.console && window.console.log('Property \"' + m + \"\\\" doesn't exist. Please check for typo.\"); };\r\n    Y.prototype.set = function (m, q, s) {\r\n        s = \"undefined\" === typeof s ? !0 : s;\r\n        var v = ra[this._defaultsKey];\r\n        if (\"options\" === m)\r\n            this.createUserOptions(q);\r\n        else if (v.hasOwnProperty(m) || v.publicProperties && v.publicProperties.hasOwnProperty(m) && \"readWrite\" === v.publicProperties[m])\r\n            this.options._isPlaceholder && this.createUserOptions(), this.options[m] = q;\r\n        else {\r\n            window.console && (v.publicProperties && v.publicProperties.hasOwnProperty(m) && \"readOnly\" === v.publicProperties[m] ? window.console.log('Property \"' + m + '\" is read-only.') : window.console.log('Property \"' +\r\n                m + \"\\\" doesn't exist. Please check for typo.\"));\r\n            return;\r\n        }\r\n        s && (this.chart || this).render();\r\n    };\r\n    Y.prototype.addTo = function (m, q, s, v) {\r\n        v = \"undefined\" === typeof v ? !0 : v;\r\n        var y = ra[this._defaultsKey];\r\n        y.hasOwnProperty(m) || y.publicProperties && y.publicProperties.hasOwnProperty(m) && \"readWrite\" === y.publicProperties[m] ? (this.options._isPlaceholder && this.createUserOptions(), \"undefined\" === typeof this.options[m] && (this.options[m] = []), m = this.options[m], s = \"undefined\" === typeof s || null === s ? m.length : s, m.splice(s, 0, q), v && (this.chart ||\r\n            this).render()) : window.console && (y.publicProperties && y.publicProperties.hasOwnProperty(m) && \"readOnly\" === y.publicProperties[m] ? window.console.log('Property \"' + m + '\" is read-only.') : window.console.log('Property \"' + m + \"\\\" doesn't exist. Please check for typo.\"));\r\n    };\r\n    Y.prototype.createUserOptions = function (m) {\r\n        if (\"undefined\" !== typeof m || this.options._isPlaceholder)\r\n            if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {\r\n                this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] =\r\n                    []);\r\n                var q = this.parent.options[this.optionsName], s = q.length;\r\n                this.options._isPlaceholder || (Da(q), s = q.indexOf(this.options));\r\n                this.options = \"undefined\" === typeof m ? {} : m;\r\n                q[s] = this.options;\r\n            }\r\n            else\r\n                this.options = \"undefined\" === typeof m ? {} : m, m = this.parent.options, this.optionsName ? q = this.optionsName : (q = this._defaultsKey) && 0 !== q.length ? (s = q.charAt(0).toLowerCase(), 1 < q.length && (s = s.concat(q.slice(1))), q = s) : q = void 0, m[q] = this.options;\r\n    };\r\n    Y.prototype.remove = function (m) {\r\n        m = \"undefined\" === typeof m ? !0 : m;\r\n        if (this.isOptionsInArray) {\r\n            var q = this.parent.options[this.optionsName];\r\n            Da(q);\r\n            var s = q.indexOf(this.options);\r\n            0 <= s && q.splice(s, 1);\r\n        }\r\n        else\r\n            delete this.parent.options[this.optionsName];\r\n        m && (this.chart || this).render();\r\n    };\r\n    Y.prototype.updateOption = function (m) {\r\n        var q = ra[this._defaultsKey], s = {}, v = this[m], x = this._themeOptionsKey, z = this._index;\r\n        this.theme && y(x) && y(z) ? s = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[x]) && (null === z ? s = this.parent.themeOptions[x] : 0 < this.parent.themeOptions[x].length &&\r\n            (s = Math.min(this.parent.themeOptions[x].length - 1, z), s = this.parent.themeOptions[x][s]));\r\n        this.themeOptions = s;\r\n        m in q && (v = m in this.options ? this.options[m] : s && m in s ? s[m] : q[m]);\r\n        if (v === this[m])\r\n            return !1;\r\n        this[m] = v;\r\n        return !0;\r\n    };\r\n    Y.prototype.trackChanges = function (m) { if (!this.sessionVariables)\r\n        throw \"Session Variable Store not set\"; this.sessionVariables[m] = this.options[m]; };\r\n    Y.prototype.isBeingTracked = function (m) { this.options._oldOptions || (this.options._oldOptions = {}); return this.options._oldOptions[m] ? !0 : !1; };\r\n    Y.prototype.hasOptionChanged =\r\n        function (m) { if (!this.sessionVariables)\r\n            throw \"Session Variable Store not set\"; return this.sessionVariables[m] !== this.options[m]; };\r\n    Y.prototype.addEventListener = function (m, q, v) { m && q && (this._eventListeners[m] = this._eventListeners[m] || [], this._eventListeners[m].push({ context: v || this, eventHandler: q })); };\r\n    Y.prototype.removeEventListener = function (m, q) { if (m && q && this._eventListeners[m])\r\n        for (var v = this._eventListeners[m], y = 0; y < v.length; y++)\r\n            if (v[y].eventHandler === q) {\r\n                v[y].splice(y, 1);\r\n                break;\r\n            } };\r\n    Y.prototype.removeAllEventListeners =\r\n        function () { this._eventListeners = []; };\r\n    Y.prototype.dispatchEvent = function (m, q, v) { if (m && this._eventListeners[m]) {\r\n        q = q || {};\r\n        for (var y = this._eventListeners[m], x = 0; x < y.length; x++)\r\n            y[x].eventHandler.call(y[x].context, q);\r\n    } \"function\" === typeof this[m] && this[m].call(v || this.chart, q); };\r\n    Ea.prototype.registerSpace = function (m, q) { \"top\" === m ? this._topOccupied += q.height : \"bottom\" === m ? this._bottomOccupied += q.height : \"left\" === m ? this._leftOccupied += q.width : \"right\" === m && (this._rightOccupied += q.width); };\r\n    Ea.prototype.unRegisterSpace =\r\n        function (m, q) { \"top\" === m ? this._topOccupied -= q.height : \"bottom\" === m ? this._bottomOccupied -= q.height : \"left\" === m ? this._leftOccupied -= q.width : \"right\" === m && (this._rightOccupied -= q.width); };\r\n    Ea.prototype.getFreeSpace = function () { return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied }; };\r\n    Ea.prototype.reset = function () {\r\n        this._rightOccupied =\r\n            this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;\r\n    };\r\n    oa(ka, Y);\r\n    ka.prototype._initialize = function () {\r\n        y(this.padding) || \"object\" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = y(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = y(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = y(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = y(this.padding.left) ?\r\n            0 : Number(this.padding.left) | 0);\r\n    };\r\n    ka.prototype.render = function (m) {\r\n        if (0 !== this.fontSize) {\r\n            m && this.ctx.save();\r\n            var q = this.ctx.font;\r\n            this.ctx.textBaseline = this.textBaseline;\r\n            var v = 0;\r\n            this._isDirty && this.measureText(this.ctx);\r\n            this.ctx.translate(this.x, this.y + v);\r\n            \"middle\" === this.textBaseline && (v = -this._lineHeight / 2);\r\n            this.ctx.font = this._getFontString();\r\n            this.ctx.rotate(Math.PI / 180 * this.angle);\r\n            var y = 0, x = this.topPadding, z = null;\r\n            this.ctx.roundRect || Ca(this.ctx);\r\n            (0 < this.borderThickness && this.borderColor || this.backgroundColor) &&\r\n                this.ctx.roundRect(0, v, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\r\n            this.ctx.fillStyle = this.fontColor;\r\n            for (v = 0; v < this._wrappedText.lines.length; v++)\r\n                z = this._wrappedText.lines[v], \"right\" === this.horizontalAlign ? y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding : \"left\" === this.horizontalAlign ? y = this.leftPadding : \"center\" === this.horizontalAlign && (y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding),\r\n                    this.ctx.fillText(z.text, y, x), x += z.height;\r\n            this.ctx.font = q;\r\n            m && this.ctx.restore();\r\n        }\r\n    };\r\n    ka.prototype.setText = function (m) { this.text = m; this._isDirty = !0; this._wrappedText = null; };\r\n    ka.prototype.measureText = function () { this._lineHeight = Va(this.fontFamily, this.fontSize, this.fontWeight); if (null === this.maxWidth)\r\n        throw \"Please set maxWidth and height for TextBlock\"; this._wrapText(this.ctx); this._isDirty = !1; return { width: this.width, height: this.height }; };\r\n    ka.prototype._getLineWithWidth = function (m, q, v) {\r\n        m = String(m);\r\n        if (!m)\r\n            return { text: \"\",\r\n                width: 0 };\r\n        var y = v = 0, x = m.length - 1, z = Infinity;\r\n        for (this.ctx.font = this._getFontString(); y <= x;) {\r\n            var z = Math.floor((y + x) / 2), G = m.substr(0, z + 1);\r\n            v = this.ctx.measureText(G).width;\r\n            if (v < q)\r\n                y = z + 1;\r\n            else if (v > q)\r\n                x = z - 1;\r\n            else\r\n                break;\r\n        }\r\n        v > q && 1 < G.length && (G = G.substr(0, G.length - 1), v = this.ctx.measureText(G).width);\r\n        q = !0;\r\n        if (G.length === m.length || \" \" === m[G.length])\r\n            q = !1;\r\n        q && (m = G.split(\" \"), 1 < m.length && m.pop(), G = m.join(\" \"), v = this.ctx.measureText(G).width);\r\n        return { text: G, width: v };\r\n    };\r\n    ka.prototype._wrapText = function () {\r\n        var m = new String(Ga(String(this.text))), v = [], s = this.ctx.font, y = 0, x = 0;\r\n        this.ctx.font = this._getFontString();\r\n        if (0 === this.frontSize)\r\n            x = y = 0;\r\n        else\r\n            for (; 0 < m.length;) {\r\n                var z = this.maxHeight - (this.topPadding + this.bottomPadding), G = this._getLineWithWidth(m, this.maxWidth - (this.leftPadding + this.rightPadding), !1);\r\n                G.height = this._lineHeight;\r\n                v.push(G);\r\n                var R = x, x = Math.max(x, G.width), y = y + G.height, m = Ga(m.slice(G.text.length, m.length));\r\n                z && y > z && (G = v.pop(), y -= G.height, x = R);\r\n            }\r\n        this._wrappedText = { lines: v, width: x, height: y };\r\n        this.width = x + (this.leftPadding + this.rightPadding);\r\n        this.height = y + (this.topPadding + this.bottomPadding);\r\n        this.ctx.font = s;\r\n    };\r\n    ka.prototype._getFontString = function () { var m; m = \"\" + (this.fontStyle ? this.fontStyle + \" \" : \"\"); m += this.fontWeight ? this.fontWeight + \" \" : \"\"; m += this.fontSize ? this.fontSize + \"px \" : \"\"; var q = this.fontFamily ? this.fontFamily + \"\" : \"\"; !v && q && (q = q.split(\",\")[0], \"'\" !== q[0] && '\"' !== q[0] && (q = \"'\" + q + \"'\")); return m += q; };\r\n    oa(Sa, Y);\r\n    oa(Ia, Y);\r\n    Ia.prototype.render = function () {\r\n        if (this.text) {\r\n            var m = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, v = m.layoutManager.getFreeSpace(), s = v.x1, x = v.y1, z = 0, G = 0, S = this.chart._menuButton && this.chart.exportEnabled && \"top\" === this.verticalAlign ? 22 : 0, R, C;\r\n            \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = v.width - 4 - S * (\"center\" === this.horizontalAlign ? 2 : 1)), G = 0.5 * v.height - this.margin - 2, z = 0) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign || \"right\" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = v.height - 4), G = 0.5 * v.width - this.margin - 2) : \"center\" === this.horizontalAlign && (null ===\r\n                this.maxWidth && (this.maxWidth = v.width - 4), G = 0.5 * v.height - 4));\r\n            var Q;\r\n            y(this.padding) || \"number\" !== typeof this.padding ? y(this.padding) || \"object\" !== typeof this.padding || (Q = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, Q += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, Q *= 1.25) : Q = 2.5 * this.padding;\r\n            this.wrap || (G = Math.min(G, Math.max(1.5 * this.fontSize, this.fontSize + Q)));\r\n            G = new ka(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor,\r\n                fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: G, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: \"top\" });\r\n            Q = G.measureText();\r\n            \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (\"top\" === this.verticalAlign ? (x = v.y1 + 2, C = \"top\") : \"bottom\" === this.verticalAlign &&\r\n                (x = v.y2 - 2 - Q.height, C = \"bottom\"), \"left\" === this.horizontalAlign ? s = v.x1 + 2 : \"center\" === this.horizontalAlign ? s = v.x1 + v.width / 2 - Q.width / 2 : \"right\" === this.horizontalAlign && (s = v.x2 - 2 - Q.width - S), R = this.horizontalAlign, this.width = Q.width, this.height = Q.height) : \"center\" === this.verticalAlign && (\"left\" === this.horizontalAlign ? (s = v.x1 + 2, x = v.y2 - 2 - (this.maxWidth / 2 - Q.width / 2), z = -90, C = \"left\", this.width = Q.height, this.height = Q.width) : \"right\" === this.horizontalAlign ? (s = v.x2 - 2, x = v.y1 + 2 + (this.maxWidth / 2 - Q.width / 2), z = 90, C = \"right\",\r\n                this.width = Q.height, this.height = Q.width) : \"center\" === this.horizontalAlign && (x = m.y1 + (m.height / 2 - Q.height / 2), s = m.x1 + (m.width / 2 - Q.width / 2), C = \"center\", this.width = Q.width, this.height = Q.height), R = \"center\");\r\n            G.x = s;\r\n            G.y = x;\r\n            G.angle = z;\r\n            G.horizontalAlign = R;\r\n            G.render(!0);\r\n            m.layoutManager.registerSpace(C, { width: this.width + (\"left\" === C || \"right\" === C ? this.margin + 2 : 0), height: this.height + (\"top\" === C || \"bottom\" === C ? this.margin + 2 : 0) });\r\n            this.bounds = { x1: s, y1: x, x2: s + this.width, y2: x + this.height };\r\n            this.ctx.textBaseline = \"top\";\r\n        }\r\n    };\r\n    oa(Oa, Y);\r\n    Oa.prototype.render = Ia.prototype.render;\r\n    oa(Ja, Y);\r\n    var La = { addTheme: function (m, v) { ya[m] = v; }, addColorSet: function (m, v) { Aa[m] = v; }, addCultureInfo: function (m, v) { Ka[m] = v; }, formatNumber: function (m, v, s) { s = s || \"en\"; if (Ka[s])\r\n            return X(m, v || \"#,##0.##\", new Ja(s)); throw \"Unknown Culture Name\"; }, formatDate: function (m, v, s) { s = s || \"en\"; if (Ka[s])\r\n            return Ba(m, v || \"DD MMM YYYY\", new Ja(s)); throw \"Unknown Culture Name\"; } };\r\n    \"undefined\" !== typeof module && \"undefined\" !== typeof module.exports ? module.exports = La : \"function\" === typeof define &&\r\n        define.amd ? define([], function () { return La; }) : window.CanvasJS = La;\r\n    La.Chart = function () {\r\n        function m(a, f) { return a.x - f.x; }\r\n        function q(a, f, b) {\r\n            if (a && f && b) {\r\n                b = b + \".\" + f;\r\n                var c = \"image/\" + f;\r\n                a = a.toDataURL(c);\r\n                var e = !1, g = document.createElement(\"a\");\r\n                g.download = b;\r\n                g.href = a;\r\n                if (\"undefined\" !== typeof Blob && new Blob) {\r\n                    for (var h = a.replace(/^data:[a-z\\/]*;base64,/, \"\"), h = atob(h), l = new ArrayBuffer(h.length), l = new Uint8Array(l), t = 0; t < h.length; t++)\r\n                        l[t] = h.charCodeAt(t);\r\n                    f = new Blob([l.buffer], { type: \"image/\" + f });\r\n                    try {\r\n                        window.navigator.msSaveBlob(f, b), e = !0;\r\n                    }\r\n                    catch (k) {\r\n                        g.dataset.downloadurl = [c, g.download, g.href].join(\":\"), g.href = window.URL.createObjectURL(f);\r\n                    }\r\n                }\r\n                if (!e)\r\n                    try {\r\n                        event = document.createEvent(\"MouseEvents\"), event.initMouseEvent(\"click\", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), g.dispatchEvent ? g.dispatchEvent(event) : g.fireEvent && g.fireEvent(\"onclick\");\r\n                    }\r\n                    catch (r) {\r\n                        f = window.open(), f.document.write(\"<img src='\" + a + \"'></img><div>Please right click on the image and save it to your device</div>\"), f.document.close();\r\n                    }\r\n            }\r\n        }\r\n        function s(a, f) {\r\n            f = f || {};\r\n            this.theme =\r\n                y(f.theme) || y(ya[f.theme]) ? \"light1\" : f.theme;\r\n            s.base.constructor.call(this, \"Chart\", null, f, null, null);\r\n            var b = this;\r\n            this._containerId = a;\r\n            this._objectsInitialized = !1;\r\n            this.overlaidCanvasCtx = this.ctx = null;\r\n            this._indexLabels = [];\r\n            this._panTimerId = 0;\r\n            this._lastTouchEventType = \"\";\r\n            this._lastTouchData = null;\r\n            this.isAnimating = !1;\r\n            this.renderCount = 0;\r\n            this.panEnabled = this.disableToolTip = this.animatedRender = !1;\r\n            this._defaultCursor = \"default\";\r\n            this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };\r\n            this._dataInRenderedOrder =\r\n                [];\r\n            if (this.container = \"string\" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {\r\n                this.container.innerHTML = \"\";\r\n                var c = 0, e = 0, c = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;\r\n                this.width = c;\r\n                this.height = e;\r\n                this.x1 = this.y1 = 0;\r\n                this.x2 = this.width;\r\n                this.y2 = this.height;\r\n                this._selectedColorSet = \"undefined\" !== typeof Aa[this.colorSet] ?\r\n                    Aa[this.colorSet] : Aa.colorSet1;\r\n                this._canvasJSContainer = document.createElement(\"div\");\r\n                this._canvasJSContainer.setAttribute(\"class\", \"canvasjs-chart-container\");\r\n                this._canvasJSContainer.style.position = \"relative\";\r\n                this._canvasJSContainer.style.textAlign = \"left\";\r\n                this._canvasJSContainer.style.cursor = \"auto\";\r\n                v || (this._canvasJSContainer.style.height = \"0px\");\r\n                this.container.appendChild(this._canvasJSContainer);\r\n                this.canvas = ua(c, e);\r\n                this._preRenderCanvas = ua(c, e);\r\n                this.canvas.style.position = \"absolute\";\r\n                this.canvas.getContext &&\r\n                    (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext(\"2d\"), this.ctx.textBaseline = \"top\", Ca(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\"), this._preRenderCtx.textBaseline = \"top\", Ca(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ua(c, e), this.plotArea.canvas.style.position = \"absolute\", this.plotArea.canvas.setAttribute(\"class\", \"plotAreaCanvas\"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext(\"2d\")),\r\n                        this.overlaidCanvas = ua(c, e), this.overlaidCanvas.style.position = \"absolute\", this.overlaidCanvas.style.webkitTapHighlightColor = \"transparent\", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext(\"2d\"), this.overlaidCanvasCtx.textBaseline = \"top\", Ca(this.overlaidCanvasCtx)), this._eventManager = new ea(this), this.windowResizeHandler = O(window, \"resize\", function () { b._updateSize() && b.render(); }), this._toolBar = document.createElement(\"div\"),\r\n                        this._toolBar.setAttribute(\"class\", \"canvasjs-chart-toolbar\"), this._toolBar.style.cssText = \"position: absolute; right: 1px; top: 1px;\", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, O(this.overlaidCanvas, \"click\", function (a) { b._mouseEventHandler(a); }), O(this.overlaidCanvas, \"mousemove\", function (a) { b._mouseEventHandler(a); }), O(this.overlaidCanvas, \"mouseup\", function (a) { b._mouseEventHandler(a); }), O(this.overlaidCanvas, \"mousedown\", function (a) {\r\n                        b._mouseEventHandler(a);\r\n                        wa(b._dropdownMenu);\r\n                    }), O(this.overlaidCanvas, \"mouseout\", function (a) { b._mouseEventHandler(a); }), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerDown\" : \"touchstart\", function (a) { b._touchEventHandler(a); }), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerMove\" : \"touchmove\", function (a) { b._touchEventHandler(a); }), O(this.overlaidCanvas, window.navigator.msPointerEnabled ? \"MSPointerUp\" : \"touchend\", function (a) { b._touchEventHandler(a); }), O(this.overlaidCanvas, window.navigator.msPointerEnabled ?\r\n                        \"MSPointerCancel\" : \"touchcancel\", function (a) { b._touchEventHandler(a); }), this.toolTip = new Z(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] });\r\n            }\r\n            else\r\n                window.console && window.console.log('CanvasJS Error: Chart Container with id \"' + this._containerId + '\" was not found');\r\n        }\r\n        function x(a, f) {\r\n            for (var b = [], c, e = 0; e < a.length; e++)\r\n                if (0 == e)\r\n                    b.push(a[0]);\r\n                else {\r\n                    var g, h, l;\r\n                    l = e - 1;\r\n                    g = 0 === l ? 0 : l - 1;\r\n                    h = l === a.length - 1 ? l : l + 1;\r\n                    c = Math.abs((a[h].x - a[g].x) / (0 === a[h].x - a[l].x ? 0.01 : a[h].x - a[l].x)) * (f - 1) / 2 + 1;\r\n                    var t = (a[h].x - a[g].x) / c;\r\n                    c = (a[h].y - a[g].y) / c;\r\n                    b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? { x: a[l].x + t / 3, y: a[l].y + c / 3 } : { x: a[l].x, y: a[l].y + c / 9 };\r\n                    l = e;\r\n                    g = 0 === l ? 0 : l - 1;\r\n                    h = l === a.length - 1 ? l : l + 1;\r\n                    c = Math.abs((a[h].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (f - 1) / 2 + 1;\r\n                    t = (a[h].x - a[g].x) / c;\r\n                    c = (a[h].y - a[g].y) / c;\r\n                    b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? { x: a[l].x - t / 3, y: a[l].y - c / 3 } : { x: a[l].x, y: a[l].y - c / 9 };\r\n                    b[b.length] = a[e];\r\n                }\r\n            return b;\r\n        }\r\n        function z(a, f, b, c, e, g, h, l, t, k) {\r\n            var r = 0;\r\n            k ? (h.color = g, l.color = g) : k = 1;\r\n            r = t ? Math.abs(e - b) : Math.abs(c - f);\r\n            r = 0 < h.trimLength ? Math.abs(r * h.trimLength / 100) : Math.abs(r - h.length);\r\n            t ? (b += r / 2, e -= r / 2) : (f += r / 2, c -= r / 2);\r\n            var r = 1 === Math.round(h.thickness) % 2 ? 0.5 : 0, p = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0;\r\n            a.save();\r\n            a.globalAlpha = k;\r\n            a.strokeStyle = l.color || g;\r\n            a.lineWidth = l.thickness || 2;\r\n            a.setLineDash && a.setLineDash(G(l.dashType, l.thickness));\r\n            a.beginPath();\r\n            t && 0 < l.thickness ? (a.moveTo(c - h.thickness / 2, Math.round((b + e) / 2) - p), a.lineTo(f +\r\n                h.thickness / 2, Math.round((b + e) / 2) - p)) : 0 < l.thickness && (a.moveTo(Math.round((f + c) / 2) - p, b + h.thickness / 2), a.lineTo(Math.round((f + c) / 2) - p, e - h.thickness / 2));\r\n            a.stroke();\r\n            a.strokeStyle = h.color || g;\r\n            a.lineWidth = h.thickness || 2;\r\n            a.setLineDash && a.setLineDash(G(h.dashType, h.thickness));\r\n            a.beginPath();\r\n            t && 0 < h.thickness ? (a.moveTo(c - r, b), a.lineTo(c - r, e), a.moveTo(f + r, b), a.lineTo(f + r, e)) : 0 < h.thickness && (a.moveTo(f, b + r), a.lineTo(c, b + r), a.moveTo(f, e - r), a.lineTo(c, e - r));\r\n            a.stroke();\r\n            a.restore();\r\n        }\r\n        function P(a, f, b, c, e) {\r\n            if (null ===\r\n                a || \"undefined\" === typeof a)\r\n                return \"undefined\" === typeof b ? f : b;\r\n            a = parseFloat(a.toString()) * (0 <= a.toString().indexOf(\"%\") ? f / 100 : 1);\r\n            \"undefined\" !== typeof c && (a = Math.min(c, a), \"undefined\" !== typeof e && (a = Math.max(e, a)));\r\n            return !isNaN(a) && a <= f && 0 <= a ? a : \"undefined\" === typeof b ? f : b;\r\n        }\r\n        function U(a, f) {\r\n            U.base.constructor.call(this, \"Legend\", \"legend\", f, null, a);\r\n            this.chart = a;\r\n            this.canvas = a.canvas;\r\n            this.ctx = this.chart.ctx;\r\n            this.ghostCtx = this.chart._eventManager.ghostCtx;\r\n            this.items = [];\r\n            this.optionsName = \"legend\";\r\n            this.height = this.width =\r\n                0;\r\n            this.orientation = null;\r\n            this.dataSeries = [];\r\n            this.bounds = { x1: null, y1: null, x2: null, y2: null };\r\n            \"undefined\" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));\r\n            this.lineHeight = Va(this.fontFamily, this.fontSize, this.fontWeight);\r\n            this.horizontalSpacing = this.fontSize;\r\n        }\r\n        function R(a, f, b, c) {\r\n            R.base.constructor.call(this, \"DataSeries\", \"data\", f, b, a);\r\n            this.chart = a;\r\n            this.canvas = a.canvas;\r\n            this._ctx = a.canvas.ctx;\r\n            this.index = b;\r\n            this.noDataPointsInPlotArea = 0;\r\n            this.id = c;\r\n            this.chart._eventManager.objectMap[c] =\r\n                { id: c, objectType: \"dataSeries\", dataSeriesIndex: b };\r\n            a = f.dataPoints ? f.dataPoints.length : 0;\r\n            this.dataPointEOs = [];\r\n            for (f = 0; f < a; f++)\r\n                this.dataPointEOs[f] = {};\r\n            this.dataPointIds = [];\r\n            this.plotUnit = [];\r\n            this.axisY = this.axisX = null;\r\n            this.optionsName = \"data\";\r\n            this.isOptionsInArray = !0;\r\n            null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);\r\n            this.axisPlacement = this.getDefaultAxisPlacement();\r\n            \"undefined\" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));\r\n        }\r\n        function C(a, f, b, c, e, g) {\r\n            C.base.constructor.call(this, \"Axis\", f, b, c, a);\r\n            this.chart = a;\r\n            this.canvas = a.canvas;\r\n            this.ctx = a.ctx;\r\n            this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;\r\n            this.labels = [];\r\n            this.dataSeries = [];\r\n            this._stripLineLabels = this._ticks = this._labels = null;\r\n            this.dataInfo = { min: Infinity, max: -Infinity, viewPortMin: Infinity, viewPortMax: -Infinity, minDiff: Infinity };\r\n            this.isOptionsInArray = !0;\r\n            \"axisX\" === e ? (\"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisX\", y(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] =\r\n                {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = \"axisX2\", y(this.chart.sessionVariables.axisX2[c]) && (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType = null)) : \"left\" === g || \"bottom\" === g ? (this.optionsName = \"axisY\", y(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = \"axisY2\",\r\n                y(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]);\r\n            \"undefined\" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));\r\n            \"undefined\" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));\r\n            this.type = e;\r\n            \"axisX\" !== e || b && \"undefined\" !== typeof b.gridThickness || (this.gridThickness = 0);\r\n            this._position = g;\r\n            this.lineCoordinates =\r\n                { x1: null, y1: null, x2: null, y2: null, width: null };\r\n            this.labelAngle = (this.labelAngle % 360 + 360) % 360;\r\n            90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);\r\n            this.options.scaleBreaks && (this.scaleBreaks = new Q(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));\r\n            this.stripLines = [];\r\n            if (this.options.stripLines && 0 < this.options.stripLines.length)\r\n                for (a = 0; a < this.options.stripLines.length; a++)\r\n                    this.stripLines.push(new fa(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));\r\n            this.options.crosshair && (this.crosshair = new ha(this.chart, this.options.crosshair, this));\r\n            this._titleTextBlock = null;\r\n            this.hasOptionChanged(\"viewportMinimum\") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);\r\n            this.hasOptionChanged(\"viewportMinimum\") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum =\r\n                null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;\r\n            this.hasOptionChanged(\"viewportMaximum\") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);\r\n            this.hasOptionChanged(\"viewportMaximum\") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;\r\n            null !== this.minimum && null !== this.viewportMinimum &&\r\n                (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\r\n            null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\r\n            this.trackChanges(\"viewportMinimum\");\r\n            this.trackChanges(\"viewportMaximum\");\r\n        }\r\n        function Q(a, f, b, c) {\r\n            Q.base.constructor.call(this, \"ScaleBreaks\", \"scaleBreaks\", f, null, c);\r\n            this.id = b;\r\n            this.chart = a;\r\n            this.ctx = this.chart.ctx;\r\n            this.axis = c;\r\n            this.optionsName = \"scaleBreaks\";\r\n            this.isOptionsInArray = !1;\r\n            this._appliedBreaks = [];\r\n            this.customBreaks =\r\n                [];\r\n            this.autoBreaks = [];\r\n            \"string\" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.spacing && (this.spacing = 8);\r\n            this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));\r\n            if (this.options.customBreaks && 0 < this.options.customBreaks.length) {\r\n                for (a = 0; a < this.options.customBreaks.length; a++)\r\n                    this.customBreaks.push(new ba(this.chart, \"customBreaks\", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), \"number\" === typeof this.customBreaks[a].startValue && (\"number\" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);\r\n                this._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue; });\r\n                for (a = 0; a < this._appliedBreaks.length - 1; a++)\r\n                    this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log(\"CanvasJS Error: Breaks \" + a + \" and \" + (a + 1) + \" are overlapping.\"), this._appliedBreaks.splice(a, 2), a--);\r\n            }\r\n        }\r\n        function ba(a, f, b, c, e, g) {\r\n            ba.base.constructor.call(this, \"Break\", f, b, c, g);\r\n            this.id = e;\r\n            this.chart = a;\r\n            this.ctx = this.chart.ctx;\r\n            this.scaleBreaks = g;\r\n            this.optionsName = f;\r\n            this.isOptionsInArray = !0;\r\n            this.type = b.type ? this.type : g.type;\r\n            this.fillOpacity = y(b.fillOpacity) ? g.fillOpacity : this.fillOpacity;\r\n            this.lineThickness = y(b.lineThickness) ? g.lineThickness :\r\n                this.lineThickness;\r\n            this.color = b.color ? this.color : g.color;\r\n            this.lineColor = b.lineColor ? this.lineColor : g.lineColor;\r\n            this.lineDashType = b.lineDashType ? this.lineDashType : g.lineDashType;\r\n            !y(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());\r\n            !y(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());\r\n            \"number\" === typeof this.startValue && (\"number\" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue =\r\n                a);\r\n            this.spacing = \"undefined\" === typeof b.spacing ? g.spacing : b.spacing;\r\n            \"string\" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + \"%\") : \"number\" !== typeof this.options.spacing && (this.spacing = g.spacing);\r\n            this.size = g.parent.logarithmic ? 1 : 0;\r\n        }\r\n        function fa(a, f, b, c, e) {\r\n            fa.base.constructor.call(this, \"StripLine\", \"stripLines\", f, b, e);\r\n            this.id = c;\r\n            this.chart = a;\r\n            this.ctx = this.chart.ctx;\r\n            this.label = this.label;\r\n            this.axis = e;\r\n            this.optionsName =\r\n                \"stripLines\";\r\n            this.isOptionsInArray = !0;\r\n            this._thicknessType = \"pixel\";\r\n            null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);\r\n        }\r\n        function ha(a, f, b) {\r\n            ha.base.constructor.call(this, \"Crosshair\", \"crosshair\", f, null, b);\r\n            this.chart = a;\r\n            this.ctx = this.chart.ctx;\r\n            this.axis = b;\r\n            this.optionsName = \"crosshair\";\r\n            this._thicknessType = \"pixel\";\r\n        }\r\n        function Z(a, f) {\r\n            Z.base.constructor.call(this, \"ToolTip\", \"toolTip\", f, null, a);\r\n            this.chart = a;\r\n            this.canvas = a.canvas;\r\n            this.ctx = this.chart.ctx;\r\n            this.currentDataPointIndex = this.currentSeriesIndex = -1;\r\n            this._timerId = 0;\r\n            this._prevY = this._prevX = NaN;\r\n            this.containerTransitionDuration = 0.1;\r\n            this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);\r\n            this.optionsName = \"toolTip\";\r\n            this._initialize();\r\n        }\r\n        function ea(a) { this.chart = a; this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.previousDataPointEventObject = null; this.ghostCanvas = ua(this.chart.width, this.chart.height); this.ghostCtx = this.ghostCanvas.getContext(\"2d\"); this.mouseoveredObjectMaps = []; }\r\n        function ja(a) { this.chart = a; this.ctx = this.chart.plotArea.ctx; this.animations = []; this.animationRequestId = null; }\r\n        oa(s, Y);\r\n        s.prototype.destroy = function () {\r\n            var a = window, f = this.windowResizeHandler;\r\n            a.removeEventListener ?\r\n                a.removeEventListener(\"resize\", f) : a.detachEvent && a.detachEvent(\"onresize\", f);\r\n        };\r\n        s.prototype._updateOptions = function () {\r\n            var a = this;\r\n            this.updateOption(\"width\");\r\n            this.updateOption(\"height\");\r\n            this.updateOption(\"dataPointWidth\");\r\n            this.updateOption(\"dataPointMinWidth\");\r\n            this.updateOption(\"dataPointMaxWidth\");\r\n            this.updateOption(\"interactivityEnabled\");\r\n            this.updateOption(\"theme\");\r\n            this.updateOption(\"colorSet\") && (this._selectedColorSet = \"undefined\" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1);\r\n            this.updateOption(\"backgroundColor\");\r\n            this.backgroundColor || (this.backgroundColor = \"rgba(0,0,0,0)\");\r\n            this.updateOption(\"culture\");\r\n            this._cultureInfo = new Ja(this.options.culture);\r\n            this.updateOption(\"animationEnabled\");\r\n            this.animationEnabled = this.animationEnabled && v;\r\n            this.updateOption(\"animationDuration\");\r\n            this.updateOption(\"rangeChanging\");\r\n            this.updateOption(\"rangeChanged\");\r\n            this.updateOption(\"exportEnabled\");\r\n            this.updateOption(\"exportFileName\");\r\n            this.updateOption(\"zoomType\");\r\n            if (this.options.zoomEnabled) {\r\n                if (!this._zoomButton) {\r\n                    var f = !1;\r\n                    wa(this._zoomButton =\r\n                        document.createElement(\"button\"));\r\n                    va(this, this._zoomButton, \"pan\");\r\n                    this._toolBar.appendChild(this._zoomButton);\r\n                    this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor;\r\n                    O(this._zoomButton, \"touchstart\", function (a) { f = !0; });\r\n                    O(this._zoomButton, \"click\", function () { a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, va(a, a._zoomButton, \"zoom\")) : (a.zoomEnabled = !0, a.panEnabled = !1, va(a, a._zoomButton, \"pan\")); a.render(); });\r\n                    O(this._zoomButton, \"mouseover\", function () {\r\n                        f ? f = !1 : (pa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" }));\r\n                    });\r\n                    O(this._zoomButton, \"mouseout\", function () {\r\n                        f || (pa(a, a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._zoomButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\r\n                    });\r\n                }\r\n                this._resetButton || (f = !1, wa(this._resetButton = document.createElement(\"button\")), va(this, this._resetButton, \"reset\"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), O(this._resetButton, \"touchstart\", function (a) { f = !0; }), O(this._resetButton, \"click\", function () {\r\n                    a.toolTip.hide();\r\n                    a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled =\r\n                        !1, va(a, a._zoomButton, \"pan\"), a._defaultCursor = \"default\", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1);\r\n                    if (a.sessionVariables.axisX)\r\n                        for (var c = 0; c < a.sessionVariables.axisX.length; c++)\r\n                            a.sessionVariables.axisX[c].newViewportMinimum = null, a.sessionVariables.axisX[c].newViewportMaximum = null;\r\n                    if (a.sessionVariables.axisX2)\r\n                        for (c = 0; c < a.sessionVariables.axisX2.length; c++)\r\n                            a.sessionVariables.axisX2[c].newViewportMinimum = null, a.sessionVariables.axisX2[c].newViewportMaximum = null;\r\n                    if (a.sessionVariables.axisY)\r\n                        for (c = 0; c < a.sessionVariables.axisY.length; c++)\r\n                            a.sessionVariables.axisY[c].newViewportMinimum = null, a.sessionVariables.axisY[c].newViewportMaximum = null;\r\n                    if (a.sessionVariables.axisY2)\r\n                        for (c = 0; c < a.sessionVariables.axisY2.length; c++)\r\n                            a.sessionVariables.axisY2[c].newViewportMinimum = null, a.sessionVariables.axisY2[c].newViewportMaximum = null;\r\n                    a.resetOverlayedCanvas();\r\n                    wa(a._zoomButton, a._resetButton);\r\n                    a._dispatchRangeEvent(\"rangeChanging\", \"reset\");\r\n                    a.render();\r\n                    a._dispatchRangeEvent(\"rangeChanged\", \"reset\");\r\n                }), O(this._resetButton, \"mouseover\", function () { f || (pa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.hoverFfontColorOnHoverontColor, transition: \"0.4s\", WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" })); }), O(this._resetButton, \"mouseout\", function () {\r\n                    f || (pa(a, a._resetButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: \"0.4s\",\r\n                        WebkitTransition: \"0.4s\" }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._resetButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\r\n                }), this.overlaidCanvas.style.cursor = a._defaultCursor);\r\n                this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute(\"state\") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Na(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1));\r\n            }\r\n            else\r\n                this.panEnabled = this.zoomEnabled =\r\n                    !1;\r\n            this._menuButton ? this.exportEnabled ? Na(this._menuButton) : wa(this._menuButton) : this.exportEnabled && v && (f = !1, this._menuButton = document.createElement(\"button\"), va(this, this._menuButton, \"menu\"), this._toolBar.appendChild(this._menuButton), O(this._menuButton, \"touchstart\", function (a) { f = !0; }), O(this._menuButton, \"click\", function () {\r\n                \"none\" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= (new Date).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = \"block\", a._menuButton.blur(),\r\n                    a._dropdownMenu.focus());\r\n            }, !0), O(this._menuButton, \"mouseover\", function () { f || (pa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(100%)\", filter: \"invert(100%)\" })); }, !0), O(this._menuButton, \"mouseout\", function () {\r\n                f || (pa(a, a._menuButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor }), 0 >= navigator.userAgent.search(\"MSIE\") && pa(a, a._menuButton.childNodes[0], { WebkitFilter: \"invert(0%)\", filter: \"invert(0%)\" }));\r\n            }, !0));\r\n            if (!this._dropdownMenu && this.exportEnabled && v) {\r\n                f = !1;\r\n                this._dropdownMenu = document.createElement(\"div\");\r\n                this._dropdownMenu.setAttribute(\"tabindex\", -1);\r\n                var b = -1 !== this.theme.indexOf(\"dark\") ? \"black\" : \"#888888\";\r\n                this._dropdownMenu.style.cssText = \"position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:\" +\r\n                    this.toolbar.backgroundColor + \";box-shadow: 2px 2px 10px \" + b;\r\n                a._dropdownMenu.style.display = \"none\";\r\n                this._toolBar.appendChild(this._dropdownMenu);\r\n                O(this._dropdownMenu, \"blur\", function () { wa(a._dropdownMenu); a._dropDownCloseTime = new Date; }, !0);\r\n                b = document.createElement(\"div\");\r\n                b.style.cssText = \"padding: 12px 8px 12px 8px\";\r\n                b.innerHTML = this._cultureInfo.printText;\r\n                b.style.backgroundColor = this.toolbar.backgroundColor;\r\n                b.style.color = this.toolbar.fontColor;\r\n                this._dropdownMenu.appendChild(b);\r\n                O(b, \"touchstart\", function (a) {\r\n                    f =\r\n                        !0;\r\n                });\r\n                O(b, \"mouseover\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, !0);\r\n                O(b, \"mouseout\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor); }, !0);\r\n                O(b, \"click\", function () { a.print(); wa(a._dropdownMenu); }, !0);\r\n                b = document.createElement(\"div\");\r\n                b.style.cssText = \"padding: 12px 8px 12px 8px\";\r\n                b.innerHTML = this._cultureInfo.saveJPGText;\r\n                b.style.backgroundColor = this.toolbar.backgroundColor;\r\n                b.style.color = this.toolbar.fontColor;\r\n                this._dropdownMenu.appendChild(b);\r\n                O(b, \"touchstart\", function (a) { f = !0; });\r\n                O(b, \"mouseover\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, !0);\r\n                O(b, \"mouseout\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor); }, !0);\r\n                O(b, \"click\", function () { q(a.canvas, \"jpeg\", a.exportFileName); wa(a._dropdownMenu); }, !0);\r\n                b = document.createElement(\"div\");\r\n                b.style.cssText =\r\n                    \"padding: 12px 8px 12px 8px\";\r\n                b.innerHTML = this._cultureInfo.savePNGText;\r\n                b.style.backgroundColor = this.toolbar.backgroundColor;\r\n                b.style.color = this.toolbar.fontColor;\r\n                this._dropdownMenu.appendChild(b);\r\n                O(b, \"touchstart\", function (a) { f = !0; });\r\n                O(b, \"mouseover\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover); }, !0);\r\n                O(b, \"mouseout\", function () { f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor); }, !0);\r\n                O(b, \"click\", function () { q(a.canvas, \"png\", a.exportFileName); wa(a._dropdownMenu); }, !0);\r\n            }\r\n            \"none\" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? va(a, a._zoomButton, \"zoom\") : va(a, a._zoomButton, \"pan\"), a._resetButton.getAttribute(\"state\") !== a._cultureInfo.resetText && va(a, a._resetButton, \"reset\"));\r\n            this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);\r\n            for (var c in this.toolTip.options)\r\n                this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c);\r\n        };\r\n        s.prototype._updateSize = function () {\r\n            var a = 0, f = 0;\r\n            this.options.width ? a = this.width : this.width = a = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;\r\n            this.options.height ? f = this.height : this.height = f = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;\r\n            return this.canvas.width !== a * ga || this.canvas.height !== f * ga ? (Ha(this.canvas, a, f), Ha(this._preRenderCanvas, a, f), Ha(this.overlaidCanvas, a, f), Ha(this._eventManager.ghostCanvas, a, f), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height },\r\n                !0) : !1;\r\n        };\r\n        s.prototype._initialize = function () {\r\n            this.toolbar = new Sa(this, this.options.toolbar);\r\n            this._animator ? this._animator.cancelAllAnimations() : this._animator = new ja(this);\r\n            this.removeAllEventListeners();\r\n            this.disableToolTip = !1;\r\n            this._axes = [];\r\n            this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;\r\n            this.animationRequestId && this.cancelRequestAnimFrame.call(window, this.animationRequestId);\r\n            this._updateOptions();\r\n            this.animatedRender = v && this.animationEnabled && 0 === this.renderCount;\r\n            this._updateSize();\r\n            this.clearCanvas();\r\n            this.ctx.beginPath();\r\n            this.axisX = [];\r\n            this.axisX2 = [];\r\n            this.axisY = [];\r\n            this.axisY2 = [];\r\n            this._indexLabels = [];\r\n            this._dataInRenderedOrder = [];\r\n            this._events = [];\r\n            this._eventManager && this._eventManager.reset();\r\n            this.plotInfo = { axisPlacement: null, plotTypes: [] };\r\n            this.layoutManager = new Ea(0, 0, this.width, this.height, 2);\r\n            this.plotArea.layoutManager && this.plotArea.layoutManager.reset();\r\n            this.data = [];\r\n            var a = 0, f = null;\r\n            if (this.options.data) {\r\n                for (var b = 0; b < this.options.data.length; b++)\r\n                    if (a++, !this.options.data[b].type ||\r\n                        0 <= s._supportedChartTypes.indexOf(this.options.data[b].type)) {\r\n                        var c = new R(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId);\r\n                        \"error\" === c.type && (c.linkedDataSeriesIndex = y(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || \"number\" !== typeof c.linkedDataSeriesIndex || \"error\" === this.options.data[c.linkedDataSeriesIndex].type) && (c.linkedDataSeriesIndex = null);\r\n                        null === c.name &&\r\n                            (c.name = \"DataSeries \" + a);\r\n                        null === c.color ? 1 < this.options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"candlestick\" === c.type || \"ohlc\" === c.type || \"waterfall\" ===\r\n                            c.type || \"boxAndWhisker\" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color];\r\n                        null === c.markerSize && ((\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || 0 <= c.type.toLowerCase().indexOf(\"area\")) && c.dataPoints && c.dataPoints.length < this.width / 16 || \"scatter\" === c.type) && (c.markerSize = 8);\r\n                        \"bubble\" !== c.type && \"scatter\" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) { return a.x; }) && c.dataPoints.sort(m) : c.dataPoints.sort(m));\r\n                        this.data.push(c);\r\n                        var e = c.axisPlacement, f = f || e, g;\r\n                        \"normal\" === e ? \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"normal\") : \"xySwapped\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or pie chart' : \"none\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with pie chart' : null ===\r\n                            this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"xySwapped\") : \"none\" === e ? \"normal\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with line, area, column or bar chart' : \"xySwapped\" === this.plotInfo.axisPlacement ? g = 'You cannot combine \"' + c.type + '\" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = \"none\") : null === e && \"none\" === this.plotInfo.axisPlacement && (g = 'You cannot combine \"' + c.type + '\" with pie chart');\r\n                        if (g && window.console) {\r\n                            window.console.log(g);\r\n                            return;\r\n                        }\r\n                    }\r\n                for (b = 0; b < this.data.length; b++) {\r\n                    if (\"none\" == f && \"error\" === this.data[b].type && window.console) {\r\n                        window.console.log('You cannot combine \"' + c.type + '\" with error chart');\r\n                        return;\r\n                    }\r\n                    \"error\" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = f || \"normal\", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex]);\r\n                }\r\n            }\r\n            this._objectsInitialized = !0;\r\n        };\r\n        s._supportedChartTypes = Da(\"line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall\".split(\" \"));\r\n        s.prototype.render = function (a) {\r\n            a && (this.options = a);\r\n            this._initialize();\r\n            var f = [];\r\n            for (a = 0; a < this.data.length; a++)\r\n                if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) {\r\n                    if (!this.data[a].axisYType || \"primary\" === this.data[a].axisYType)\r\n                        if (this.options.axisY && 0 < this.options.axisY.length) {\r\n                            if (!this.axisY.length)\r\n                                for (var b = 0; b < this.options.axisY.length; b++)\r\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new C(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"left\")) :\r\n                                        \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new C(this, \"axisY\", this.options.axisY[b], b, \"axisY\", \"bottom\"));\r\n                            this.data[a].axisY = this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0];\r\n                            this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a]);\r\n                        }\r\n                        else\r\n                            this.axisY.length || (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"left\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new C(this, \"axisY\", this.options.axisY, 0, \"axisY\", \"bottom\"))), this.data[a].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[a]);\r\n                    if (\"secondary\" === this.data[a].axisYType)\r\n                        if (this.options.axisY2 && 0 < this.options.axisY2.length) {\r\n                            if (!this.axisY2.length)\r\n                                for (b = 0; b < this.options.axisY2.length; b++)\r\n                                    \"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new C(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new C(this, \"axisY2\", this.options.axisY2[b], b, \"axisY\", \"top\"));\r\n                            this.data[a].axisY = this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0];\r\n                            this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a]);\r\n                        }\r\n                        else\r\n                            this.axisY2.length || (\"normal\" === this.plotInfo.axisPlacement ?\r\n                                this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"right\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new C(this, \"axisY2\", this.options.axisY2, 0, \"axisY\", \"top\"))), this.data[a].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[a]);\r\n                    if (!this.data[a].axisXType || \"primary\" === this.data[a].axisXType)\r\n                        if (this.options.axisX && 0 < this.options.axisX.length) {\r\n                            if (!this.axisX.length)\r\n                                for (b = 0; b < this.options.axisX.length; b++)\r\n                                    \"normal\" === this.plotInfo.axisPlacement ?\r\n                                        this._axes.push(this.axisX[b] = new C(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new C(this, \"axisX\", this.options.axisX[b], b, \"axisX\", \"left\"));\r\n                            this.data[a].axisX = this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0];\r\n                            this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a]);\r\n                        }\r\n                        else\r\n                            this.axisX.length ||\r\n                                (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"bottom\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new C(this, \"axisX\", this.options.axisX, 0, \"axisX\", \"left\"))), this.data[a].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[a]);\r\n                    if (\"secondary\" === this.data[a].axisXType)\r\n                        if (this.options.axisX2 && 0 < this.options.axisX2.length) {\r\n                            if (!this.axisX2.length)\r\n                                for (b = 0; b < this.options.axisX2.length; b++)\r\n                                    \"normal\" ===\r\n                                        this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] = new C(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new C(this, \"axisX2\", this.options.axisX2[b], b, \"axisX\", \"right\"));\r\n                            this.data[a].axisX = this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0];\r\n                            this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a]);\r\n                        }\r\n                        else\r\n                            this.axisX2.length ||\r\n                                (\"normal\" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"top\")) : \"xySwapped\" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new C(this, \"axisX2\", this.options.axisX2, 0, \"axisX\", \"right\"))), this.data[a].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[a]);\r\n                }\r\n            if (this.axisY) {\r\n                for (b = 1; b < this.axisY.length; b++)\r\n                    \"undefined\" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0);\r\n                for (b = 0; b < this.axisY.length -\r\n                    1; b++)\r\n                    \"undefined\" === typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10);\r\n            }\r\n            if (this.axisY2) {\r\n                for (b = 1; b < this.axisY2.length; b++)\r\n                    \"undefined\" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0);\r\n                for (b = 0; b < this.axisY2.length - 1; b++)\r\n                    \"undefined\" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10);\r\n            }\r\n            this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && \"undefined\" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness =\r\n                0 : 0 < this.axisY2[0].gridThickness && \"undefined\" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));\r\n            if (this.axisX)\r\n                for (b = 0; b < this.axisX.length; b++)\r\n                    \"undefined\" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0);\r\n            if (this.axisX2)\r\n                for (b = 0; b < this.axisX2.length; b++)\r\n                    \"undefined\" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0);\r\n            this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness &&\r\n                \"undefined\" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && \"undefined\" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));\r\n            b = !1;\r\n            if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled))\r\n                for (a = 0; a < this._axes.length; a++)\r\n                    if (null !== this._axes[a].viewportMinimum || null !== this._axes[a].viewportMaximum) {\r\n                        b = !0;\r\n                        break;\r\n                    }\r\n            b ? (Na(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid \" +\r\n                this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + \"px solid \" + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + \"px solid \" + this.toolbar.borderColor) : (wa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + \"px solid transparent\", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));\r\n            cb(this);\r\n            this._processData();\r\n            this.options.title && (this.title = new Ia(this, this.options.title), this.title.dockInsidePlotArea ? f.push(this.title) : this.title.render());\r\n            if (this.options.subtitles)\r\n                for (this.subtitles = [], a = 0; a < this.options.subtitles.length; a++)\r\n                    b = new Oa(this, this.options.subtitles[a], a), this.subtitles.push(b), b.dockInsidePlotArea ? f.push(b) : b.render();\r\n            this.legend = new U(this, this.options.legend);\r\n            for (a = 0; a < this.data.length; a++)\r\n                (this.data[a].showInLegend || \"pie\" === this.data[a].type || \"doughnut\" === this.data[a].type || \"funnel\" === this.data[a].type || \"pyramid\" === this.data[a].type) &&\r\n                    this.legend.dataSeries.push(this.data[a]);\r\n            this.legend.dockInsidePlotArea ? f.push(this.legend) : this.legend.render();\r\n            for (a = 0; a < this._axes.length; a++)\r\n                if (this._axes[a].scaleBreaks && this._axes[a].scaleBreaks._appliedBreaks.length) {\r\n                    v ? (this._breaksCanvas = ua(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext(\"2d\")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);\r\n                    break;\r\n                }\r\n            this._preRenderCanvas = ua(this.width, this.height);\r\n            this._preRenderCtx = this._preRenderCanvas.getContext(\"2d\");\r\n            if (\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement)\r\n                C.setLayoutAndRender(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());\r\n            else if (\"none\" === this.plotInfo.axisPlacement)\r\n                this.preparePlotArea();\r\n            else\r\n                return;\r\n            for (a = 0; a < f.length; a++)\r\n                f[a].render();\r\n            var c = [];\r\n            if (this.animatedRender) {\r\n                var e = ua(this.width, this.height);\r\n                e.getContext(\"2d\").drawImage(this.canvas, 0, 0, this.width, this.height);\r\n            }\r\n            db(this);\r\n            var f = this.ctx.miterLimit, g;\r\n            this.ctx.miterLimit = 3;\r\n            v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = \"source-atop\", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));\r\n            for (a = 0; a < this.plotInfo.plotTypes.length; a++)\r\n                for (var h = this.plotInfo.plotTypes[a], l = 0; l < h.plotUnits.length; l++) {\r\n                    var t = h.plotUnits[l], k = null;\r\n                    t.targetCanvas = null;\r\n                    this.animatedRender && (t.targetCanvas = ua(this.width, this.height), t.targetCanvasCtx = t.targetCanvas.getContext(\"2d\"), g = t.targetCanvasCtx.miterLimit, t.targetCanvasCtx.miterLimit = 3);\r\n                    \"line\" === t.type ? k = this.renderLine(t) : \"stepLine\" === t.type ? k = this.renderStepLine(t) : \"spline\" === t.type ? k = this.renderSpline(t) : \"column\" === t.type ? k = this.renderColumn(t) : \"bar\" === t.type ? k = this.renderBar(t) : \"area\" === t.type ? k = this.renderArea(t) : \"stepArea\" === t.type ? k = this.renderStepArea(t) : \"splineArea\" ===\r\n                        t.type ? k = this.renderSplineArea(t) : \"stackedColumn\" === t.type ? k = this.renderStackedColumn(t) : \"stackedColumn100\" === t.type ? k = this.renderStackedColumn100(t) : \"stackedBar\" === t.type ? k = this.renderStackedBar(t) : \"stackedBar100\" === t.type ? k = this.renderStackedBar100(t) : \"stackedArea\" === t.type ? k = this.renderStackedArea(t) : \"stackedArea100\" === t.type ? k = this.renderStackedArea100(t) : \"bubble\" === t.type ? k = k = this.renderBubble(t) : \"scatter\" === t.type ? k = this.renderScatter(t) : \"pie\" === t.type ? this.renderPie(t) : \"doughnut\" === t.type ?\r\n                        this.renderPie(t) : \"funnel\" === t.type ? k = this.renderFunnel(t) : \"pyramid\" === t.type ? k = this.renderFunnel(t) : \"candlestick\" === t.type ? k = this.renderCandlestick(t) : \"ohlc\" === t.type ? k = this.renderCandlestick(t) : \"rangeColumn\" === t.type ? k = this.renderRangeColumn(t) : \"error\" === t.type ? k = this.renderError(t) : \"rangeBar\" === t.type ? k = this.renderRangeBar(t) : \"rangeArea\" === t.type ? k = this.renderRangeArea(t) : \"rangeSplineArea\" === t.type ? k = this.renderRangeSplineArea(t) : \"waterfall\" === t.type ? k = this.renderWaterfall(t) : \"boxAndWhisker\" ===\r\n                        t.type && (k = this.renderBoxAndWhisker(t));\r\n                    for (b = 0; b < t.dataSeriesIndexes.length; b++)\r\n                        this._dataInRenderedOrder.push(this.data[t.dataSeriesIndexes[b]]);\r\n                    this.animatedRender && (t.targetCanvasCtx.miterLimit = g, k && c.push(k));\r\n                }\r\n            this.ctx.miterLimit = f;\r\n            this.animatedRender && this._breaksCanvasCtx && c.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });\r\n            this.animatedRender && 0 < this._indexLabels.length && (g =\r\n                ua(this.width, this.height).getContext(\"2d\"), c.push(this.renderIndexLabels(g)));\r\n            var r = this;\r\n            if (0 < c.length)\r\n                r.disableToolTip = !0, r._animator.animate(200, r.animationDuration, function (a) {\r\n                    r.ctx.clearRect(0, 0, r.width, r.height);\r\n                    r.ctx.drawImage(e, 0, 0, Math.floor(r.width * ga), Math.floor(r.height * ga), 0, 0, r.width, r.height);\r\n                    for (var b = 0; b < c.length; b++)\r\n                        k = c[b], 1 > a && \"undefined\" !== typeof k.startTimePercent ? a >= k.startTimePercent && k.animationCallback(k.easingFunction(a - k.startTimePercent, 0, 1, 1 - k.startTimePercent), k) : k.animationCallback(k.easingFunction(a, 0, 1, 1), k);\r\n                    r.dispatchEvent(\"dataAnimationIterationEnd\", { chart: r });\r\n                }, function () { c = []; for (var a = 0; a < r.plotInfo.plotTypes.length; a++)\r\n                    for (var b = r.plotInfo.plotTypes[a], d = 0; d < b.plotUnits.length; d++)\r\n                        b.plotUnits[d].targetCanvas = null; e = null; r.disableToolTip = !1; });\r\n            else {\r\n                if (r._breaksCanvas)\r\n                    if (v)\r\n                        r.plotArea.ctx.drawImage(r._breaksCanvas, 0, 0, this.width, this.height);\r\n                    else\r\n                        for (b = 0; b < r._axes.length; b++)\r\n                            r._axes[b].createMask();\r\n                0 < r._indexLabels.length && r.renderIndexLabels();\r\n                r.dispatchEvent(\"dataAnimationIterationEnd\", { chart: r });\r\n            }\r\n            this.attachPlotAreaEventHandlers();\r\n            this.zoomEnabled || (this.panEnabled || !this._zoomButton || \"none\" === this._zoomButton.style.display) || wa(this._zoomButton, this._resetButton);\r\n            this.toolTip._updateToolTip();\r\n            this.renderCount++;\r\n            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);\r\n            for (b = 0; b < this._axes.length; b++)\r\n                this._axes[b].maskCanvas && (delete this._axes[b].maskCanvas, delete this._axes[b].maskCtx);\r\n        };\r\n        s.prototype.attachPlotAreaEventHandlers = function () {\r\n            this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown,\r\n                mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? \"move\" : \"default\", capture: !0, bounds: this.plotArea });\r\n        };\r\n        s.prototype.categoriseDataSeries = function () {\r\n            for (var a = \"\", f = 0; f < this.data.length; f++)\r\n                if (a = this.data[f], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= s._supportedChartTypes.indexOf(a.type)) {\r\n                    for (var b = null, c = !1, e = null, g = !1, h = 0; h < this.plotInfo.plotTypes.length; h++)\r\n                        if (this.plotInfo.plotTypes[h].type === a.type) {\r\n                            c = !0;\r\n                            b = this.plotInfo.plotTypes[h];\r\n                            break;\r\n                        }\r\n                    c || (b = { type: a.type,\r\n                        totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(b));\r\n                    for (h = 0; h < b.plotUnits.length; h++)\r\n                        if (b.plotUnits[h].axisYType === a.axisYType && b.plotUnits[h].axisXType === a.axisXType && b.plotUnits[h].axisYIndex === a.axisYIndex && b.plotUnits[h].axisXIndex === a.axisXIndex) {\r\n                            g = !0;\r\n                            e = b.plotUnits[h];\r\n                            break;\r\n                        }\r\n                    g || (e = { type: a.type, previousDataSeriesCount: 0, index: b.plotUnits.length, plotType: b, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: \"primary\" === a.axisYType ? this.axisY[0 <=\r\n                            a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: \"primary\" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [] }, b.plotUnits.push(e));\r\n                    b.totalDataSeries++;\r\n                    e.dataSeriesIndexes.push(f);\r\n                    a.plotUnit = e;\r\n                }\r\n            for (f = 0; f < this.plotInfo.plotTypes.length; f++)\r\n                for (b = this.plotInfo.plotTypes[f],\r\n                    h = a = 0; h < b.plotUnits.length; h++)\r\n                    b.plotUnits[h].previousDataSeriesCount = a, a += b.plotUnits[h].dataSeriesIndexes.length;\r\n        };\r\n        s.prototype.assignIdToDataPoints = function () { for (var a = 0; a < this.data.length; a++) {\r\n            var f = this.data[a];\r\n            if (f.dataPoints)\r\n                for (var b = f.dataPoints.length, c = 0; c < b; c++)\r\n                    f.dataPointIds[c] = ++this._eventManager.lastObjectId;\r\n        } };\r\n        s.prototype._processData = function () {\r\n            this.assignIdToDataPoints();\r\n            this.categoriseDataSeries();\r\n            for (var a = 0; a < this.plotInfo.plotTypes.length; a++)\r\n                for (var f = this.plotInfo.plotTypes[a], b = 0; b < f.plotUnits.length; b++) {\r\n                    var c = f.plotUnits[b];\r\n                    \"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" === c.type || \"scatter\" === c.type ? this._processMultiseriesPlotUnit(c) : \"stackedColumn\" === c.type || \"stackedBar\" === c.type || \"stackedArea\" === c.type ? this._processStackedPlotUnit(c) : \"stackedColumn100\" === c.type || \"stackedBar100\" === c.type || \"stackedArea100\" === c.type ? this._processStacked100PlotUnit(c) : \"candlestick\" ===\r\n                        c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? this._processMultiYPlotUnit(c) : \"waterfall\" === c.type && this._processSpecificPlotUnit(c);\r\n                }\r\n            this.calculateAutoBreaks();\r\n        };\r\n        s.prototype._processMultiseriesPlotUnit = function (a) {\r\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\r\n                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {\r\n                    var l = this.data[a.dataSeriesIndexes[h]], t = 0, k = !1, r = !1, p;\r\n                    if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement)\r\n                        var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ?\r\n                            this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\r\n                    if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || \"dateTime\" === l.xValueType)\r\n                        g = !0;\r\n                    for (t = 0; t < l.dataPoints.length; t++) {\r\n                        \"undefined\" === typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0));\r\n                        l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x;\r\n                        e = l.dataPoints[t].y;\r\n                        c < b.min && (b.min = c);\r\n                        c > b.max && (b.max = c);\r\n                        e < f.min && \"number\" === typeof e && (f.min = e);\r\n                        e > f.max && \"number\" === typeof e && (f.max = e);\r\n                        if (0 < t) {\r\n                            if (a.axisX.logarithmic) {\r\n                                var w = c / l.dataPoints[t - 1].x;\r\n                                1 > w && (w = 1 / w);\r\n                                b.minDiff > w && 1 !== w && (b.minDiff = w);\r\n                            }\r\n                            else\r\n                                w = c - l.dataPoints[t - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w);\r\n                            null !== e && null !== l.dataPoints[t - 1].y && (a.axisY.logarithmic ? (w = e / l.dataPoints[t - 1].y, 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e - l.dataPoints[t - 1].y, 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w)));\r\n                        }\r\n                        if (c < n && !k)\r\n                            null !== e && (p = c);\r\n                        else {\r\n                            if (!k && (k = !0, 0 < t)) {\r\n                                t -= 2;\r\n                                continue;\r\n                            }\r\n                            if (c > d &&\r\n                                !r)\r\n                                r = !0;\r\n                            else if (c > d && r)\r\n                                continue;\r\n                            l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);\r\n                            c < b.viewPortMin && (b.viewPortMin = c);\r\n                            c > b.viewPortMax && (b.viewPortMax = c);\r\n                            null === e ? b.viewPortMin === c && p < c && (b.viewPortMin = p) : (e < f.viewPortMin && \"number\" === typeof e && (f.viewPortMin = e), e > f.viewPortMax && \"number\" === typeof e && (f.viewPortMax = e));\r\n                        }\r\n                    }\r\n                    l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\r\n                }\r\n        };\r\n        s.prototype._processStackedPlotUnit = function (a) {\r\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\r\n                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = [], l = [], t = Infinity, k = -Infinity, r = 0; r < a.dataSeriesIndexes.length; r++) {\r\n                    var p = this.data[a.dataSeriesIndexes[r]], n = 0, d = !1, w = !1, za;\r\n                    if (\"normal\" === p.axisPlacement || \"xySwapped\" === p.axisPlacement)\r\n                        var D = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, u = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\r\n                    if (p.dataPoints[n].x && p.dataPoints[n].x.getTime || \"dateTime\" === p.xValueType)\r\n                        g = !0;\r\n                    for (n = 0; n < p.dataPoints.length; n++) {\r\n                        \"undefined\" === typeof p.dataPoints[n].x && (p.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));\r\n                        p.dataPoints[n].x.getTime ? (g = !0, c = p.dataPoints[n].x.getTime()) :\r\n                            c = p.dataPoints[n].x;\r\n                        e = y(p.dataPoints[n].y) ? 0 : p.dataPoints[n].y;\r\n                        c < b.min && (b.min = c);\r\n                        c > b.max && (b.max = c);\r\n                        if (0 < n) {\r\n                            if (a.axisX.logarithmic) {\r\n                                var m = c / p.dataPoints[n - 1].x;\r\n                                1 > m && (m = 1 / m);\r\n                                b.minDiff > m && 1 !== m && (b.minDiff = m);\r\n                            }\r\n                            else\r\n                                m = c - p.dataPoints[n - 1].x, 0 > m && (m *= -1), b.minDiff > m && 0 !== m && (b.minDiff = m);\r\n                            null !== e && null !== p.dataPoints[n - 1].y && (a.axisY.logarithmic ? 0 < e && (m = e / p.dataPoints[n - 1].y, 1 > m && (m = 1 / m), f.minDiff > m && 1 !== m && (f.minDiff = m)) : (m = e - p.dataPoints[n - 1].y, 0 > m && (m *= -1), f.minDiff > m && 0 !== m && (f.minDiff = m)));\r\n                        }\r\n                        if (c < D &&\r\n                            !d)\r\n                            null !== p.dataPoints[n].y && (za = c);\r\n                        else {\r\n                            if (!d && (d = !0, 0 < n)) {\r\n                                n -= 2;\r\n                                continue;\r\n                            }\r\n                            if (c > u && !w)\r\n                                w = !0;\r\n                            else if (c > u && w)\r\n                                continue;\r\n                            p.dataPoints[n].label && (a.axisX.labels[c] = p.dataPoints[n].label);\r\n                            c < b.viewPortMin && (b.viewPortMin = c);\r\n                            c > b.viewPortMax && (b.viewPortMax = c);\r\n                            null === p.dataPoints[n].y ? b.viewPortMin === c && za < c && (b.viewPortMin = za) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h[c] ? h[c] += e : (h[c] = e, t = Math.min(e, t)) : l[c] ? l[c] += e : (l[c] = e, k = Math.max(e, k)));\r\n                        }\r\n                    }\r\n                    a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate &&\r\n                        1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (f.dataPointYPositiveSums ? (f.dataPointYPositiveSums.push.apply(f.dataPointYPositiveSums, h), f.dataPointYNegativeSums.push.apply(f.dataPointYPositiveSums, l)) : (f.dataPointYPositiveSums = h, f.dataPointYNegativeSums = l));\r\n                    p.axisX.valueType = p.xValueType = g ? \"dateTime\" : \"number\";\r\n                }\r\n                for (n in h)\r\n                    h.hasOwnProperty(n) && !isNaN(n) && (a = h[n], a < f.min && (f.min = Math.min(a, t)), a > f.max && (f.max = a), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin && (f.viewPortMin = Math.min(a, t)), a > f.viewPortMax &&\r\n                        (f.viewPortMax = a)));\r\n                for (n in l)\r\n                    l.hasOwnProperty(n) && !isNaN(n) && (a = l[n], a < f.min && (f.min = a), a > f.max && (f.max = Math.max(a, k)), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin && (f.viewPortMin = a), a > f.viewPortMax && (f.viewPortMax = Math.max(a, k))));\r\n            }\r\n        };\r\n        s.prototype._processStacked100PlotUnit = function (a) {\r\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\r\n                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = !1, l = !1, t = [], k = 0; k < a.dataSeriesIndexes.length; k++) {\r\n                    var r = this.data[a.dataSeriesIndexes[k]], p = 0, n = !1, d = !1, w;\r\n                    if (\"normal\" === r.axisPlacement || \"xySwapped\" === r.axisPlacement)\r\n                        var m = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, D = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum :\r\n                            this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\r\n                    if (r.dataPoints[p].x && r.dataPoints[p].x.getTime || \"dateTime\" === r.xValueType)\r\n                        g = !0;\r\n                    for (p = 0; p < r.dataPoints.length; p++) {\r\n                        \"undefined\" === typeof r.dataPoints[p].x && (r.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0));\r\n                        r.dataPoints[p].x.getTime ? (g = !0, c = r.dataPoints[p].x.getTime()) : c = r.dataPoints[p].x;\r\n                        e = y(r.dataPoints[p].y) ? null : r.dataPoints[p].y;\r\n                        c < b.min && (b.min = c);\r\n                        c > b.max && (b.max = c);\r\n                        if (0 < p) {\r\n                            if (a.axisX.logarithmic) {\r\n                                var u = c / r.dataPoints[p -\r\n                                    1].x;\r\n                                1 > u && (u = 1 / u);\r\n                                b.minDiff > u && 1 !== u && (b.minDiff = u);\r\n                            }\r\n                            else\r\n                                u = c - r.dataPoints[p - 1].x, 0 > u && (u *= -1), b.minDiff > u && 0 !== u && (b.minDiff = u);\r\n                            y(e) || null === r.dataPoints[p - 1].y || (a.axisY.logarithmic ? 0 < e && (u = e / r.dataPoints[p - 1].y, 1 > u && (u = 1 / u), f.minDiff > u && 1 !== u && (f.minDiff = u)) : (u = e - r.dataPoints[p - 1].y, 0 > u && (u *= -1), f.minDiff > u && 0 !== u && (f.minDiff = u)));\r\n                        }\r\n                        if (c < m && !n)\r\n                            null !== e && (w = c);\r\n                        else {\r\n                            if (!n && (n = !0, 0 < p)) {\r\n                                p -= 2;\r\n                                continue;\r\n                            }\r\n                            if (c > D && !d)\r\n                                d = !0;\r\n                            else if (c > D && d)\r\n                                continue;\r\n                            r.dataPoints[p].label && (a.axisX.labels[c] = r.dataPoints[p].label);\r\n                            c < b.viewPortMin && (b.viewPortMin = c);\r\n                            c > b.viewPortMax && (b.viewPortMax = c);\r\n                            null === e ? b.viewPortMin === c && w < c && (b.viewPortMin = w) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h = !0 : 0 > e && (l = !0), t[c] = t[c] ? t[c] + Math.abs(e) : Math.abs(e));\r\n                        }\r\n                    }\r\n                    r.axisX.valueType = r.xValueType = g ? \"dateTime\" : \"number\";\r\n                }\r\n                a.axisY.logarithmic ? (f.max = y(f.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(f.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && !l ? (f.max = y(f.viewPortMax) ?\r\n                    99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && l ? (f.max = y(f.viewPortMax) ? 99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99)) : !h && l && (f.max = y(f.viewPortMax) ? -1 : Math.max(f.viewPortMax, -1), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99));\r\n                f.viewPortMin = f.min;\r\n                f.viewPortMax = f.max;\r\n                a.dataPointYSums = t;\r\n            }\r\n        };\r\n        s.prototype._processMultiYPlotUnit = function (a) {\r\n            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\r\n                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, h, l = !1, t = 0; t < a.dataSeriesIndexes.length; t++) {\r\n                    var k = this.data[a.dataSeriesIndexes[t]], r = 0, p = !1, n = !1, d, w, m;\r\n                    if (\"normal\" === k.axisPlacement || \"xySwapped\" === k.axisPlacement)\r\n                        var D = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, u = a.axisX.sessionVariables.newViewportMaximum ?\r\n                            a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\r\n                    if (k.dataPoints[r].x && k.dataPoints[r].x.getTime || \"dateTime\" === k.xValueType)\r\n                        l = !0;\r\n                    for (r = 0; r < k.dataPoints.length; r++) {\r\n                        \"undefined\" === typeof k.dataPoints[r].x && (k.dataPoints[r].x = r + (a.axisX.logarithmic ? 1 : 0));\r\n                        k.dataPoints[r].x.getTime ? (l = !0, c = k.dataPoints[r].x.getTime()) : c = k.dataPoints[r].x;\r\n                        if ((e = k.dataPoints[r].y) && e.length) {\r\n                            g = Math.min.apply(null, e);\r\n                            h = Math.max.apply(null, e);\r\n                            w = !0;\r\n                            for (var v = 0; v < e.length; v++)\r\n                                null === e.k && (w = !1);\r\n                            w && (p || (m = d), d = c);\r\n                        }\r\n                        c < b.min && (b.min = c);\r\n                        c > b.max && (b.max = c);\r\n                        g < f.min && (f.min = g);\r\n                        h > f.max && (f.max = h);\r\n                        0 < r && (a.axisX.logarithmic ? (w = c / k.dataPoints[r - 1].x, 1 > w && (w = 1 / w), b.minDiff > w && 1 !== w && (b.minDiff = w)) : (w = c - k.dataPoints[r - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w)), e && (null !== e[0] && k.dataPoints[r - 1].y && null !== k.dataPoints[r - 1].y[0]) && (a.axisY.logarithmic ? (w = e[0] /\r\n                            k.dataPoints[r - 1].y[0], 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e[0] - k.dataPoints[r - 1].y[0], 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w))));\r\n                        if (!(c < D) || p) {\r\n                            if (!p && (p = !0, 0 < r)) {\r\n                                r -= 2;\r\n                                d = m;\r\n                                continue;\r\n                            }\r\n                            if (c > u && !n)\r\n                                n = !0;\r\n                            else if (c > u && n)\r\n                                continue;\r\n                            k.dataPoints[r].label && (a.axisX.labels[c] = k.dataPoints[r].label);\r\n                            c < b.viewPortMin && (b.viewPortMin = c);\r\n                            c > b.viewPortMax && (b.viewPortMax = c);\r\n                            if (b.viewPortMin === c && e)\r\n                                for (v = 0; v < e.length; v++)\r\n                                    if (null === e[v] && d < c) {\r\n                                        b.viewPortMin = d;\r\n                                        break;\r\n                                    }\r\n                            null === e ? b.viewPortMin === c && d < c &&\r\n                                (b.viewPortMin = d) : (g < f.viewPortMin && (f.viewPortMin = g), h > f.viewPortMax && (f.viewPortMax = h));\r\n                        }\r\n                    }\r\n                    k.axisX.valueType = k.xValueType = l ? \"dateTime\" : \"number\";\r\n                }\r\n        };\r\n        s.prototype._processSpecificPlotUnit = function (a) {\r\n            if (\"waterfall\" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))\r\n                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {\r\n                    var l = this.data[a.dataSeriesIndexes[h]], t = 0, k = !1, r = !1, p = c = 0;\r\n                    if (\"normal\" === l.axisPlacement || \"xySwapped\" === l.axisPlacement)\r\n                        var n = a.axisX.sessionVariables.newViewportMinimum ?\r\n                            a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;\r\n                    if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || \"dateTime\" === l.xValueType)\r\n                        g = !0;\r\n                    for (t = 0; t < l.dataPoints.length; t++)\r\n                        \"undefined\" !== typeof l.dataPoints[t].isCumulativeSum && !0 === l.dataPoints[t].isCumulativeSum ? (l.dataPointEOs[t].cumulativeSumYStartValue = 0, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum) : \"undefined\" !== typeof l.dataPoints[t].isIntermediateSum && !0 === l.dataPoints[t].isIntermediateSum ? (l.dataPointEOs[t].cumulativeSumYStartValue =\r\n                            p, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : c, p = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, c = 0) : (e = \"number\" !== typeof l.dataPoints[t].y ? 0 : l.dataPoints[t].y, l.dataPointEOs[t].cumulativeSumYStartValue = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPointEOs[t].cumulativeSum = 0 === t ? e : l.dataPointEOs[t - 1].cumulativeSum + e, c += e);\r\n                    for (t = 0; t < l.dataPoints.length; t++)\r\n                        if (\"undefined\" === typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0)),\r\n                            l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x, e = l.dataPoints[t].y, c < b.min && (b.min = c), c > b.max && (b.max = c), l.dataPointEOs[t].cumulativeSum < f.min && (f.min = l.dataPointEOs[t].cumulativeSum), l.dataPointEOs[t].cumulativeSum > f.max && (f.max = l.dataPointEOs[t].cumulativeSum), 0 < t && (a.axisX.logarithmic ? (p = c / l.dataPoints[t - 1].x, 1 > p && (p = 1 / p), b.minDiff > p && 1 !== p && (b.minDiff = p)) : (p = c - l.dataPoints[t - 1].x, 0 > p && (p *= -1), b.minDiff > p && 0 !== p && (b.minDiff = p)), null !== e && null !== l.dataPoints[t -\r\n                            1].y && (a.axisY.logarithmic ? (e = l.dataPointEOs[t].cumulativeSum / l.dataPointEOs[t - 1].cumulativeSum, 1 > e && (e = 1 / e), f.minDiff > e && 1 !== e && (f.minDiff = e)) : (e = l.dataPointEOs[t].cumulativeSum - l.dataPointEOs[t - 1].cumulativeSum, 0 > e && (e *= -1), f.minDiff > e && 0 !== e && (f.minDiff = e)))), !(c < n) || k) {\r\n                            if (!k && (k = !0, 0 < t)) {\r\n                                t -= 2;\r\n                                continue;\r\n                            }\r\n                            if (c > d && !r)\r\n                                r = !0;\r\n                            else if (c > d && r)\r\n                                continue;\r\n                            l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);\r\n                            c < b.viewPortMin && (b.viewPortMin = c);\r\n                            c > b.viewPortMax && (b.viewPortMax = c);\r\n                            0 < t && (l.dataPointEOs[t -\r\n                                1].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t - 1].cumulativeSum), l.dataPointEOs[t - 1].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t - 1].cumulativeSum));\r\n                            l.dataPointEOs[t].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t].cumulativeSum);\r\n                            l.dataPointEOs[t].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t].cumulativeSum);\r\n                        }\r\n                    l.axisX.valueType = l.xValueType = g ? \"dateTime\" : \"number\";\r\n                }\r\n        };\r\n        s.prototype.calculateAutoBreaks = function () {\r\n            function a(a, c, b, e) {\r\n                if (e)\r\n                    return b =\r\n                        Math.pow(Math.min(b * a / c, c / a), 0.2), 1 >= b && (b = Math.pow(1 > a ? 1 / a : Math.min(c / a, a), 0.25)), { startValue: a * b, endValue: c / b };\r\n                b = 0.2 * Math.min(b - c + a, c - a);\r\n                0 >= b && (b = 0.25 * Math.min(c - a, Math.abs(a)));\r\n                return { startValue: a + b, endValue: c - b };\r\n            }\r\n            function f(a) {\r\n                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {\r\n                    var c = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks, b = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;\r\n                    if (c ||\r\n                        b)\r\n                        for (var f = a.axisY.dataInfo, g = a.axisX.dataInfo, k, h = g.min, n = g.max, l = f.min, t = f.max, g = g._dataRanges, f = f._dataRanges, p, r = 0, m = 0; m < a.dataSeriesIndexes.length; m++) {\r\n                            var v = e.data[a.dataSeriesIndexes[m]];\r\n                            if (!(4 > v.dataPoints.length))\r\n                                for (r = 0; r < v.dataPoints.length; r++)\r\n                                    if (c && (p = (n + 1 - h) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, k = v.dataPoints[r].x.getTime ? v.dataPoints[r].x.getTime() : v.dataPoints[r].x, p = Math.floor((k - h) / p), k < g[p].min && (g[p].min = k), k > g[p].max && (g[p].max = k)), b) {\r\n                                        var q = (t + 1 - l) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\r\n                                        if ((k = \"waterfall\" === a.type ? v.dataPointEOs[r].cumulativeSum : v.dataPoints[r].y) && k.length)\r\n                                            for (var s = 0; s < k.length; s++)\r\n                                                p = Math.floor((k[s] - l) / q), k[s] < f[p].min && (f[p].min = k[s]), k[s] > f[p].max && (f[p].max = k[s]);\r\n                                        else\r\n                                            y(k) || (p = Math.floor((k - l) / q), k < f[p].min && (f[p].min = k), k > f[p].max && (f[p].max = k));\r\n                                    }\r\n                        }\r\n                }\r\n            }\r\n            function b(a) {\r\n                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <=\r\n                    a.axisX.scaleBreaks.maxNumberOfAutoBreaks)\r\n                    for (var c = a.axisX.dataInfo, b = c.min, f = c.max, g = c._dataRanges, k, h = 0, n = 0; n < a.dataSeriesIndexes.length; n++) {\r\n                        var l = e.data[a.dataSeriesIndexes[n]];\r\n                        if (!(4 > l.dataPoints.length))\r\n                            for (h = 0; h < l.dataPoints.length; h++)\r\n                                k = (f + 1 - b) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c = l.dataPoints[h].x.getTime ? l.dataPoints[h].x.getTime() : l.dataPoints[h].x, k = Math.floor((c - b) / k), c < g[k].min && (g[k].min = c), c > g[k].max && (g[k].max = c);\r\n                    }\r\n            }\r\n            for (var c, e = this, g = !1, h = 0; h <\r\n                this._axes.length; h++)\r\n                if (this._axes[h].scaleBreaks && this._axes[h].scaleBreaks.autoCalculate && 1 <= this._axes[h].scaleBreaks.maxNumberOfAutoBreaks) {\r\n                    g = !0;\r\n                    this._axes[h].dataInfo._dataRanges = [];\r\n                    for (var l = 0; l < 100 / Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10); l++)\r\n                        this._axes[h].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });\r\n                }\r\n            if (g) {\r\n                for (h = 0; h < this.plotInfo.plotTypes.length; h++)\r\n                    for (g = this.plotInfo.plotTypes[h], l = 0; l < g.plotUnits.length; l++)\r\n                        c = g.plotUnits[l], \"line\" === c.type ||\r\n                            \"stepLine\" === c.type || \"spline\" === c.type || \"column\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"bar\" === c.type || \"bubble\" === c.type || \"scatter\" === c.type || \"candlestick\" === c.type || \"ohlc\" === c.type || \"rangeColumn\" === c.type || \"rangeBar\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type || \"waterfall\" === c.type || \"error\" === c.type || \"boxAndWhisker\" === c.type ? f(c) : 0 <= c.type.indexOf(\"stacked\") && b(c);\r\n                for (h = 0; h < this._axes.length; h++)\r\n                    if (this._axes[h].dataInfo._dataRanges) {\r\n                        var t = this._axes[h].dataInfo.min;\r\n                        c = (this._axes[h].dataInfo.max + 1 - t) * Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;\r\n                        var k = this._axes[h].dataInfo._dataRanges, r, p, g = [];\r\n                        if (this._axes[h].dataInfo.dataPointYPositiveSums) {\r\n                            var n = this._axes[h].dataInfo.dataPointYPositiveSums;\r\n                            r = k;\r\n                            for (l in n)\r\n                                n.hasOwnProperty(l) && !isNaN(l) && (p = n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));\r\n                            delete this._axes[h].dataInfo.dataPointYPositiveSums;\r\n                        }\r\n                        if (this._axes[h].dataInfo.dataPointYNegativeSums) {\r\n                            n =\r\n                                this._axes[h].dataInfo.dataPointYNegativeSums;\r\n                            r = k;\r\n                            for (l in n)\r\n                                n.hasOwnProperty(l) && !isNaN(l) && (p = -1 * n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));\r\n                            delete this._axes[h].dataInfo.dataPointYNegativeSums;\r\n                        }\r\n                        for (l = 0; l < k.length - 1; l++)\r\n                            if (r = k[l].max, isFinite(r))\r\n                                for (; l < k.length - 1;)\r\n                                    if (t = k[l + 1].min, isFinite(t)) {\r\n                                        p = t - r;\r\n                                        p > c && g.push({ diff: p, start: r, end: t });\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        l++;\r\n                        if (this._axes[h].scaleBreaks.customBreaks)\r\n                            for (l = 0; l < this._axes[h].scaleBreaks.customBreaks.length; l++)\r\n                                for (c =\r\n                                    0; c < g.length; c++)\r\n                                    if (this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].startValue && this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].end || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue && this._axes[h].scaleBreaks.customBreaks[l].endValue <=\r\n                                        g[c].end)\r\n                                        g.splice(c, 1), c--;\r\n                        g.sort(function (a, c) { return c.diff - a.diff; });\r\n                        for (l = 0; l < Math.min(g.length, this._axes[h].scaleBreaks.maxNumberOfAutoBreaks); l++)\r\n                            c = a(g[l].start, g[l].end, this._axes[h].logarithmic ? this._axes[h].dataInfo.max / this._axes[h].dataInfo.min : this._axes[h].dataInfo.max - this._axes[h].dataInfo.min, this._axes[h].logarithmic), this._axes[h].scaleBreaks.autoBreaks.push(new ba(this, \"autoBreaks\", c, l, ++this._eventManager.lastObjectId, this._axes[h].scaleBreaks)), this._axes[h].scaleBreaks._appliedBreaks.push(this._axes[h].scaleBreaks.autoBreaks[this._axes[h].scaleBreaks.autoBreaks.length -\r\n                                1]);\r\n                        this._axes[h].scaleBreaks._appliedBreaks.sort(function (a, c) { return a.startValue - c.startValue; });\r\n                    }\r\n            }\r\n        };\r\n        s.prototype.getDataPointAtXY = function (a, f, b) {\r\n            b = b || !1;\r\n            for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {\r\n                var g = null;\r\n                (g = this._dataInRenderedOrder[e].getDataPointAtXY(a, f, b)) && c.push(g);\r\n            }\r\n            a = null;\r\n            f = !1;\r\n            for (b = 0; b < c.length; b++)\r\n                if (\"line\" === c[b].dataSeries.type || \"stepLine\" === c[b].dataSeries.type || \"area\" === c[b].dataSeries.type || \"stepArea\" === c[b].dataSeries.type)\r\n                    if (e = ma(\"markerSize\", c[b].dataPoint, c[b].dataSeries) ||\r\n                        8, c[b].distance <= e / 2) {\r\n                        f = !0;\r\n                        break;\r\n                    }\r\n            for (b = 0; b < c.length; b++)\r\n                f && \"line\" !== c[b].dataSeries.type && \"stepLine\" !== c[b].dataSeries.type && \"area\" !== c[b].dataSeries.type && \"stepArea\" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]);\r\n            return a;\r\n        };\r\n        s.prototype.getObjectAtXY = function (a, f, b) {\r\n            var c = null;\r\n            if (b = this.getDataPointAtXY(a, f, b || !1))\r\n                c = b.dataSeries.dataPointIds[b.dataPointIndex];\r\n            else if (v)\r\n                c = Xa(a, f, this._eventManager.ghostCtx);\r\n            else\r\n                for (b = 0; b < this.legend.items.length; b++) {\r\n                    var e = this.legend.items[b];\r\n                    a >= e.x1 && (a <= e.x2 && f >= e.y1 && f <= e.y2) && (c = e.id);\r\n                }\r\n            return c;\r\n        };\r\n        s.prototype.getAutoFontSize = function (a, f, b) { f = Math.min(this.width, this.height); return Math.max(\"theme4\" === this.theme ? 0 : 300 <= f ? 12 : 10, Math.round(f * (a / 400))); };\r\n        s.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height); };\r\n        s.prototype.clearCanvas = function () { this.ctx.clearRect(0, 0, this.width, this.height); this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)); };\r\n        s.prototype.attachEvent = function (a) { this._events.push(a); };\r\n        s.prototype._touchEventHandler = function (a) {\r\n            if (a.changedTouches && this.interactivityEnabled) {\r\n                var f = [], b = a.changedTouches, c = b ? b[0] : a, e = null;\r\n                switch (a.type) {\r\n                    case \"touchstart\":\r\n                    case \"MSPointerDown\":\r\n                        f = [\"mousemove\", \"mousedown\"];\r\n                        this._lastTouchData = Pa(c);\r\n                        this._lastTouchData.time = new Date;\r\n                        break;\r\n                    case \"touchmove\":\r\n                    case \"MSPointerMove\":\r\n                        f = [\"mousemove\"];\r\n                        break;\r\n                    case \"touchend\":\r\n                    case \"MSPointerUp\":\r\n                        var g = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time :\r\n                            0, f = \"touchstart\" === this._lastTouchEventType || \"MSPointerDown\" === this._lastTouchEventType || 300 > g ? [\"mouseup\", \"click\"] : [\"mouseup\"];\r\n                        break;\r\n                    default: return;\r\n                }\r\n                if (!(b && 1 < b.length)) {\r\n                    e = Pa(c);\r\n                    e.time = new Date;\r\n                    try {\r\n                        var h = e.y - this._lastTouchData.y, g = e.time - this._lastTouchData.time;\r\n                        if (15 < Math.abs(h) && (this._lastTouchData.scroll || 300 > g)) {\r\n                            this._lastTouchData.scroll = !0;\r\n                            var l = window.parent || window;\r\n                            l && l.scrollBy && l.scrollBy(0, -h);\r\n                        }\r\n                    }\r\n                    catch (t) { }\r\n                    this._lastTouchEventType = a.type;\r\n                    if (this._lastTouchData.scroll && this.zoomEnabled)\r\n                        this.isDrag &&\r\n                            this.resetOverlayedCanvas(), this.isDrag = !1;\r\n                    else\r\n                        for (b = 0; b < f.length; b++)\r\n                            e = f[b], g = document.createEvent(\"MouseEvent\"), g.initMouseEvent(e, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), c.target.dispatchEvent(g), a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault();\r\n                }\r\n            }\r\n        };\r\n        s.prototype._dispatchRangeEvent = function (a, f) {\r\n            var b = { chart: this };\r\n            b.type = a;\r\n            b.trigger = f;\r\n            var c = [];\r\n            this.axisX && 0 < this.axisX.length && c.push(\"axisX\");\r\n            this.axisX2 && 0 < this.axisX2.length &&\r\n                c.push(\"axisX2\");\r\n            this.axisY && 0 < this.axisY.length && c.push(\"axisY\");\r\n            this.axisY2 && 0 < this.axisY2.length && c.push(\"axisY2\");\r\n            for (var e = 0; e < c.length; e++)\r\n                if (y(b[c[e]]) && (b[c[e]] = []), \"axisY\" === c[e])\r\n                    for (var g = 0; g < this.axisY.length; g++)\r\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\r\n                else if (\"axisY2\" === c[e])\r\n                    for (g = 0; g < this.axisY2.length; g++)\r\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,\r\n                            viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\r\n                else if (\"axisX\" === c[e])\r\n                    for (g = 0; g < this.axisX.length; g++)\r\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\r\n                else if (\"axisX2\" === c[e])\r\n                    for (g = 0; g < this.axisX2.length; g++)\r\n                        b[c[e]].push({ viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum, viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum });\r\n            this.dispatchEvent(a, b, this);\r\n        };\r\n        s.prototype._mouseEventHandler = function (a) {\r\n            \"undefined\" === typeof a.target && a.srcElement && (a.target = a.srcElement);\r\n            var f = Pa(a), b = a.type, c, e;\r\n            a.which ? e = 3 == a.which : a.button && (e = 2 == a.button);\r\n            s.capturedEventParam && (c = s.capturedEventParam, \"mouseup\" === b && (s.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", c.chart._mouseEventHandler, !1)), c.hasOwnProperty(b) && (\"mouseup\" !== b || c.chart.overlaidCanvas.releaseCapture ?\r\n                a.target !== c.chart.overlaidCanvas && v || c[b].call(c.context, f.x, f.y) : a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = !1)));\r\n            if (this.interactivityEnabled)\r\n                if (this._ignoreNextEvent)\r\n                    this._ignoreNextEvent = !1;\r\n                else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), !e) {\r\n                    if (!s.capturedEventParam && this._events) {\r\n                        for (var g = 0; g < this._events.length; g++)\r\n                            if (this._events[g].hasOwnProperty(b))\r\n                                if (c = this._events[g], e = c.bounds, f.x >= e.x1 && f.x <= e.x2 && f.y >= e.y1 && f.y <= e.y2) {\r\n                                    c[b].call(c.context, f.x, f.y);\r\n                                    \"mousedown\" === b && !0 === c.capture ? (s.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener(\"mouseup\", this._mouseEventHandler, !1)) : \"mouseup\" === b && (c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(\"mouseup\", this._mouseEventHandler, !1));\r\n                                    break;\r\n                                }\r\n                                else\r\n                                    c = null;\r\n                        a.target.style.cursor = c && c.cursor ? c.cursor : this._defaultCursor;\r\n                    }\r\n                    b = this.plotArea;\r\n                    if (f.x < b.x1 || f.x >\r\n                        b.x2 || f.y < b.y1 || f.y > b.y2)\r\n                        this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas();\r\n                    this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);\r\n                }\r\n        };\r\n        s.prototype._plotAreaMouseDown = function (a, f) { this.isDrag = !0; this.dragStartPoint = { x: a, y: f }; };\r\n        s.prototype._plotAreaMouseUp = function (a, f) {\r\n            if ((\"normal\" === this.plotInfo.axisPlacement || \"xySwapped\" === this.plotInfo.axisPlacement) && this.isDrag) {\r\n                var b = f - this.dragStartPoint.y, c = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf(\"x\"), g = 0 <= this.zoomType.indexOf(\"y\"), h = !1;\r\n                this.resetOverlayedCanvas();\r\n                if (\"xySwapped\" === this.plotInfo.axisPlacement)\r\n                    var l = g, g = e, e = l;\r\n                if (this.panEnabled || this.zoomEnabled) {\r\n                    if (this.panEnabled)\r\n                        for (e = g = 0; e < this._axes.length; e++)\r\n                            b = this._axes[e], b.logarithmic ? b.viewportMinimum < b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum =\r\n                                b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, h = !0) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum + g, b.sessionVariables.newViewportMaximum = b.viewportMaximum + g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, h = !0);\r\n                    else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {\r\n                        if (!this.dragStartPoint)\r\n                            return;\r\n                        b = e ? this.dragStartPoint.x : this.plotArea.x1;\r\n                        c = g ? this.dragStartPoint.y : this.plotArea.y1;\r\n                        e = e ? a : this.plotArea.x2;\r\n                        g = g ? f : this.plotArea.y2;\r\n                        2 < Math.abs(b - e) && 2 < Math.abs(c - g) && this._zoomPanToSelectedRegion(b, c, e, g) && (h = !0);\r\n                    }\r\n                    h && (this._ignoreNextEvent = !0, this._dispatchRangeEvent(\"rangeChanging\", \"zoom\"), this.render(), this._dispatchRangeEvent(\"rangeChanged\", \"zoom\"), h && (this.zoomEnabled && \"none\" === this._zoomButton.style.display) && (Na(this._zoomButton, this._resetButton), va(this, this._zoomButton, \"pan\"), va(this, this._resetButton, \"reset\")));\r\n                }\r\n            }\r\n            this.isDrag = !1;\r\n            if (\"none\" !== this.plotInfo.axisPlacement) {\r\n                this.resetOverlayedCanvas();\r\n                if (this.axisX && 0 < this.axisX.length)\r\n                    for (h = 0; h < this.axisX.length; h++)\r\n                        this.axisX[h].crosshair && this.axisX[h].crosshair.enabled && this.axisX[h].renderCrosshair(a, f);\r\n                if (this.axisX2 && 0 < this.axisX2.length)\r\n                    for (h = 0; h < this.axisX2.length; h++)\r\n                        this.axisX2[h].crosshair && this.axisX2[h].crosshair.enabled && this.axisX2[h].renderCrosshair(a, f);\r\n                if (this.axisY && 0 < this.axisY.length)\r\n                    for (h = 0; h < this.axisY.length; h++)\r\n                        this.axisY[h].crosshair &&\r\n                            this.axisY[h].crosshair.enabled && this.axisY[h].renderCrosshair(a, f);\r\n                if (this.axisY2 && 0 < this.axisY2.length)\r\n                    for (h = 0; h < this.axisY2.length; h++)\r\n                        this.axisY2[h].crosshair && this.axisY2[h].crosshair.enabled && this.axisY2[h].renderCrosshair(a, f);\r\n            }\r\n        };\r\n        s.prototype._plotAreaMouseMove = function (a, f) {\r\n            if (this.isDrag && \"none\" !== this.plotInfo.axisPlacement) {\r\n                var b = 0, c = 0, e = b = null, e = 0 <= this.zoomType.indexOf(\"x\"), g = 0 <= this.zoomType.indexOf(\"y\"), h = this;\r\n                \"xySwapped\" === this.plotInfo.axisPlacement && (b = g, g = e, e = b);\r\n                b = this.dragStartPoint.x -\r\n                    a;\r\n                c = this.dragStartPoint.y - f;\r\n                2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, f);\r\n                if ((!e || 2 < Math.abs(b) || !g || 2 < Math.abs(c)) && (this.panEnabled || this.zoomEnabled))\r\n                    if (this.panEnabled)\r\n                        e = { x1: e ? this.plotArea.x1 + b : this.plotArea.x1, y1: g ? this.plotArea.y1 + c : this.plotArea.y1, x2: e ? this.plotArea.x2 + b : this.plotArea.x2, y2: g ? this.plotArea.y2 + c : this.plotArea.y2 }, clearTimeout(h._panTimerId), h._panTimerId = setTimeout(function (c, b, e, d) { return function () { h._zoomPanToSelectedRegion(c, b, e, d, !0) && (h._dispatchRangeEvent(\"rangeChanging\", \"pan\"), h.render(), h._dispatchRangeEvent(\"rangeChanged\", \"pan\"), h.dragStartPoint.x = a, h.dragStartPoint.y = f); }; }(e.x1, e.y1, e.x2, e.y2), 0);\r\n                    else if (this.zoomEnabled) {\r\n                        this.resetOverlayedCanvas();\r\n                        b = this.overlaidCanvasCtx.globalAlpha;\r\n                        this.overlaidCanvasCtx.fillStyle = \"#A89896\";\r\n                        var c = e ? this.dragStartPoint.x : this.plotArea.x1, l = g ? this.dragStartPoint.y : this.plotArea.y1, t = e ? a - this.dragStartPoint.x : this.plotArea.x2 -\r\n                            this.plotArea.x1, k = g ? f - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;\r\n                        this.validateRegion(c, l, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? f : this.plotArea.y2 - this.plotArea.y1, \"xy\" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = \"#99B2B5\");\r\n                        this.overlaidCanvasCtx.globalAlpha = 0.7;\r\n                        this.overlaidCanvasCtx.fillRect(c, l, t, k);\r\n                        this.overlaidCanvasCtx.globalAlpha = b;\r\n                    }\r\n            }\r\n            else if (this.toolTip.mouseMoveHandler(a, f), \"none\" !== this.plotInfo.axisPlacement) {\r\n                if (this.axisX && 0 < this.axisX.length)\r\n                    for (e =\r\n                        0; e < this.axisX.length; e++)\r\n                        this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, f);\r\n                if (this.axisX2 && 0 < this.axisX2.length)\r\n                    for (e = 0; e < this.axisX2.length; e++)\r\n                        this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, f);\r\n                if (this.axisY && 0 < this.axisY.length)\r\n                    for (e = 0; e < this.axisY.length; e++)\r\n                        this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, f);\r\n                if (this.axisY2 && 0 < this.axisY2.length)\r\n                    for (e = 0; e < this.axisY2.length; e++)\r\n                        this.axisY2[e].crosshair &&\r\n                            this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, f);\r\n            }\r\n        };\r\n        s.prototype._zoomPanToSelectedRegion = function (a, f, b, c, e) { a = this.validateRegion(a, f, b, c, e); f = a.axesWithValidRange; b = a.axesRanges; if (a.isValid)\r\n            for (c = 0; c < f.length; c++)\r\n                e = b[c], f[c].setViewPortRange(e.val1, e.val2); return a.isValid; };\r\n        s.prototype.validateRegion = function (a, f, b, c, e) {\r\n            e = e || !1;\r\n            for (var g = 0 <= this.zoomType.indexOf(\"x\"), h = 0 <= this.zoomType.indexOf(\"y\"), l = !1, t = [], k = [], r = [], p = 0; p < this._axes.length; p++)\r\n                (\"axisX\" === this._axes[p].type &&\r\n                    g || \"axisY\" === this._axes[p].type && h) && k.push(this._axes[p]);\r\n            for (h = 0; h < k.length; h++) {\r\n                var p = k[h], g = !1, n = p.convertPixelToValue({ x: a, y: f }), d = p.convertPixelToValue({ x: b, y: c });\r\n                if (n > d)\r\n                    var w = d, d = n, n = w;\r\n                if (p.scaleBreaks)\r\n                    for (w = 0; !g && w < p.scaleBreaks._appliedBreaks.length; w++)\r\n                        g = p.scaleBreaks._appliedBreaks[w].startValue <= n && p.scaleBreaks._appliedBreaks[w].endValue >= d;\r\n                if (isFinite(p.dataInfo.minDiff))\r\n                    if (w = p.getApparentDifference(n, d, null, !0), !(g || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) &&\r\n                        (p.logarithmic && w < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && w < 3 * Math.abs(p.dataInfo.minDiff)) || n < p.minimum || d > p.maximum))\r\n                        t.push(p), r.push({ val1: n, val2: d }), l = !0;\r\n                    else if (!e) {\r\n                        l = !1;\r\n                        break;\r\n                    }\r\n            }\r\n            return { isValid: l, axesWithValidRange: t, axesRanges: r };\r\n        };\r\n        s.prototype.preparePlotArea = function () {\r\n            var a = this.plotArea;\r\n            !v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);\r\n            if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {\r\n                var f = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;\r\n                if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {\r\n                    var b = this.axisY[0];\r\n                    a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1;\r\n                    a.y1 = f.y1 < b.lineCoordinates.y1 ? f.y1 : b.lineCoordinates.y1;\r\n                    a.x2 = f.x2 > b.lineCoordinates.x2 ? f.x2 : b.lineCoordinates.x2;\r\n                    a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2;\r\n                    a.width = a.x2 - a.x1;\r\n                    a.height = a.y2 - a.y1;\r\n                }\r\n                this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1, a.y1 = f.y1 < b.lineCoordinates.y1 ? f.y1 : b.lineCoordinates.y1, a.x2 = f.x2 > b.lineCoordinates.x2 ?\r\n                    f.x2 : b.lineCoordinates.x2, a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);\r\n            }\r\n            else\r\n                f = this.layoutManager.getFreeSpace(), a.x1 = f.x1, a.x2 = f.x2, a.y1 = f.y1, a.y2 = f.y2, a.width = f.width, a.height = f.height;\r\n            v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + \"px\", a.canvas.style.top = a.y1 + \"px\", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));\r\n            a.layoutManager = new Ea(a.x1, a.y1, a.x2, a.y2, 2);\r\n        };\r\n        s.prototype.renderIndexLabels = function (a) {\r\n            var f = a || this.plotArea.ctx, b = this.plotArea, c = 0, e = 0, g = 0, h = 0, l = c = h = e = g = 0, t = 0;\r\n            for (a = 0; a < this._indexLabels.length; a++) {\r\n                var k = this._indexLabels[a], r = k.chartType.toLowerCase(), p, n, l = ma(\"indexLabelFontColor\", k.dataPoint, k.dataSeries), t = ma(\"indexLabelFontSize\", k.dataPoint, k.dataSeries);\r\n                p = ma(\"indexLabelFontFamily\", k.dataPoint, k.dataSeries);\r\n                n = ma(\"indexLabelFontStyle\", k.dataPoint, k.dataSeries);\r\n                var h = ma(\"indexLabelFontWeight\", k.dataPoint, k.dataSeries), d = ma(\"indexLabelBackgroundColor\", k.dataPoint, k.dataSeries), e = ma(\"indexLabelMaxWidth\", k.dataPoint, k.dataSeries), g = ma(\"indexLabelWrap\", k.dataPoint, k.dataSeries), w = ma(\"indexLabelLineDashType\", k.dataPoint, k.dataSeries), m = ma(\"indexLabelLineColor\", k.dataPoint, k.dataSeries), D = y(k.dataPoint.indexLabelLineThickness) ? y(k.dataSeries.options.indexLabelLineThickness) ? 0 : k.dataSeries.options.indexLabelLineThickness : k.dataPoint.indexLabelLineThickness, c = 0 < D ? Math.min(10, (\"normal\" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, u = { percent: null, total: null }, T = null;\r\n                if (0 <= k.dataSeries.type.indexOf(\"stacked\") ||\r\n                    \"pie\" === k.dataSeries.type || \"doughnut\" === k.dataSeries.type)\r\n                    u = this.getPercentAndTotal(k.dataSeries, k.dataPoint);\r\n                if (k.dataSeries.indexLabelFormatter || k.dataPoint.indexLabelFormatter)\r\n                    T = { chart: this, dataSeries: k.dataSeries, dataPoint: k.dataPoint, index: k.indexKeyword, total: u.total, percent: u.percent };\r\n                var H = k.dataPoint.indexLabelFormatter ? k.dataPoint.indexLabelFormatter(T) : k.dataPoint.indexLabel ? this.replaceKeywordsWithValue(k.dataPoint.indexLabel, k.dataPoint, k.dataSeries, null, k.indexKeyword) : k.dataSeries.indexLabelFormatter ?\r\n                    k.dataSeries.indexLabelFormatter(T) : k.dataSeries.indexLabel ? this.replaceKeywordsWithValue(k.dataSeries.indexLabel, k.dataPoint, k.dataSeries, null, k.indexKeyword) : null;\r\n                if (null !== H && \"\" !== H) {\r\n                    var u = ma(\"indexLabelPlacement\", k.dataPoint, k.dataSeries), T = ma(\"indexLabelOrientation\", k.dataPoint, k.dataSeries), q = k.direction, s = k.dataSeries.axisX, A = k.dataSeries.axisY, x = !1, d = new ka(f, { x: 0, y: 0, maxWidth: e ? e : 0.5 * this.width, maxHeight: g ? 5 * t : 1.5 * t, angle: \"horizontal\" === T ? 0 : -90, text: H, padding: 0, backgroundColor: d, horizontalAlign: \"left\",\r\n                        fontSize: t, fontFamily: p, fontWeight: h, fontColor: l, fontStyle: n, textBaseline: \"top\" });\r\n                    d.measureText();\r\n                    k.dataSeries.indexLabelMaxWidth = d.maxWidth;\r\n                    if (\"stackedarea100\" === r) {\r\n                        if (k.point.x < b.x1 || k.point.x > b.x2 || k.point.y < b.y1 - 1 || k.point.y > b.y2 + 1)\r\n                            continue;\r\n                    }\r\n                    else if (\"rangearea\" === r || \"rangesplinearea\" === r) {\r\n                        if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum)\r\n                            continue;\r\n                    }\r\n                    else if (0 <= r.indexOf(\"line\") ||\r\n                        0 <= r.indexOf(\"area\") || 0 <= r.indexOf(\"bubble\") || 0 <= r.indexOf(\"scatter\")) {\r\n                        if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum || k.dataPoint.y < A.viewportMinimum || k.dataPoint.y > A.viewportMaximum)\r\n                            continue;\r\n                    }\r\n                    else if (0 <= r.indexOf(\"column\") || \"waterfall\" === r || \"error\" === r && !k.axisSwapped) {\r\n                        if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum || k.bounds.y1 > b.y2 || k.bounds.y2 < b.y1)\r\n                            continue;\r\n                    }\r\n                    else if (0 <= r.indexOf(\"bar\") || \"error\" === r) {\r\n                        if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum ||\r\n                            k.bounds.x1 > b.x2 || k.bounds.x2 < b.x1)\r\n                            continue;\r\n                    }\r\n                    else if (\"candlestick\" === r || \"ohlc\" === r) {\r\n                        if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum)\r\n                            continue;\r\n                    }\r\n                    else if (k.dataPoint.x < s.viewportMinimum || k.dataPoint.x > s.viewportMaximum)\r\n                        continue;\r\n                    e = h = 2;\r\n                    \"horizontal\" === T ? (l = d.width, t = d.height) : (t = d.width, l = d.height);\r\n                    if (\"normal\" === this.plotInfo.axisPlacement) {\r\n                        if (0 <= r.indexOf(\"line\") || 0 <= r.indexOf(\"area\"))\r\n                            u =\r\n                                \"auto\", h = 4;\r\n                        else if (0 <= r.indexOf(\"stacked\"))\r\n                            \"auto\" === u && (u = \"inside\");\r\n                        else if (\"bubble\" === r || \"scatter\" === r)\r\n                            u = \"inside\";\r\n                        p = k.point.x - l / 2;\r\n                        \"inside\" !== u ? (e = b.y1, g = b.y2, 0 < q ? (n = k.point.y - t - h - c, n < e && (n = \"auto\" === u ? Math.max(k.point.y, e) + h + c : e + h + c, x = n + t > k.point.y)) : (n = k.point.y + h + c, n > g - t - h - c && (n = \"auto\" === u ? Math.min(k.point.y, g) - t - h - c : g - t - h - c, x = n < k.point.y))) : (e = Math.max(k.bounds.y1, b.y1), g = Math.min(k.bounds.y2, b.y2), c = 0 <= r.indexOf(\"range\") || \"error\" === r ? 0 < q ? Math.max(k.bounds.y1, b.y1) + t / 2 + h : Math.min(k.bounds.y2, b.y2) -\r\n                            t / 2 - h : (Math.max(k.bounds.y1, b.y1) + Math.min(k.bounds.y2, b.y2)) / 2, 0 < q ? (n = Math.max(k.point.y, c) - t / 2, n < e && (\"bubble\" === r || \"scatter\" === r) && (n = Math.max(k.point.y - t - h, b.y1 + h))) : (n = Math.min(k.point.y, c) - t / 2, n > g - t - h && (\"bubble\" === r || \"scatter\" === r) && (n = Math.min(k.point.y + h, b.y2 - t - h))), n = Math.min(n, g - t));\r\n                    }\r\n                    else\r\n                        0 <= r.indexOf(\"line\") || 0 <= r.indexOf(\"area\") || 0 <= r.indexOf(\"scatter\") ? (u = \"auto\", e = 4) : 0 <= r.indexOf(\"stacked\") ? \"auto\" === u && (u = \"inside\") : \"bubble\" === r && (u = \"inside\"), n = k.point.y - t / 2, \"inside\" !== u ? (h = b.x1, g = b.x2,\r\n                            0 > q ? (p = k.point.x - l - e - c, p < h && (p = \"auto\" === u ? Math.max(k.point.x, h) + e + c : h + e + c, x = p + l > k.point.x)) : (p = k.point.x + e + c, p > g - l - e - c && (p = \"auto\" === u ? Math.min(k.point.x, g) - l - e - c : g - l - e - c, x = p < k.point.x))) : (h = Math.max(k.bounds.x1, b.x1), Math.min(k.bounds.x2, b.x2), c = 0 <= r.indexOf(\"range\") || \"error\" === r ? 0 > q ? Math.max(k.bounds.x1, b.x1) + l / 2 + e : Math.min(k.bounds.x2, b.x2) - l / 2 - e : (Math.max(k.bounds.x1, b.x1) + Math.min(k.bounds.x2, b.x2)) / 2, p = 0 > q ? Math.max(k.point.x, c) - l / 2 : Math.min(k.point.x, c) - l / 2, p = Math.max(p, h));\r\n                    \"vertical\" === T && (n +=\r\n                        t);\r\n                    d.x = p;\r\n                    d.y = n;\r\n                    d.render(!0);\r\n                    D && (\"inside\" !== u && (0 > r.indexOf(\"bar\") && (\"error\" !== r || !k.axisSwapped) && k.point.x > b.x1 && k.point.x < b.x2 || !x) && (0 > r.indexOf(\"column\") && (\"error\" !== r || k.axisSwapped) && k.point.y > b.y1 && k.point.y < b.y2 || !x)) && (f.lineWidth = D, f.strokeStyle = m ? m : \"gray\", f.setLineDash && f.setLineDash(G(w, D)), f.beginPath(), f.moveTo(k.point.x, k.point.y), 0 <= r.indexOf(\"bar\") || \"error\" === r && k.axisSwapped ? f.lineTo(p + (0 < k.direction ? 0 : l), n + (\"horizontal\" === T ? t : -t) / 2) : 0 <= r.indexOf(\"column\") || \"error\" === r && !k.axisSwapped ?\r\n                        f.lineTo(p + l / 2, n + ((0 < k.direction ? t : -t) + (\"horizontal\" === T ? t : -t)) / 2) : f.lineTo(p + l / 2, n + ((n < k.point.y ? t : -t) + (\"horizontal\" === T ? t : -t)) / 2), f.stroke());\r\n                }\r\n            }\r\n            f = { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };\r\n            for (a = 0; a < this._indexLabels.length; a++)\r\n                k = this._indexLabels[a], d = ma(\"indexLabelBackgroundColor\", k.dataPoint, k.dataSeries), k.dataSeries.indexLabelBackgroundColor = y(d) ? v ? \"transparent\" : null : d;\r\n            return f;\r\n        };\r\n        s.prototype.renderLine =\r\n            function (a) {\r\n                var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n                if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                    var c = this._eventManager.ghostCtx;\r\n                    b.save();\r\n                    var e = this.plotArea;\r\n                    b.beginPath();\r\n                    b.rect(e.x1, e.y1, e.width, e.height);\r\n                    b.clip();\r\n                    for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                        var t = a.dataSeriesIndexes[l], k = this.data[t];\r\n                        b.lineWidth = k.lineThickness;\r\n                        var r = k.dataPoints, p = \"solid\";\r\n                        if (b.setLineDash) {\r\n                            var n = G(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, d = G(p, k.lineThickness);\r\n                            b.setLineDash(d);\r\n                        }\r\n                        var w = k.id;\r\n                        this._eventManager.objectMap[w] = { objectType: \"dataSeries\", dataSeriesIndex: t };\r\n                        w = S(w);\r\n                        c.strokeStyle = w;\r\n                        c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\r\n                        var w = k._colorSet, m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];\r\n                        b.strokeStyle = w;\r\n                        var D = !0, u = 0, T, H;\r\n                        b.beginPath();\r\n                        if (0 < r.length) {\r\n                            for (var q = !1, u = 0; u < r.length; u++)\r\n                                if (T = r[u].x.getTime ? r[u].x.getTime() : r[u].x, !(T < a.axisX.dataInfo.viewPortMin || T > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !q)))\r\n                                    if (\"number\" !== typeof r[u].y)\r\n                                        0 <\r\n                                            u && !(k.connectNullData || q || D) && (b.stroke(), v && c.stroke()), q = !0;\r\n                                    else {\r\n                                        T = a.axisX.convertValueToPixel(T);\r\n                                        H = a.axisY.convertValueToPixel(r[u].y);\r\n                                        var s = k.dataPointIds[u];\r\n                                        this._eventManager.objectMap[s] = { id: s, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: u, x1: T, y1: H };\r\n                                        D || q ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)), b.lineTo(T, H), v && c.lineTo(T, H)) : (b.beginPath(), b.moveTo(T, H), v && (c.beginPath(), c.moveTo(T, H))), q = D = !1) : (b.lineTo(T, H), v && c.lineTo(T, H), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(T, H), v && (c.stroke(), c.beginPath(), c.moveTo(T, H))));\r\n                                        h = { x: T, y: H };\r\n                                        u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(T, H), m = r[u].lineColor || w, b.strokeStyle = m, b.setLineDash && (r[u].lineDashType ? (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));\r\n                                        if (0 < r[u].markerSize || 0 < k.markerSize) {\r\n                                            var A = k.getMarkerProperties(u, T, H, b);\r\n                                            g.push(A);\r\n                                            s = S(s);\r\n                                            v && g.push({ x: T, y: H, ctx: c, type: A.type, size: A.size, color: s, borderColor: s, borderThickness: A.borderThickness });\r\n                                        }\r\n                                        (r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"line\", dataPoint: r[u], dataSeries: k, point: { x: T, y: H }, direction: 0 > r[u].y === a.axisY.reversed ? 1 : -1, color: w });\r\n                                    }\r\n                            b.stroke();\r\n                            v && c.stroke();\r\n                        }\r\n                    }\r\n                    ia.drawMarkers(g);\r\n                    v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());\r\n                    b.restore();\r\n                    b.beginPath();\r\n                    return { source: f, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear,\r\n                        animationBase: 0 };\r\n                }\r\n            };\r\n        s.prototype.renderStepLine = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = this._eventManager.ghostCtx;\r\n                b.save();\r\n                var e = this.plotArea;\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                    var t = a.dataSeriesIndexes[l], k = this.data[t];\r\n                    b.lineWidth = k.lineThickness;\r\n                    var r = k.dataPoints, p = \"solid\";\r\n                    if (b.setLineDash) {\r\n                        var n = G(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, d = G(p, k.lineThickness);\r\n                        b.setLineDash(d);\r\n                    }\r\n                    var w = k.id;\r\n                    this._eventManager.objectMap[w] = { objectType: \"dataSeries\", dataSeriesIndex: t };\r\n                    w = S(w);\r\n                    c.strokeStyle = w;\r\n                    c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\r\n                    var w = k._colorSet, m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];\r\n                    b.strokeStyle = w;\r\n                    var D = !0, u = 0, T, H;\r\n                    b.beginPath();\r\n                    if (0 < r.length) {\r\n                        for (var q = !1, u = 0; u < r.length; u++)\r\n                            if (T = r[u].getTime ? r[u].x.getTime() : r[u].x, !(T < a.axisX.dataInfo.viewPortMin || T > a.axisX.dataInfo.viewPortMax &&\r\n                                (!k.connectNullData || !q)))\r\n                                if (\"number\" !== typeof r[u].y)\r\n                                    0 < u && !(k.connectNullData || q || D) && (b.stroke(), v && c.stroke()), q = !0;\r\n                                else {\r\n                                    var s = H;\r\n                                    T = a.axisX.convertValueToPixel(T);\r\n                                    H = a.axisY.convertValueToPixel(r[u].y);\r\n                                    var A = k.dataPointIds[u];\r\n                                    this._eventManager.objectMap[A] = { id: A, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: u, x1: T, y1: H };\r\n                                    D || q ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)), b.lineTo(T, s), b.lineTo(T, H), v && (c.lineTo(T, s), c.lineTo(T, H))) : (b.beginPath(), b.moveTo(T, H), v && (c.beginPath(), c.moveTo(T, H))), q = D = !1) : (b.lineTo(T, s), v && c.lineTo(T, s), b.lineTo(T, H), v && c.lineTo(T, H), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(T, H), v && (c.stroke(), c.beginPath(), c.moveTo(T, H))));\r\n                                    h = { x: T, y: H };\r\n                                    u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(T, H), m = r[u].lineColor || w, b.strokeStyle =\r\n                                        m, b.setLineDash && (r[u].lineDashType ? (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));\r\n                                    if (0 < r[u].markerSize || 0 < k.markerSize)\r\n                                        s = k.getMarkerProperties(u, T, H, b), g.push(s), A = S(A), v && g.push({ x: T, y: H, ctx: c, type: s.type, size: s.size, color: A, borderColor: A, borderThickness: s.borderThickness });\r\n                                    (r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stepLine\", dataPoint: r[u], dataSeries: k, point: { x: T, y: H }, direction: 0 >\r\n                                            r[u].y === a.axisY.reversed ? 1 : -1, color: w });\r\n                                }\r\n                        b.stroke();\r\n                        v && c.stroke();\r\n                    }\r\n                }\r\n                ia.drawMarkers(g);\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());\r\n                b.restore();\r\n                b.beginPath();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderSpline = function (a) {\r\n            function f(a) {\r\n                a = x(a, 2);\r\n                if (0 < a.length) {\r\n                    c.beginPath();\r\n                    v && e.beginPath();\r\n                    c.moveTo(a[0].x, a[0].y);\r\n                    a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle);\r\n                    a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray);\r\n                    v && e.moveTo(a[0].x, a[0].y);\r\n                    for (var b = 0; b < a.length - 3; b += 3)\r\n                        if (c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b +\r\n                            2].y, a[b + 3].x, a[b + 3].y), v && e.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), 0 < b && 0 === b % 3E3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray)\r\n                            c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), v && (e.stroke(), e.beginPath(), e.moveTo(a[b + 3].x, a[b + 3].y));\r\n                    c.stroke();\r\n                    v && e.stroke();\r\n                }\r\n            }\r\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = this._eventManager.ghostCtx;\r\n                c.save();\r\n                var g = this.plotArea;\r\n                c.beginPath();\r\n                c.rect(g.x1, g.y1, g.width, g.height);\r\n                c.clip();\r\n                for (var h = [], l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                    var t = a.dataSeriesIndexes[l], k = this.data[t];\r\n                    c.lineWidth = k.lineThickness;\r\n                    var r = k.dataPoints, p = \"solid\";\r\n                    if (c.setLineDash) {\r\n                        var n = G(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, d = G(p, k.lineThickness);\r\n                        c.setLineDash(d);\r\n                    }\r\n                    var w = k.id;\r\n                    this._eventManager.objectMap[w] = { objectType: \"dataSeries\", dataSeriesIndex: t };\r\n                    w = S(w);\r\n                    e.strokeStyle = w;\r\n                    e.lineWidth =\r\n                        0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;\r\n                    var w = k._colorSet, m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];\r\n                    c.strokeStyle = w;\r\n                    var D = 0, u, T, H = [];\r\n                    c.beginPath();\r\n                    if (0 < r.length)\r\n                        for (T = !1, D = 0; D < r.length; D++)\r\n                            if (u = r[D].getTime ? r[D].x.getTime() : r[D].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !T)))\r\n                                if (\"number\" !== typeof r[D].y)\r\n                                    0 < D && !T && (k.connectNullData ? c.setLineDash && (0 < H.length && (k.options.nullDataLineDashType || !r[D - 1].lineDashType)) && (H[H.length -\r\n                                        1].newLineDashArray = n, p = k.nullDataLineDashType) : (f(H), H = [])), T = !0;\r\n                                else {\r\n                                    u = a.axisX.convertValueToPixel(u);\r\n                                    T = a.axisY.convertValueToPixel(r[D].y);\r\n                                    var s = k.dataPointIds[D];\r\n                                    this._eventManager.objectMap[s] = { id: s, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: D, x1: u, y1: T };\r\n                                    H[H.length] = { x: u, y: T };\r\n                                    D < r.length - 1 && (m !== (r[D].lineColor || w) || p !== (r[D].lineDashType || k.lineDashType)) && (m = r[D].lineColor || w, H[H.length - 1].newStrokeStyle = m, c.setLineDash && (r[D].lineDashType ? (p = r[D].lineDashType, H[H.length - 1].newLineDashArray =\r\n                                        G(p, k.lineThickness)) : (p = k.lineDashType, H[H.length - 1].newLineDashArray = d)));\r\n                                    if (0 < r[D].markerSize || 0 < k.markerSize) {\r\n                                        var q = k.getMarkerProperties(D, u, T, c);\r\n                                        h.push(q);\r\n                                        s = S(s);\r\n                                        v && h.push({ x: u, y: T, ctx: e, type: q.type, size: q.size, color: s, borderColor: s, borderThickness: q.borderThickness });\r\n                                    }\r\n                                    (r[D].indexLabel || k.indexLabel || r[D].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"spline\", dataPoint: r[D], dataSeries: k, point: { x: u, y: T }, direction: 0 > r[D].y === a.axisY.reversed ? 1 : -1, color: w });\r\n                                    T = !1;\r\n                                }\r\n                    f(H);\r\n                }\r\n                ia.drawMarkers(h);\r\n                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath());\r\n                c.restore();\r\n                c.beginPath();\r\n                return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation,\r\n                    easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        var W = function (a, f, b, c, e, g, h, l, t, k, r, p, n) {\r\n            \"undefined\" === typeof n && (n = 1);\r\n            h = h || 0;\r\n            l = l || \"black\";\r\n            var d = 15 < c - f && 15 < e - b ? 8 : 0.35 * Math.min(c - f, e - b);\r\n            a.beginPath();\r\n            a.moveTo(f, b);\r\n            a.save();\r\n            a.fillStyle = g;\r\n            a.globalAlpha = n;\r\n            a.fillRect(f, b, c - f, e - b);\r\n            a.globalAlpha = 1;\r\n            0 < h && (n = 0 === h % 2 ? 0 : 0.5, a.beginPath(), a.lineWidth = h, a.strokeStyle = l, a.moveTo(f, b), a.rect(f - n, b - n, c - f + 2 * n, e - b + 2 * n), a.stroke());\r\n            a.restore();\r\n            !0 === t && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b + d), a.lineTo(c -\r\n                d, b + d), a.lineTo(c, b), a.closePath(), h = a.createLinearGradient((c + f) / 2, b + d, (c + f) / 2, b), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, .4)\"), a.fillStyle = h, a.fill(), a.restore());\r\n            !0 === k && (a.save(), a.beginPath(), a.moveTo(f, e), a.lineTo(f + d, e - d), a.lineTo(c - d, e - d), a.lineTo(c, e), a.closePath(), h = a.createLinearGradient((c + f) / 2, e - d, (c + f) / 2, e), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, .4)\"), a.fillStyle = h, a.fill(), a.restore());\r\n            !0 === r && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b +\r\n                d), a.lineTo(f + d, e - d), a.lineTo(f, e), a.closePath(), h = a.createLinearGradient(f + d, (e + b) / 2, f, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, a.fill(), a.restore());\r\n            !0 === p && (a.save(), a.beginPath(), a.moveTo(c, b), a.lineTo(c - d, b + d), a.lineTo(c - d, e - d), a.lineTo(c, e), h = a.createLinearGradient(c - d, (e + b) / 2, c, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, h.addColorStop(0, g), h.addColorStop(1, \"rgba(255, 255, 255, 0.1)\"), a.fillStyle = h, a.fill(),\r\n                a.closePath(), a.restore());\r\n        };\r\n        s.prototype.renderColumn = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = 0, h, l, t, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = this.dataPointMinWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, r = this.dataPointMaxWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth :\r\n                    Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff;\r\n                isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));\r\n                p = this.dataPointWidth = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\r\n                this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && r < g) &&\r\n                    (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));\r\n                p < g && (p = g);\r\n                p > r && (p = r);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (r = 0; r < a.dataSeriesIndexes.length; r++) {\r\n                    var n = a.dataSeriesIndexes[r], d = this.data[n], w = d.dataPoints;\r\n                    if (0 < w.length)\r\n                        for (var m = 5 < p && d.bevelEnabled ? !0 : !1, g = 0; g < w.length; g++)\r\n                            if (w[g].getTime ?\r\n                                t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof w[g].y) {\r\n                                h = a.axisX.convertValueToPixel(t);\r\n                                l = a.axisY.convertValueToPixel(w[g].y);\r\n                                h = a.axisX.reversed ? h + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : h - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + r) * p << 0;\r\n                                var D = a.axisX.reversed ? h - p << 0 : h + p << 0, u;\r\n                                0 <= w[g].y ? u = k : (u = l, l = k);\r\n                                l > u && (c = l, l = u, u = c);\r\n                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];\r\n                                W(b, h, l, D, u, c, 0, null, m && 0 <= w[g].y, 0 > w[g].y && m, !1, !1, d.fillOpacity);\r\n                                c = d.dataPointIds[g];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: h, y1: l, x2: D, y2: u };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, h, l, D, u, c, 0, null, !1, !1, !1, !1);\r\n                                (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({ chartType: \"column\", dataPoint: w[g], dataSeries: d, point: { x: h + (D - h) / 2, y: 0 > w[g].y === a.axisY.reversed ? l : u }, direction: 0 > w[g].y === a.axisY.reversed ?\r\n                                        1 : -1, bounds: { x1: h, y1: Math.min(l, u), x2: D, y2: Math.max(l, u) }, color: c });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.yScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k };\r\n            }\r\n        };\r\n        s.prototype.renderStackedColumn = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = [], h = [], l = [], t = [], k = 0, r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;\r\n                var d = a.axisX.dataInfo.minDiff;\r\n                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));\r\n                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\r\n                this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ?\r\n                    this.dataPointWidth : Infinity, r));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && r < k) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));\r\n                d < k && (d = k);\r\n                d > r && (d = r);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\r\n                    var m = a.dataSeriesIndexes[w], D = this.data[m], u = D.dataPoints;\r\n                    if (0 < u.length) {\r\n                        var T = 5 < d && D.bevelEnabled ? !0 : !1;\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        for (k = 0; k < u.length; k++)\r\n                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\r\n                                r = a.axisX.convertValueToPixel(c);\r\n                                var s = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0, q = s + d << 0, y;\r\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y)\r\n                                    l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (p = a.axisY.convertValueToPixel(l[c]),\r\n                                        y = \"undefined\" !== typeof g[c] ? g[c] : n, g[c] = p);\r\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y)\r\n                                    t[c] = u[k].y + (t[c] ? t[c] : 0), y = a.axisY.convertValueToPixel(t[c]), p = \"undefined\" !== typeof h[c] ? h[c] : n, h[c] = y;\r\n                                else if (p = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {\r\n                                    var A = \"undefined\" !== typeof g[c] ? g[c] : 0;\r\n                                    p -= A;\r\n                                    y = n - A;\r\n                                    g[c] = A + (y - p);\r\n                                }\r\n                                else\r\n                                    A = h[c] ? h[c] : 0, y = p + A, p = n + A, h[c] = A + (y - p);\r\n                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];\r\n                                W(b, s, p, q, y, c, 0, null, T && 0 <= u[k].y, 0 > u[k].y && T, !1, !1, D.fillOpacity);\r\n                                c = D.dataPointIds[k];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: s, y1: p, x2: q, y2: y };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, s, p, q, y, c, 0, null, !1, !1, !1, !1);\r\n                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedColumn\", dataPoint: u[k], dataSeries: D, point: { x: r, y: 0 <= u[k].y ? p : y }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(p, y), x2: q, y2: Math.max(p, y) }, color: c });\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx,\r\n                    animationCallback: I.yScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\r\n            }\r\n        };\r\n        s.prototype.renderStackedColumn100 = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = [], h = [], l = [], t = [], k = 0, r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ?\r\n                    this.dataPointWidth : 1;\r\n                r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;\r\n                var d = a.axisX.dataInfo.minDiff;\r\n                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));\r\n                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\r\n                this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));\r\n                !this.dataPointMaxWidth &&\r\n                    (this.dataPointMinWidth && r < k) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));\r\n                d < k && (d = k);\r\n                d > r && (d = r);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\r\n                    var m = a.dataSeriesIndexes[w], D = this.data[m], u = D.dataPoints;\r\n                    if (0 < u.length)\r\n                        for (var s = 5 < d && D.bevelEnabled ?\r\n                            !0 : !1, k = 0; k < u.length; k++)\r\n                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\r\n                                r = a.axisX.convertValueToPixel(c);\r\n                                p = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;\r\n                                var q = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0, y = q + d << 0, B;\r\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {\r\n                                    l[c] = p + (\"undefined\" !== typeof l[c] ? l[c] : 0);\r\n                                    if (0 >= l[c])\r\n                                        continue;\r\n                                    p = a.axisY.convertValueToPixel(l[c]);\r\n                                    B = g[c] ? g[c] : n;\r\n                                    g[c] = p;\r\n                                }\r\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y)\r\n                                    t[c] = p + (\"undefined\" !== typeof t[c] ? t[c] : 0), B = a.axisY.convertValueToPixel(t[c]), p = h[c] ? h[c] : n, h[c] = B;\r\n                                else if (p = a.axisY.convertValueToPixel(p), 0 <= u[k].y) {\r\n                                    var A = \"undefined\" !== typeof g[c] ? g[c] : 0;\r\n                                    p -= A;\r\n                                    B = n - A;\r\n                                    a.dataSeriesIndexes.length - 1 === w && 1 >= Math.abs(e.y1 - p) && (p = e.y1);\r\n                                    g[c] = A + (B - p);\r\n                                }\r\n                                else\r\n                                    A = \"undefined\" !== typeof h[c] ? h[c] : 0, B = p + A, p = n + A, a.dataSeriesIndexes.length - 1 === w && 1 >= Math.abs(e.y2 - B) && (B = e.y2), h[c] =\r\n                                        A + (B - p);\r\n                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];\r\n                                W(b, q, p, y, B, c, 0, null, s && 0 <= u[k].y, 0 > u[k].y && s, !1, !1, D.fillOpacity);\r\n                                c = D.dataPointIds[k];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: q, y1: p, x2: y, y2: B };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, q, p, y, B, c, 0, null, !1, !1, !1, !1);\r\n                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedColumn100\", dataPoint: u[k], dataSeries: D,\r\n                                    point: { x: r, y: 0 <= u[k].y ? p : B }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: q, y1: Math.min(p, B), x2: y, y2: Math.max(p, B) }, color: c });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),\r\n                    b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.yScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n };\r\n            }\r\n        };\r\n        s.prototype.renderBar = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = 0, h, l, t, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ?\r\n                    a.axisY.viewportMinimum : 0), g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff;\r\n                isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));\r\n                p = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) /\r\n                    a.plotType.totalDataSeries) << 0;\r\n                this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && r < g) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));\r\n                p < g && (p = g);\r\n                p > r && (p = r);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (r = 0; r < a.dataSeriesIndexes.length; r++) {\r\n                    var n = a.dataSeriesIndexes[r], d = this.data[n], w = d.dataPoints;\r\n                    if (0 < w.length) {\r\n                        var m = 5 < p && d.bevelEnabled ? !0 : !1;\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        for (g = 0; g < w.length; g++)\r\n                            if (w[g].getTime ? t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof w[g].y) {\r\n                                l = a.axisX.convertValueToPixel(t);\r\n                                h = a.axisY.convertValueToPixel(w[g].y);\r\n                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : l - a.plotType.totalDataSeries *\r\n                                    p / 2 + (a.previousDataSeriesCount + r) * p << 0;\r\n                                var D = a.axisX.reversed ? l - p << 0 : l + p << 0, u;\r\n                                0 <= w[g].y ? u = k : (u = h, h = k);\r\n                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];\r\n                                W(b, u, l, h, D, c, 0, null, m, !1, !1, !1, d.fillOpacity);\r\n                                c = d.dataPointIds[g];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: u, y1: l, x2: h, y2: D };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, u, l, h, D, c, 0, null, !1, !1, !1, !1);\r\n                                (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bar\",\r\n                                    dataPoint: w[g], dataSeries: d, point: { x: 0 <= w[g].y ? h : u, y: l + (D - l) / 2 }, direction: 0 > w[g].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(u, h), y1: l, x2: Math.max(u, h), y2: D }, color: c });\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.xScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k };\r\n            }\r\n        };\r\n        s.prototype.renderStackedBar = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = [], h = [], l = [], t = [], k = 0, r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;\r\n                var d = a.axisX.dataInfo.minDiff;\r\n                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));\r\n                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) /\r\n                    Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\r\n                this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, p));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));\r\n                d < k && (d = k);\r\n                d > p && (d = p);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height),\r\n                    this._eventManager.ghostCtx.clip());\r\n                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\r\n                    var m = a.dataSeriesIndexes[w], D = this.data[m], u = D.dataPoints;\r\n                    if (0 < u.length) {\r\n                        var s = 5 < d && D.bevelEnabled ? !0 : !1;\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        for (k = 0; k < u.length; k++)\r\n                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\r\n                                p = a.axisX.convertValueToPixel(c);\r\n                                var q = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0, y = q + d << 0, B;\r\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks &&\r\n                                    0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y)\r\n                                    l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (B = g[c] ? g[c] : n, g[c] = r = a.axisY.convertValueToPixel(l[c]));\r\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y)\r\n                                    t[c] = u[k].y + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = B = a.axisY.convertValueToPixel(t[c]);\r\n                                else if (r = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {\r\n                                    var A = g[c] ? g[c] : 0;\r\n                                    B = n + A;\r\n                                    r += A;\r\n                                    g[c] = A + (r - B);\r\n                                }\r\n                                else\r\n                                    A = h[c] ? h[c] : 0, B = r - A, r = n - A, h[c] = A + (r - B);\r\n                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];\r\n                                W(b, B, q, r, y, c, 0, null, s, !1, !1, !1, D.fillOpacity);\r\n                                c = D.dataPointIds[k];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: B, y1: q, x2: r, y2: y };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, B, q, r, y, c, 0, null, !1, !1, !1, !1);\r\n                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar\", dataPoint: u[k], dataSeries: D, point: { x: 0 <= u[k].y ? r : B, y: p }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(B, r), y1: q, x2: Math.max(B, r), y2: y }, color: c });\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.xScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\r\n            }\r\n        };\r\n        s.prototype.renderStackedBar100 = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = [], h = [], l = [], t = [], k = 0, r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.dataPointMinWidth ?\r\n                    this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;\r\n                var d = a.axisX.dataInfo.minDiff;\r\n                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));\r\n                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;\r\n                this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth :\r\n                    Infinity, p));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));\r\n                d < k && (d = k);\r\n                d > p && (d = p);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {\r\n                    var m = a.dataSeriesIndexes[w], D = this.data[m], u = D.dataPoints;\r\n                    if (0 < u.length) {\r\n                        var q = 5 < d && D.bevelEnabled ? !0 : !1;\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        for (k = 0; k < u.length; k++)\r\n                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof u[k].y) {\r\n                                p = a.axisX.convertValueToPixel(c);\r\n                                var s;\r\n                                s = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;\r\n                                var y = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0, B = y + d << 0;\r\n                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {\r\n                                    l[c] = s +\r\n                                        (l[c] ? l[c] : 0);\r\n                                    if (0 >= l[c])\r\n                                        continue;\r\n                                    s = g[c] ? g[c] : n;\r\n                                    g[c] = r = a.axisY.convertValueToPixel(l[c]);\r\n                                }\r\n                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y)\r\n                                    t[c] = s + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = s = a.axisY.convertValueToPixel(t[c]);\r\n                                else if (r = a.axisY.convertValueToPixel(s), 0 <= u[k].y) {\r\n                                    var A = g[c] ? g[c] : 0;\r\n                                    s = n + A;\r\n                                    r += A;\r\n                                    a.dataSeriesIndexes.length - 1 === w && 1 >= Math.abs(e.x2 - r) && (r = e.x2);\r\n                                    g[c] = A + (r - s);\r\n                                }\r\n                                else\r\n                                    A = h[c] ? h[c] : 0, s = r - A, r = n - A, a.dataSeriesIndexes.length - 1 === w && 1 >= Math.abs(e.x1 - s) && (s = e.x1),\r\n                                        h[c] = A + (r - s);\r\n                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];\r\n                                W(b, s, y, r, B, c, 0, null, q, !1, !1, !1, D.fillOpacity);\r\n                                c = D.dataPointIds[k];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: m, dataPointIndex: k, x1: s, y1: y, x2: r, y2: B };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, s, y, r, B, c, 0, null, !1, !1, !1, !1);\r\n                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedBar100\", dataPoint: u[k], dataSeries: D, point: { x: 0 <= u[k].y ?\r\n                                            r : s, y: p }, direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(s, r), y1: y, x2: Math.max(s, r), y2: B }, color: c });\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.xScaleAnimation, easingFunction: I.easing.easeOutQuart, animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n };\r\n            }\r\n        };\r\n        s.prototype.renderArea = function (a) {\r\n            var f, b;\r\n            function c() {\r\n                A && (0 < w.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum &&\r\n                    (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x, B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = { x: u, y: s });\r\n            }\r\n            var e = a.targetCanvasCtx || this.plotArea.ctx, g = v ? this._preRenderCtx : e;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var h = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, t = a.axisY.lineCoordinates, k = [], r = this.plotArea, p;\r\n                g.save();\r\n                v && h.save();\r\n                g.beginPath();\r\n                g.rect(r.x1, r.y1, r.width, r.height);\r\n                g.clip();\r\n                v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());\r\n                for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\r\n                    var d = a.dataSeriesIndexes[n], w = this.data[d], m = w.dataPoints, k = w.id;\r\n                    this._eventManager.objectMap[k] = { objectType: \"dataSeries\", dataSeriesIndex: d };\r\n                    k = S(k);\r\n                    h.fillStyle = k;\r\n                    k = [];\r\n                    f = !0;\r\n                    var D = 0, u, s, q, y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), B, A = null;\r\n                    if (0 < m.length) {\r\n                        var x = w._colorSet[D % w._colorSet.length], z = w.lineColor = w.options.lineColor || x, K = z;\r\n                        g.fillStyle =\r\n                            x;\r\n                        g.strokeStyle = z;\r\n                        g.lineWidth = w.lineThickness;\r\n                        b = \"solid\";\r\n                        if (g.setLineDash) {\r\n                            var J = G(w.nullDataLineDashType, w.lineThickness);\r\n                            b = w.lineDashType;\r\n                            var ca = G(b, w.lineThickness);\r\n                            g.setLineDash(ca);\r\n                        }\r\n                        for (var da = !0; D < m.length; D++)\r\n                            if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !da)))\r\n                                if (\"number\" !== typeof m[D].y)\r\n                                    w.connectNullData || (da || f) || c(), da = !0;\r\n                                else {\r\n                                    u = a.axisX.convertValueToPixel(q);\r\n                                    s = a.axisY.convertValueToPixel(m[D].y);\r\n                                    f || da ? (!f &&\r\n                                        w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || b === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f = u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, b = w.nullDataLineDashType, g.setLineDash(J)), g.lineTo(u, s), v && h.lineTo(u, s)) : (g.beginPath(), g.moveTo(u, s), v && (h.beginPath(), h.moveTo(u, s)), A = { x: u, y: s }), da = f = !1) : (g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c());\r\n                                    p = { x: u, y: s };\r\n                                    D < m.length - 1 && (K !== (m[D].lineColor || z) || b !== (m[D].lineDashType || w.lineDashType)) && (c(), K = m[D].lineColor ||\r\n                                        z, g.strokeStyle = K, g.setLineDash && (m[D].lineDashType ? (b = m[D].lineDashType, g.setLineDash(G(b, w.lineThickness))) : (b = w.lineDashType, g.setLineDash(ca))));\r\n                                    var aa = w.dataPointIds[D];\r\n                                    this._eventManager.objectMap[aa] = { id: aa, objectType: \"dataPoint\", dataSeriesIndex: d, dataPointIndex: D, x1: u, y1: s };\r\n                                    0 !== m[D].markerSize && (0 < m[D].markerSize || 0 < w.markerSize) && (q = w.getMarkerProperties(D, u, s, g), k.push(q), aa = S(aa), v && k.push({ x: u, y: s, ctx: h, type: q.type, size: q.size, color: aa, borderColor: aa, borderThickness: q.borderThickness }));\r\n                                    (m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({ chartType: \"area\", dataPoint: m[D], dataSeries: w, point: { x: u, y: s }, direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1, color: x });\r\n                                }\r\n                        c();\r\n                        ia.drawMarkers(k);\r\n                    }\r\n                }\r\n                v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height),\r\n                    this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\r\n                g.restore();\r\n                return { source: e, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderSplineArea = function (a) {\r\n            function f() {\r\n                var b = x(q, 2);\r\n                if (0 < b.length) {\r\n                    if (0 < p.lineThickness) {\r\n                        c.beginPath();\r\n                        c.moveTo(b[0].x, b[0].y);\r\n                        b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle);\r\n                        b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);\r\n                        for (var d = 0; d < b.length - 3; d += 3)\r\n                            if (c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle || b[d + 3].newLineDashArray)\r\n                                c.stroke(), c.beginPath(), c.moveTo(b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle && (c.strokeStyle = b[d + 3].newStrokeStyle), b[d + 3].newLineDashArray && c.setLineDash(b[d + 3].newLineDashArray);\r\n                        c.stroke();\r\n                    }\r\n                    c.beginPath();\r\n                    c.moveTo(b[0].x, b[0].y);\r\n                    v && (e.beginPath(), e.moveTo(b[0].x, b[0].y));\r\n                    for (d = 0; d < b.length - 3; d += 3)\r\n                        c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y);\r\n                    a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? u = D : 0 > a.axisY.viewportMaximum ? u = h.y1 : 0 < a.axisY.viewportMinimum && (u = g.y2);\r\n                    s = { x: b[0].x, y: b[0].y };\r\n                    c.lineTo(b[b.length - 1].x, u);\r\n                    c.lineTo(s.x, u);\r\n                    c.closePath();\r\n                    c.globalAlpha = p.fillOpacity;\r\n                    c.fill();\r\n                    c.globalAlpha =\r\n                        1;\r\n                    v && (e.lineTo(b[b.length - 1].x, u), e.lineTo(s.x, u), e.closePath(), e.fill());\r\n                }\r\n            }\r\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = this._eventManager.ghostCtx, g = a.axisX.lineCoordinates, h = a.axisY.lineCoordinates, l = [], t = this.plotArea;\r\n                c.save();\r\n                v && e.save();\r\n                c.beginPath();\r\n                c.rect(t.x1, t.y1, t.width, t.height);\r\n                c.clip();\r\n                v && (e.beginPath(), e.rect(t.x1, t.y1, t.width, t.height), e.clip());\r\n                for (var k = 0; k < a.dataSeriesIndexes.length; k++) {\r\n                    var r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, l = p.id;\r\n                    this._eventManager.objectMap[l] = { objectType: \"dataSeries\", dataSeriesIndex: r };\r\n                    l = S(l);\r\n                    e.fillStyle = l;\r\n                    var l = [], d = 0, w, m, D = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u, s = null, q = [];\r\n                    if (0 < n.length) {\r\n                        var y = p._colorSet[d % p._colorSet.length], B = p.lineColor = p.options.lineColor || y, A = B;\r\n                        c.fillStyle = y;\r\n                        c.strokeStyle = B;\r\n                        c.lineWidth = p.lineThickness;\r\n                        var z = \"solid\";\r\n                        if (c.setLineDash) {\r\n                            var M = G(p.nullDataLineDashType, p.lineThickness), z = p.lineDashType, K = G(z, p.lineThickness);\r\n                            c.setLineDash(K);\r\n                        }\r\n                        for (m = !1; d < n.length; d++)\r\n                            if (w = n[d].x.getTime ? n[d].x.getTime() : n[d].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!p.connectNullData || !m)))\r\n                                if (\"number\" !== typeof n[d].y)\r\n                                    0 < d && !m && (p.connectNullData ? c.setLineDash && (0 < q.length && (p.options.nullDataLineDashType || !n[d - 1].lineDashType)) && (q[q.length - 1].newLineDashArray = M, z = p.nullDataLineDashType) : (f(), q = [])), m = !0;\r\n                                else {\r\n                                    w = a.axisX.convertValueToPixel(w);\r\n                                    m = a.axisY.convertValueToPixel(n[d].y);\r\n                                    var J = p.dataPointIds[d];\r\n                                    this._eventManager.objectMap[J] =\r\n                                        { id: J, objectType: \"dataPoint\", dataSeriesIndex: r, dataPointIndex: d, x1: w, y1: m };\r\n                                    q[q.length] = { x: w, y: m };\r\n                                    d < n.length - 1 && (A !== (n[d].lineColor || B) || z !== (n[d].lineDashType || p.lineDashType)) && (A = n[d].lineColor || B, q[q.length - 1].newStrokeStyle = A, c.setLineDash && (n[d].lineDashType ? (z = n[d].lineDashType, q[q.length - 1].newLineDashArray = G(z, p.lineThickness)) : (z = p.lineDashType, q[q.length - 1].newLineDashArray = K)));\r\n                                    if (0 !== n[d].markerSize && (0 < n[d].markerSize || 0 < p.markerSize)) {\r\n                                        var ca = p.getMarkerProperties(d, w, m, c);\r\n                                        l.push(ca);\r\n                                        J = S(J);\r\n                                        v && l.push({ x: w, y: m, ctx: e, type: ca.type, size: ca.size, color: J, borderColor: J, borderThickness: ca.borderThickness });\r\n                                    }\r\n                                    (n[d].indexLabel || p.indexLabel || n[d].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"splineArea\", dataPoint: n[d], dataSeries: p, point: { x: w, y: m }, direction: 0 > n[d].y === a.axisY.reversed ? 1 : -1, color: y });\r\n                                    m = !1;\r\n                                }\r\n                        f();\r\n                        ia.drawMarkers(l);\r\n                    }\r\n                }\r\n                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(t.x1, t.y1, t.width, t.height), this._eventManager.ghostCtx.restore());\r\n                c.restore();\r\n                return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderStepArea = function (a) {\r\n            var f, b;\r\n            function c() {\r\n                A && (0 < w.lineThickness &&\r\n                    g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum && (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x, B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = { x: u, y: s });\r\n            }\r\n            var e = a.targetCanvasCtx || this.plotArea.ctx, g = v ? this._preRenderCtx : e;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var h = this._eventManager.ghostCtx, l = a.axisX.lineCoordinates, t = a.axisY.lineCoordinates, k = [], r = this.plotArea, p;\r\n                g.save();\r\n                v && h.save();\r\n                g.beginPath();\r\n                g.rect(r.x1, r.y1, r.width, r.height);\r\n                g.clip();\r\n                v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());\r\n                for (var n = 0; n < a.dataSeriesIndexes.length; n++) {\r\n                    var d = a.dataSeriesIndexes[n], w = this.data[d], m = w.dataPoints, k = w.id;\r\n                    this._eventManager.objectMap[k] = { objectType: \"dataSeries\", dataSeriesIndex: d };\r\n                    k = S(k);\r\n                    h.fillStyle = k;\r\n                    k = [];\r\n                    f = !0;\r\n                    var D = 0, u, s, q, y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum :\r\n                        0), B, A = null;\r\n                    b = !1;\r\n                    if (0 < m.length) {\r\n                        var x = w._colorSet[D % w._colorSet.length], z = w.lineColor = w.options.lineColor || x, K = z;\r\n                        g.fillStyle = x;\r\n                        g.strokeStyle = z;\r\n                        g.lineWidth = w.lineThickness;\r\n                        var J = \"solid\";\r\n                        if (g.setLineDash) {\r\n                            var ca = G(w.nullDataLineDashType, w.lineThickness), J = w.lineDashType, da = G(J, w.lineThickness);\r\n                            g.setLineDash(da);\r\n                        }\r\n                        for (; D < m.length; D++)\r\n                            if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !b))) {\r\n                                var aa = s;\r\n                                \"number\" !== typeof m[D].y ?\r\n                                    (w.connectNullData || (b || f) || c(), b = !0) : (u = a.axisX.convertValueToPixel(q), s = a.axisY.convertValueToPixel(m[D].y), f || b ? (!f && w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || J === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f = u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, J = w.nullDataLineDashType, g.setLineDash(ca)), g.lineTo(u, aa), g.lineTo(u, s), v && (h.lineTo(u, aa), h.lineTo(u, s))) : (g.beginPath(), g.moveTo(u, s), v && (h.beginPath(), h.moveTo(u, s)), A = { x: u, y: s }), b = f = !1) : (g.lineTo(u, aa), v && h.lineTo(u, aa), g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c()), p = { x: u, y: s }, D < m.length - 1 && (K !== (m[D].lineColor || z) || J !== (m[D].lineDashType || w.lineDashType)) && (c(), K = m[D].lineColor || z, g.strokeStyle = K, g.setLineDash && (m[D].lineDashType ? (J = m[D].lineDashType, g.setLineDash(G(J, w.lineThickness))) : (J = w.lineDashType, g.setLineDash(da)))), q = w.dataPointIds[D], this._eventManager.objectMap[q] = { id: q, objectType: \"dataPoint\", dataSeriesIndex: d, dataPointIndex: D, x1: u, y1: s }, 0 !== m[D].markerSize && (0 < m[D].markerSize ||\r\n                                    0 < w.markerSize) && (aa = w.getMarkerProperties(D, u, s, g), k.push(aa), q = S(q), v && k.push({ x: u, y: s, ctx: h, type: aa.type, size: aa.size, color: q, borderColor: q, borderThickness: aa.borderThickness })), (m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stepArea\", dataPoint: m[D], dataSeries: w, point: { x: u, y: s }, direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1, color: x }));\r\n                            }\r\n                        c();\r\n                        ia.drawMarkers(k);\r\n                    }\r\n                }\r\n                v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation =\r\n                    \"source-atop\", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());\r\n                g.restore();\r\n                return { source: e, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderStackedArea =\r\n            function (a) {\r\n                function f() { if (!(1 > t.length)) {\r\n                    for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {\r\n                        var a = t.pop();\r\n                        c.lineTo(a.x, a.y);\r\n                        v && s.lineTo(a.x, a.y);\r\n                    }\r\n                    c.closePath();\r\n                    c.globalAlpha = A.fillOpacity;\r\n                    c.fill();\r\n                    c.globalAlpha = 1;\r\n                    c.beginPath();\r\n                    v && (s.closePath(), s.fill(), s.beginPath());\r\n                    t = [];\r\n                } }\r\n                var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n                if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                    var e = null, g = [], h = this.plotArea, l = [], t = [], k = [], r = [], p = 0, n, d, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum :\r\n                        0), s = this._eventManager.ghostCtx, u, q, y;\r\n                    v && s.beginPath();\r\n                    c.save();\r\n                    v && s.save();\r\n                    c.beginPath();\r\n                    c.rect(h.x1, h.y1, h.width, h.height);\r\n                    c.clip();\r\n                    v && (s.beginPath(), s.rect(h.x1, h.y1, h.width, h.height), s.clip());\r\n                    for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {\r\n                        var B = a.dataSeriesIndexes[x], A = this.data[B], z = A.dataPoints;\r\n                        A.dataPointIndexes = [];\r\n                        for (p = 0; p < z.length; p++)\r\n                            B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);\r\n                        k.sort(Qa);\r\n                    }\r\n                    for (x = 0; x < a.dataSeriesIndexes.length; x++) {\r\n                        B = a.dataSeriesIndexes[x];\r\n                        A = this.data[B];\r\n                        z = A.dataPoints;\r\n                        q = !0;\r\n                        t = [];\r\n                        p = A.id;\r\n                        this._eventManager.objectMap[p] = { objectType: \"dataSeries\", dataSeriesIndex: B };\r\n                        p = S(p);\r\n                        s.fillStyle = p;\r\n                        if (0 < k.length) {\r\n                            var e = A._colorSet[0], M = A.lineColor = A.options.lineColor || e, K = M;\r\n                            c.fillStyle = e;\r\n                            c.strokeStyle = M;\r\n                            c.lineWidth = A.lineThickness;\r\n                            y = \"solid\";\r\n                            if (c.setLineDash) {\r\n                                var J = G(A.nullDataLineDashType, A.lineThickness);\r\n                                y = A.lineDashType;\r\n                                var ca = G(y, A.lineThickness);\r\n                                c.setLineDash(ca);\r\n                            }\r\n                            for (var da = !0, p = 0; p < k.length; p++) {\r\n                                w = k[p];\r\n                                var aa = null, aa = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] :\r\n                                    { x: w, y: null };\r\n                                if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !da)))\r\n                                    if (\"number\" !== typeof aa.y)\r\n                                        A.connectNullData || (da || q) || f(), da = !0;\r\n                                    else {\r\n                                        n = a.axisX.convertValueToPixel(w);\r\n                                        var xa = l[w] ? l[w] : 0;\r\n                                        if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\r\n                                            r[w] = aa.y + (r[w] ? r[w] : 0);\r\n                                            if (0 >= r[w] && a.axisY.logarithmic)\r\n                                                continue;\r\n                                            d = a.axisY.convertValueToPixel(r[w]);\r\n                                        }\r\n                                        else\r\n                                            d = a.axisY.convertValueToPixel(aa.y), d -= xa;\r\n                                        t.push({ x: n, y: m - xa });\r\n                                        l[w] = m - d;\r\n                                        q ||\r\n                                            da ? (!q && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || y === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (q = t.pop(), y = t[t.length - 1], f(), c.moveTo(u.x, u.y), t.push(y), t.push(q), y = A.nullDataLineDashType, c.setLineDash(J)), c.lineTo(n, d), v && s.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (s.beginPath(), s.moveTo(n, d))), da = q = !1) : (c.lineTo(n, d), v && s.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && s.moveTo(n, d), t.push({ x: n, y: m - xa })));\r\n                                        u = { x: n, y: d };\r\n                                        p < z.length - 1 && (K !== (z[p].lineColor ||\r\n                                            M) || y !== (z[p].lineDashType || A.lineDashType)) && (f(), c.beginPath(), c.moveTo(n, d), t.push({ x: n, y: m - xa }), K = z[p].lineColor || M, c.strokeStyle = K, c.setLineDash && (z[p].lineDashType ? (y = z[p].lineDashType, c.setLineDash(G(y, A.lineThickness))) : (y = A.lineDashType, c.setLineDash(ca))));\r\n                                        if (0 <= A.dataPointIndexes[w]) {\r\n                                            var na = A.dataPointIds[A.dataPointIndexes[w]];\r\n                                            this._eventManager.objectMap[na] = { id: na, objectType: \"dataPoint\", dataSeriesIndex: B, dataPointIndex: A.dataPointIndexes[w], x1: n, y1: d };\r\n                                        }\r\n                                        0 <= A.dataPointIndexes[w] && 0 !== aa.markerSize &&\r\n                                            (0 < aa.markerSize || 0 < A.markerSize) && (w = A.getMarkerProperties(A.dataPointIndexes[w], n, d, c), g.push(w), markerColor = S(na), v && g.push({ x: n, y: d, ctx: s, type: w.type, size: w.size, color: markerColor, borderColor: markerColor, borderThickness: w.borderThickness }));\r\n                                        (aa.indexLabel || A.indexLabel || aa.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea\", dataPoint: aa, dataSeries: A, point: { x: n, y: d }, direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1, color: e });\r\n                                    }\r\n                            }\r\n                            f();\r\n                            c.moveTo(n, d);\r\n                            v && s.moveTo(n, d);\r\n                        }\r\n                        delete A.dataPointIndexes;\r\n                    }\r\n                    ia.drawMarkers(g);\r\n                    v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), s.restore());\r\n                    c.restore();\r\n                    return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation,\r\n                        easingFunction: I.easing.linear, animationBase: 0 };\r\n                }\r\n            };\r\n        s.prototype.renderStackedArea100 = function (a) {\r\n            function f() { for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {\r\n                var a = t.pop();\r\n                c.lineTo(a.x, a.y);\r\n                v && y.lineTo(a.x, a.y);\r\n            } c.closePath(); c.globalAlpha = A.fillOpacity; c.fill(); c.globalAlpha = 1; c.beginPath(); v && (y.closePath(), y.fill(), y.beginPath()); t = []; }\r\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = null, g = this.plotArea, h = [], l = [], t = [], k = [], r = [], p = 0, n, d, w, m, s, u, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y = this._eventManager.ghostCtx;\r\n                c.save();\r\n                v && y.save();\r\n                c.beginPath();\r\n                c.rect(g.x1, g.y1, g.width, g.height);\r\n                c.clip();\r\n                v && (y.beginPath(), y.rect(g.x1, g.y1, g.width, g.height), y.clip());\r\n                for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {\r\n                    var B = a.dataSeriesIndexes[x], A = this.data[B], z = A.dataPoints;\r\n                    A.dataPointIndexes = [];\r\n                    for (p = 0; p < z.length; p++)\r\n                        B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);\r\n                    k.sort(Qa);\r\n                }\r\n                for (x = 0; x < a.dataSeriesIndexes.length; x++) {\r\n                    B = a.dataSeriesIndexes[x];\r\n                    A = this.data[B];\r\n                    z = A.dataPoints;\r\n                    s = !0;\r\n                    e = A.id;\r\n                    this._eventManager.objectMap[e] = { objectType: \"dataSeries\", dataSeriesIndex: B };\r\n                    e = S(e);\r\n                    y.fillStyle = e;\r\n                    t = [];\r\n                    if (0 < k.length) {\r\n                        var e = A._colorSet[p % A._colorSet.length], M = A.lineColor = A.options.lineColor || e, K = M;\r\n                        c.fillStyle = e;\r\n                        c.strokeStyle = M;\r\n                        c.lineWidth = A.lineThickness;\r\n                        u = \"solid\";\r\n                        if (c.setLineDash) {\r\n                            var J = G(A.nullDataLineDashType, A.lineThickness);\r\n                            u = A.lineDashType;\r\n                            var ca = G(u, A.lineThickness);\r\n                            c.setLineDash(ca);\r\n                        }\r\n                        for (var da = !0, p = 0; p < k.length; p++) {\r\n                            w = k[p];\r\n                            var aa = null, aa = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] : { x: w, y: null };\r\n                            if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !da)))\r\n                                if (\"number\" !== typeof aa.y)\r\n                                    A.connectNullData || (da || s) || f(), da = !0;\r\n                                else {\r\n                                    var xa;\r\n                                    xa = 0 !== a.dataPointYSums[w] ? 100 * (aa.y / a.dataPointYSums[w]) : 0;\r\n                                    n = a.axisX.convertValueToPixel(w);\r\n                                    var na = l[w] ? l[w] : 0;\r\n                                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {\r\n                                        r[w] = xa + (r[w] ? r[w] :\r\n                                            0);\r\n                                        if (0 >= r[w] && a.axisY.logarithmic)\r\n                                            continue;\r\n                                        d = a.axisY.convertValueToPixel(r[w]);\r\n                                    }\r\n                                    else\r\n                                        d = a.axisY.convertValueToPixel(xa), d -= na;\r\n                                    t.push({ x: n, y: q - na });\r\n                                    l[w] = q - d;\r\n                                    s || da ? (!s && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || u === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (s = t.pop(), u = t[t.length - 1], f(), c.moveTo(m.x, m.y), t.push(u), t.push(s), u = A.nullDataLineDashType, c.setLineDash(J)), c.lineTo(n, d), v && y.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (y.beginPath(), y.moveTo(n, d))),\r\n                                        da = s = !1) : (c.lineTo(n, d), v && y.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && y.moveTo(n, d), t.push({ x: n, y: q - na })));\r\n                                    m = { x: n, y: d };\r\n                                    p < z.length - 1 && (K !== (z[p].lineColor || M) || u !== (z[p].lineDashType || A.lineDashType)) && (f(), c.beginPath(), c.moveTo(n, d), t.push({ x: n, y: q - na }), K = z[p].lineColor || M, c.strokeStyle = K, c.setLineDash && (z[p].lineDashType ? (u = z[p].lineDashType, c.setLineDash(G(u, A.lineThickness))) : (u = A.lineDashType, c.setLineDash(ca))));\r\n                                    if (0 <= A.dataPointIndexes[w]) {\r\n                                        var E = A.dataPointIds[A.dataPointIndexes[w]];\r\n                                        this._eventManager.objectMap[E] =\r\n                                            { id: E, objectType: \"dataPoint\", dataSeriesIndex: B, dataPointIndex: A.dataPointIndexes[w], x1: n, y1: d };\r\n                                    }\r\n                                    0 <= A.dataPointIndexes[w] && 0 !== aa.markerSize && (0 < aa.markerSize || 0 < A.markerSize) && (w = A.getMarkerProperties(p, n, d, c), h.push(w), markerColor = S(E), v && h.push({ x: n, y: d, ctx: y, type: w.type, size: w.size, color: markerColor, borderColor: markerColor, borderThickness: w.borderThickness }));\r\n                                    (aa.indexLabel || A.indexLabel || aa.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({ chartType: \"stackedArea100\", dataPoint: aa,\r\n                                        dataSeries: A, point: { x: n, y: d }, direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1, color: e });\r\n                                }\r\n                        }\r\n                        f();\r\n                        c.moveTo(n, d);\r\n                        v && y.moveTo(n, d);\r\n                    }\r\n                    delete A.dataPointIndexes;\r\n                }\r\n                ia.drawMarkers(h);\r\n                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), y.restore());\r\n                c.restore();\r\n                return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderBubble = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = this.plotArea, e = 0, g, h;\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(c.x1, c.y1, c.width, c.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(),\r\n                    this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());\r\n                for (var l = -Infinity, t = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++)\r\n                    for (var r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, d = 0, e = 0; e < n.length; e++)\r\n                        g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || \"undefined\" === typeof n[e].z || (d = n[e].z, d > l && (l = d), d < t && (t = d));\r\n                for (var w = 25 * Math.PI, m = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, w), k = 0; k < a.dataSeriesIndexes.length; k++)\r\n                    if (r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, 0 < n.length)\r\n                        for (b.strokeStyle = \"#4572A7 \", e = 0; e < n.length; e++)\r\n                            if (g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof n[e].y) {\r\n                                g = a.axisX.convertValueToPixel(g);\r\n                                h = a.axisY.convertValueToPixel(n[e].y);\r\n                                var d = n[e].z, s = 2 * Math.max(Math.sqrt((l === t ? m / 2 : w + (m - w) / (l - t) * (d - t)) / Math.PI) << 0, 1), d = p.getMarkerProperties(e, b);\r\n                                d.size = s;\r\n                                b.globalAlpha =\r\n                                    p.fillOpacity;\r\n                                ia.drawMarker(g, h, b, d.type, d.size, d.color, d.borderColor, d.borderThickness);\r\n                                b.globalAlpha = 1;\r\n                                var u = p.dataPointIds[e];\r\n                                this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: r, dataPointIndex: e, x1: g, y1: h, size: s };\r\n                                s = S(u);\r\n                                v && ia.drawMarker(g, h, this._eventManager.ghostCtx, d.type, d.size, s, s, d.borderThickness);\r\n                                (n[e].indexLabel || p.indexLabel || n[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: \"bubble\", dataPoint: n[e], dataSeries: p, point: { x: g, y: h },\r\n                                    direction: 1, bounds: { x1: g - d.size / 2, y1: h - d.size / 2, x2: g + d.size / 2, y2: h + d.size / 2 }, color: null });\r\n                            }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderScatter = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = this.plotArea, e = 0, g, h;\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(c.x1, c.y1, c.width, c.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());\r\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                    var t = a.dataSeriesIndexes[l], k = this.data[t], r = k.dataPoints;\r\n                    if (0 < r.length) {\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2);\r\n                        for (var p = 0, n = 0, e = 0; e < r.length; e++)\r\n                            if (g = r[e].getTime ? g = r[e].x.getTime() : g = r[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && \"number\" === typeof r[e].y) {\r\n                                g = a.axisX.convertValueToPixel(g);\r\n                                h = a.axisY.convertValueToPixel(r[e].y);\r\n                                var d = k.getMarkerProperties(e, g, h, b);\r\n                                b.globalAlpha = k.fillOpacity;\r\n                                ia.drawMarker(d.x, d.y, d.ctx, d.type, d.size, d.color, d.borderColor, d.borderThickness);\r\n                                b.globalAlpha = 1;\r\n                                Math.sqrt((p - g) * (p - g) + (n - h) * (n - h)) < Math.min(d.size, 5) && r.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = k.dataPointIds[e], this._eventManager.objectMap[p] = { id: p, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: e, x1: g, y1: h }, p = S(p), v && ia.drawMarker(d.x, d.y, this._eventManager.ghostCtx, d.type, d.size, p, p, d.borderThickness), (r[e].indexLabel || k.indexLabel ||\r\n                                    r[e].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: \"scatter\", dataPoint: r[e], dataSeries: k, point: { x: g, y: h }, direction: 1, bounds: { x1: g - d.size / 2, y1: h - d.size / 2, x2: g + d.size / 2, y2: h + d.size / 2 }, color: null }), p = g, n = h);\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height),\r\n                    this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderCandlestick = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f, c = this._eventManager.ghostCtx;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = null, g = null, h = this.plotArea, l = 0, t, k, r, p, n, d, e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, g = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, w = a.axisX.dataInfo.minDiff;\r\n                isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));\r\n                w = this.dataPointWidth ? this.dataPointWidth : 0.7 * h.width * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;\r\n                this.dataPointMaxWidth && e > g && (e = Math.min(this.dataPointWidth ?\r\n                    this.dataPointWidth : Infinity, g));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && g < e) && (g = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));\r\n                w < e && (w = e);\r\n                w > g && (w = g);\r\n                b.save();\r\n                v && c.save();\r\n                b.beginPath();\r\n                b.rect(h.x1, h.y1, h.width, h.height);\r\n                b.clip();\r\n                v && (c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip());\r\n                for (var m = 0; m < a.dataSeriesIndexes.length; m++) {\r\n                    var s = a.dataSeriesIndexes[m], u = this.data[s], q = u.dataPoints;\r\n                    if (0 < q.length)\r\n                        for (var H = 5 < w && u.bevelEnabled ? !0 : !1, l = 0; l < q.length; l++)\r\n                            if (q[l].getTime ?\r\n                                d = q[l].x.getTime() : d = q[l].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(q[l].y) && q[l].y.length && \"number\" === typeof q[l].y[0] && \"number\" === typeof q[l].y[1] && \"number\" === typeof q[l].y[2] && \"number\" === typeof q[l].y[3]) {\r\n                                t = a.axisX.convertValueToPixel(d);\r\n                                k = a.axisY.convertValueToPixel(q[l].y[0]);\r\n                                r = a.axisY.convertValueToPixel(q[l].y[1]);\r\n                                p = a.axisY.convertValueToPixel(q[l].y[2]);\r\n                                n = a.axisY.convertValueToPixel(q[l].y[3]);\r\n                                var x = t - w / 2 << 0, B = x + w << 0, g = u.options.fallingColor ? u.fallingColor : u._colorSet[0], e = q[l].color ? q[l].color : u._colorSet[0], A = Math.round(Math.max(1, 0.15 * w)), z = 0 === A % 2 ? 0 : 0.5, M = u.dataPointIds[l];\r\n                                this._eventManager.objectMap[M] = { id: M, objectType: \"dataPoint\", dataSeriesIndex: s, dataPointIndex: l, x1: x, y1: k, x2: B, y2: r, x3: t, y3: p, x4: t, y4: n, borderThickness: A, color: e };\r\n                                b.strokeStyle = e;\r\n                                b.beginPath();\r\n                                b.lineWidth = A;\r\n                                c.lineWidth = Math.max(A, 4);\r\n                                \"candlestick\" === u.type ? (b.moveTo(t - z, r), b.lineTo(t - z, Math.min(k, n)), b.stroke(), b.moveTo(t - z, Math.max(k, n)), b.lineTo(t - z, p), b.stroke(), W(b, x, Math.min(k, n), B, Math.max(k, n), q[l].y[0] <= q[l].y[3] ? u.risingColor : g, A, e, H, H, !1, !1, u.fillOpacity), v && (e = S(M), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, Math.min(k, n)), c.stroke(), c.moveTo(t - z, Math.max(k, n)), c.lineTo(t - z, p), c.stroke(), W(c, x, Math.min(k, n), B, Math.max(k, n), e, 0, null, !1, !1, !1, !1))) : \"ohlc\" === u.type && (b.moveTo(t - z, r), b.lineTo(t - z, p), b.stroke(), b.beginPath(), b.moveTo(t, k), b.lineTo(x, k), b.stroke(), b.beginPath(), b.moveTo(t, n), b.lineTo(B, n), b.stroke(), v && (e = S(M), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, p), c.stroke(),\r\n                                    c.beginPath(), c.moveTo(t, k), c.lineTo(x, k), c.stroke(), c.beginPath(), c.moveTo(t, n), c.lineTo(B, n), c.stroke()));\r\n                                (q[l].indexLabel || u.indexLabel || q[l].indexLabelFormatter || u.indexLabelFormatter) && this._indexLabels.push({ chartType: u.type, dataPoint: q[l], dataSeries: u, point: { x: x + (B - x) / 2, y: a.axisY.reversed ? p : r }, direction: 1, bounds: { x1: x, y1: Math.min(r, p), x2: B, y2: Math.max(r, p) }, color: e });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas &&\r\n                    b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), c.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderBoxAndWhisker = function (a) {\r\n            var f = a.targetCanvasCtx ||\r\n                this.plotArea.ctx, b = v ? this._preRenderCtx : f, c = this._eventManager.ghostCtx;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = null, g = this.plotArea, h = 0, l, t, k, r, p, n, d, e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, w = a.axisX.dataInfo.minDiff;\r\n                isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));\r\n                w = this.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(w) /\r\n                    Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;\r\n                this.dataPointMaxWidth && e > h && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < e) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));\r\n                w < e && (w = e);\r\n                w > h && (w = h);\r\n                b.save();\r\n                v && c.save();\r\n                b.beginPath();\r\n                b.rect(g.x1, g.y1, g.width, g.height);\r\n                b.clip();\r\n                v && (c.beginPath(), c.rect(g.x1, g.y1, g.width, g.height), c.clip());\r\n                for (var m = !1, m = !!a.axisY.reversed, s = 0; s < a.dataSeriesIndexes.length; s++) {\r\n                    var u = a.dataSeriesIndexes[s], q = this.data[u], H = q.dataPoints;\r\n                    if (0 < H.length)\r\n                        for (var x = 5 < w && q.bevelEnabled ? !0 : !1, h = 0; h < H.length; h++)\r\n                            if (H[h].getTime ? d = H[h].x.getTime() : d = H[h].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(H[h].y) && H[h].y.length && \"number\" === typeof H[h].y[0] && \"number\" === typeof H[h].y[1] && \"number\" === typeof H[h].y[2] && \"number\" === typeof H[h].y[3] && \"number\" === typeof H[h].y[4] && 5 === H[h].y.length) {\r\n                                l = a.axisX.convertValueToPixel(d);\r\n                                t = a.axisY.convertValueToPixel(H[h].y[0]);\r\n                                k = a.axisY.convertValueToPixel(H[h].y[1]);\r\n                                r = a.axisY.convertValueToPixel(H[h].y[2]);\r\n                                p = a.axisY.convertValueToPixel(H[h].y[3]);\r\n                                n = a.axisY.convertValueToPixel(H[h].y[4]);\r\n                                var B = l - w / 2 << 0, A = l + w / 2 << 0, e = H[h].color ? H[h].color : q._colorSet[0], z = Math.round(Math.max(1, 0.15 * w)), M = 0 === z % 2 ? 0 : 0.5, K = H[h].whiskerColor ? H[h].whiskerColor : H[h].color ? q.whiskerColor ? q.whiskerColor : H[h].color : q.whiskerColor ? q.whiskerColor : e, J = \"number\" === typeof H[h].whiskerThickness ? H[h].whiskerThickness : \"number\" === typeof q.options.whiskerThickness ? q.whiskerThickness : z, ca = H[h].whiskerDashType ?\r\n                                    H[h].whiskerDashType : q.whiskerDashType, da = y(H[h].whiskerLength) ? y(q.options.whiskerLength) ? w : q.whiskerLength : H[h].whiskerLength, da = \"number\" === typeof da ? 0 >= da ? 0 : da >= w ? w : da : \"string\" === typeof da ? parseInt(da) * w / 100 > w ? w : parseInt(da) * w / 100 : w, aa = 1 === Math.round(J) % 2 ? 0.5 : 0, xa = H[h].stemColor ? H[h].stemColor : H[h].color ? q.stemColor ? q.stemColor : H[h].color : q.stemColor ? q.stemColor : e, na = \"number\" === typeof H[h].stemThickness ? H[h].stemThickness : \"number\" === typeof q.options.stemThickness ? q.stemThickness : z, E = 1 === Math.round(na) %\r\n                                    2 ? 0.5 : 0, C = H[h].stemDashType ? H[h].stemDashType : q.stemDashType, Q = H[h].lineColor ? H[h].lineColor : H[h].color ? q.lineColor ? q.lineColor : H[h].color : q.lineColor ? q.lineColor : e, P = \"number\" === typeof H[h].lineThickness ? H[h].lineThickness : \"number\" === typeof q.options.lineThickness ? q.lineThickness : z, R = H[h].lineDashType ? H[h].lineDashType : q.lineDashType, L = 1 === Math.round(P) % 2 ? 0.5 : 0, O = q.upperBoxColor, V = q.lowerBoxColor, sa = y(q.options.fillOpacity) ? 1 : q.fillOpacity, N = q.dataPointIds[h];\r\n                                this._eventManager.objectMap[N] = { id: N,\r\n                                    objectType: \"dataPoint\", dataSeriesIndex: u, dataPointIndex: h, x1: B, y1: t, x2: A, y2: k, x3: l, y3: r, x4: l, y4: p, y5: n, borderThickness: z, color: e, stemThickness: na, stemColor: xa, whiskerThickness: J, whiskerLength: da, whiskerColor: K, lineThickness: P, lineColor: Q };\r\n                                b.save();\r\n                                0 < na && (b.beginPath(), b.strokeStyle = xa, b.lineWidth = na, b.setLineDash && b.setLineDash(G(C, na)), b.moveTo(l - E, k), b.lineTo(l - E, t), b.stroke(), b.moveTo(l - E, p), b.lineTo(l - E, r), b.stroke());\r\n                                b.restore();\r\n                                c.lineWidth = Math.max(z, 4);\r\n                                b.beginPath();\r\n                                W(b, B, Math.min(n, k), A, Math.max(k, n), V, 0, e, m ? x : !1, m ? !1 : x, !1, !1, sa);\r\n                                b.beginPath();\r\n                                W(b, B, Math.min(r, n), A, Math.max(n, r), O, 0, e, m ? !1 : x, m ? x : !1, !1, !1, sa);\r\n                                b.beginPath();\r\n                                b.lineWidth = z;\r\n                                b.strokeStyle = e;\r\n                                b.rect(B - M, Math.min(k, r) - M, A - B + 2 * M, Math.max(k, r) - Math.min(k, r) + 2 * M);\r\n                                b.stroke();\r\n                                b.save();\r\n                                0 < P && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(G(R, P)), b.strokeStyle = Q, b.lineWidth = P, b.moveTo(B, n - L), b.lineTo(A, n - L), b.stroke());\r\n                                b.restore();\r\n                                b.save();\r\n                                0 < J && (b.beginPath(), b.setLineDash && b.setLineDash(G(ca, J)), b.strokeStyle = K, b.lineWidth = J,\r\n                                    b.moveTo(l - da / 2 << 0, p - aa), b.lineTo(l + da / 2 << 0, p - aa), b.stroke(), b.moveTo(l - da / 2 << 0, t + aa), b.lineTo(l + da / 2 << 0, t + aa), b.stroke());\r\n                                b.restore();\r\n                                v && (e = S(N), c.strokeStyle = e, c.lineWidth = na, 0 < na && (c.moveTo(l - M - E, k), c.lineTo(l - M - E, Math.max(t, p)), c.stroke(), c.moveTo(l - M - E, Math.min(t, p)), c.lineTo(l - M - E, r), c.stroke()), W(c, B, Math.max(k, r), A, Math.min(k, r), e, 0, null, !1, !1, !1, !1), 0 < J && (c.beginPath(), c.lineWidth = J, c.moveTo(l + da / 2, p - aa), c.lineTo(l - da / 2, p - aa), c.stroke(), c.moveTo(l + da / 2, t + aa), c.lineTo(l - da / 2, t + aa), c.stroke()));\r\n                                (H[h].indexLabel || q.indexLabel || H[h].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({ chartType: q.type, dataPoint: H[h], dataSeries: q, point: { x: B + (A - B) / 2, y: a.axisY.reversed ? t : p }, direction: 1, bounds: { x1: B, y1: Math.min(t, p), x2: A, y2: Math.max(t, p) }, color: e });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), c.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderRangeColumn = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = 0, h, l, t, g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;\r\n                var k = a.axisX.dataInfo.minDiff;\r\n                isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range));\r\n                k = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;\r\n                this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ?\r\n                    this.dataPointWidth : Infinity, h));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < g) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));\r\n                k < g && (k = g);\r\n                k > h && (k = h);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (var r = 0; r < a.dataSeriesIndexes.length; r++) {\r\n                    var p = a.dataSeriesIndexes[r], n = this.data[p], d = n.dataPoints;\r\n                    if (0 < d.length)\r\n                        for (var w = 5 < k && n.bevelEnabled ? !0 : !1, g = 0; g < d.length; g++)\r\n                            if (d[g].getTime ? t = d[g].x.getTime() : t = d[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && !y(d[g].y) && d[g].y.length && \"number\" === typeof d[g].y[0] && \"number\" === typeof d[g].y[1]) {\r\n                                c = a.axisX.convertValueToPixel(t);\r\n                                h = a.axisY.convertValueToPixel(d[g].y[0]);\r\n                                l = a.axisY.convertValueToPixel(d[g].y[1]);\r\n                                var m = a.axisX.reversed ? c + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + r) * k << 0 : c - a.plotType.totalDataSeries *\r\n                                    k / 2 + (a.previousDataSeriesCount + r) * k << 0, q = a.axisX.reversed ? m - k << 0 : m + k << 0, c = d[g].color ? d[g].color : n._colorSet[g % n._colorSet.length];\r\n                                if (h > l) {\r\n                                    var u = h;\r\n                                    h = l;\r\n                                    l = u;\r\n                                }\r\n                                u = n.dataPointIds[g];\r\n                                this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: p, dataPointIndex: g, x1: m, y1: h, x2: q, y2: l };\r\n                                W(b, m, h, q, l, c, 0, c, w, w, !1, !1, n.fillOpacity);\r\n                                c = S(u);\r\n                                v && W(this._eventManager.ghostCtx, m, h, q, l, c, 0, null, !1, !1, !1, !1);\r\n                                if (d[g].indexLabel || n.indexLabel || d[g].indexLabelFormatter || n.indexLabelFormatter)\r\n                                    this._indexLabels.push({ chartType: \"rangeColumn\",\r\n                                        dataPoint: d[g], dataSeries: n, indexKeyword: 0, point: { x: m + (q - m) / 2, y: d[g].y[1] >= d[g].y[0] ? l : h }, direction: d[g].y[1] >= d[g].y[0] ? -1 : 1, bounds: { x1: m, y1: Math.min(h, l), x2: q, y2: Math.max(h, l) }, color: c }), this._indexLabels.push({ chartType: \"rangeColumn\", dataPoint: d[g], dataSeries: n, indexKeyword: 1, point: { x: m + (q - m) / 2, y: d[g].y[1] >= d[g].y[0] ? h : l }, direction: d[g].y[1] >= d[g].y[0] ? 1 : -1, bounds: { x1: m, y1: Math.min(h, l), x2: q, y2: Math.max(h, l) }, color: c });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =\r\n                    \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderError =\r\n            function (a) {\r\n                var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f, c = a.axisY._position ? \"left\" === a.axisY._position || \"right\" === a.axisY._position ? !1 : !0 : !1;\r\n                if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                    var e = null, g = !1, h = this.plotArea, l = 0, t, k, r, p, n, d, w, m = a.axisX.dataInfo.minDiff;\r\n                    isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));\r\n                    b.save();\r\n                    v && this._eventManager.ghostCtx.save();\r\n                    b.beginPath();\r\n                    b.rect(h.x1, h.y1, h.width, h.height);\r\n                    b.clip();\r\n                    v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());\r\n                    for (var q = 0, u = 0; u < this.data.length; u++)\r\n                        !this.data[u].type.match(/(bar|column)/ig) || !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) && q || q++;\r\n                    for (var s = 0; s < a.dataSeriesIndexes.length; s++) {\r\n                        var H = a.dataSeriesIndexes[s], x = this.data[H], B = x.dataPoints, A = y(x._linkedSeries) ? !1 : x._linkedSeries.type.match(/(bar|column)/ig) && x._linkedSeries.visible ? !0 : !1, C = 0;\r\n                        if (A)\r\n                            for (e = x._linkedSeries.id, u = 0; u < e; u++)\r\n                                !this.data[u].type.match(/(bar|column)/ig) ||\r\n                                    !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) && C || (this.data[u].type.match(/(range)/ig) && (g = !0), C++);\r\n                        e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                        l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? q : 1))) << 0 : 0.3 * this.width;\r\n                        g && (l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 *\r\n                            (this.plotArea.height / (A ? q : 1))) << 0 : 0.03 * this.width);\r\n                        u = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((c ? h.height : h.width) * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / (A ? q : 1)) << 0;\r\n                        this.dataPointMaxWidth && e > l && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, l));\r\n                        !this.dataPointMaxWidth && (this.dataPointMinWidth && l < e) && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));\r\n                        u < e && (u = e);\r\n                        u > l && (u = l);\r\n                        if (0 < B.length)\r\n                            for (var M = x._colorSet, l = 0; l < B.length; l++) {\r\n                                var e = x.lineColor = x.options.color ? x.options.color : M[0], K = { color: B[l].whiskerColor ? B[l].whiskerColor : B[l].color ? x.whiskerColor ? x.whiskerColor : B[l].color : x.whiskerColor ? x.whiskerColor : e, thickness: y(B[l].whiskerThickness) ? x.whiskerThickness : B[l].whiskerThickness, dashType: B[l].whiskerDashType ? B[l].whiskerDashType : x.whiskerDashType, length: y(B[l].whiskerLength) ? y(x.options.whiskerLength) ? u : x.options.whiskerLength : B[l].whiskerLength, trimLength: y(B[l].whiskerLength) ? y(x.options.whiskerLength) ?\r\n                                        50 : 0 : 0 };\r\n                                K.length = \"number\" === typeof K.length ? 0 >= K.length ? 0 : K.length >= u ? u : K.length : \"string\" === typeof K.length ? parseInt(K.length) * u / 100 > u ? u : parseInt(K.length) * u / 100 > u : u;\r\n                                K.thickness = \"number\" === typeof K.thickness ? 0 > K.thickness ? 0 : Math.round(K.thickness) : 2;\r\n                                var J = { color: B[l].stemColor ? B[l].stemColor : B[l].color ? x.stemColor ? x.stemColor : B[l].color : x.stemColor ? x.stemColor : e, thickness: B[l].stemThickness ? B[l].stemThickness : x.stemThickness, dashType: B[l].stemDashType ? B[l].stemDashType : x.stemDashType };\r\n                                J.thickness =\r\n                                    \"number\" === typeof J.thickness ? 0 > J.thickness ? 0 : Math.round(J.thickness) : 2;\r\n                                B[l].getTime ? w = B[l].x.getTime() : w = B[l].x;\r\n                                if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && !y(B[l].y) && B[l].y.length && \"number\" === typeof B[l].y[0] && \"number\" === typeof B[l].y[1]) {\r\n                                    var ca = a.axisX.convertValueToPixel(w);\r\n                                    c ? k = ca : t = ca;\r\n                                    ca = a.axisY.convertValueToPixel(B[l].y[0]);\r\n                                    c ? r = ca : n = ca;\r\n                                    ca = a.axisY.convertValueToPixel(B[l].y[1]);\r\n                                    c ? p = ca : d = ca;\r\n                                    c ? (n = a.axisX.reversed ? k + (A ? q : 1) * u / 2 - (A ? C - 1 : 0) * u << 0 : k - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) *\r\n                                        u << 0, d = a.axisX.reversed ? n - u << 0 : n + u << 0) : (r = a.axisX.reversed ? t + (A ? q : 1) * u / 2 - (A ? C - 1 : 0) * u << 0 : t - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) * u << 0, p = a.axisX.reversed ? r - u << 0 : r + u << 0);\r\n                                    !c && n > d && (ca = n, n = d, d = ca);\r\n                                    c && r > p && (ca = r, r = p, p = ca);\r\n                                    ca = x.dataPointIds[l];\r\n                                    this._eventManager.objectMap[ca] = { id: ca, objectType: \"dataPoint\", dataSeriesIndex: H, dataPointIndex: l, x1: Math.min(r, p), y1: Math.min(n, d), x2: Math.max(p, r), y2: Math.max(d, n), isXYSwapped: c, stemProperties: J, whiskerProperties: K };\r\n                                    z(b, Math.min(r, p), Math.min(n, d), Math.max(p, r), Math.max(d, n), e, K, J, c);\r\n                                    v && z(this._eventManager.ghostCtx, r, n, p, d, e, K, J, c);\r\n                                    if (B[l].indexLabel || x.indexLabel || B[l].indexLabelFormatter || x.indexLabelFormatter)\r\n                                        this._indexLabels.push({ chartType: \"error\", dataPoint: B[l], dataSeries: x, indexKeyword: 0, point: { x: c ? B[l].y[1] >= B[l].y[0] ? r : p : r + (p - r) / 2, y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? d : n }, direction: B[l].y[1] >= B[l].y[0] ? -1 : 1, bounds: { x1: c ? Math.min(r, p) : r, y1: c ? n : Math.min(n, d), x2: c ? Math.max(r, p) : p, y2: c ? d : Math.max(n, d) }, color: e, axisSwapped: c }), this._indexLabels.push({ chartType: \"error\",\r\n                                            dataPoint: B[l], dataSeries: x, indexKeyword: 1, point: { x: c ? B[l].y[1] >= B[l].y[0] ? p : r : r + (p - r) / 2, y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? n : d }, direction: B[l].y[1] >= B[l].y[0] ? 1 : -1, bounds: { x1: c ? Math.min(r, p) : r, y1: c ? n : Math.min(n, d), x2: c ? Math.max(r, p) : p, y2: c ? d : Math.max(n, d) }, color: e, axisSwapped: c });\r\n                                }\r\n                            }\r\n                    }\r\n                    v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());\r\n                    b.restore();\r\n                    return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n                }\r\n            };\r\n        s.prototype.renderRangeBar = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = null, e = this.plotArea, g = 0, h, l, t, k, g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;\r\n                var r = a.axisX.dataInfo.minDiff;\r\n                isFinite(r) || (r = 0.3 * Math.abs(a.axisX.range));\r\n                r = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(r) / Math.log(a.axisX.range) : Math.abs(r) / Math.abs(a.axisX.range)) /\r\n                    a.plotType.totalDataSeries) << 0;\r\n                this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < g) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));\r\n                r < g && (r = g);\r\n                r > h && (r = h);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(e.x1, e.y1, e.width, e.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());\r\n                for (var p = 0; p < a.dataSeriesIndexes.length; p++) {\r\n                    var n = a.dataSeriesIndexes[p], d = this.data[n], w = d.dataPoints;\r\n                    if (0 < w.length) {\r\n                        var m = 5 < r && d.bevelEnabled ? !0 : !1;\r\n                        b.strokeStyle = \"#4572A7 \";\r\n                        for (g = 0; g < w.length; g++)\r\n                            if (w[g].getTime ? k = w[g].x.getTime() : k = w[g].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !y(w[g].y) && w[g].y.length && \"number\" === typeof w[g].y[0] && \"number\" === typeof w[g].y[1]) {\r\n                                h = a.axisY.convertValueToPixel(w[g].y[0]);\r\n                                l = a.axisY.convertValueToPixel(w[g].y[1]);\r\n                                t = a.axisX.convertValueToPixel(k);\r\n                                t = a.axisX.reversed ? t + a.plotType.totalDataSeries * r / 2 - (a.previousDataSeriesCount + p) * r << 0 : t - a.plotType.totalDataSeries * r / 2 + (a.previousDataSeriesCount + p) * r << 0;\r\n                                var q = a.axisX.reversed ? t - r << 0 : t + r << 0;\r\n                                h > l && (c = h, h = l, l = c);\r\n                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];\r\n                                W(b, h, t, l, q, c, 0, null, m, !1, !1, !1, d.fillOpacity);\r\n                                c = d.dataPointIds[g];\r\n                                this._eventManager.objectMap[c] = { id: c, objectType: \"dataPoint\", dataSeriesIndex: n, dataPointIndex: g, x1: h, y1: t, x2: l, y2: q };\r\n                                c = S(c);\r\n                                v && W(this._eventManager.ghostCtx, h, t, l, q, c, 0, null, !1, !1, !1, !1);\r\n                                if (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter)\r\n                                    this._indexLabels.push({ chartType: \"rangeBar\", dataPoint: w[g], dataSeries: d, indexKeyword: 0, point: { x: w[g].y[1] >= w[g].y[0] ? h : l, y: t + (q - t) / 2 }, direction: w[g].y[1] >= w[g].y[0] ? -1 : 1, bounds: { x1: Math.min(h, l), y1: t, x2: Math.max(h, l), y2: q }, color: c }), this._indexLabels.push({ chartType: \"rangeBar\", dataPoint: w[g], dataSeries: d, indexKeyword: 1, point: { x: w[g].y[1] >= w[g].y[0] ? l : h, y: t + (q - t) / 2 }, direction: w[g].y[1] >= w[g].y[0] ?\r\n                                            1 : -1, bounds: { x1: Math.min(h, l), y1: t, x2: Math.max(h, l), y2: q }, color: c });\r\n                            }\r\n                    }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderRangeArea = function (a) {\r\n            function f() {\r\n                if (s) {\r\n                    var a = null;\r\n                    0 < r.lineThickness && c.stroke();\r\n                    for (var b = t.length - 1; 0 <= b; b--)\r\n                        a = t[b], c.lineTo(a.x, a.y), e.lineTo(a.x, a.y);\r\n                    c.closePath();\r\n                    c.globalAlpha = r.fillOpacity;\r\n                    c.fill();\r\n                    c.globalAlpha = 1;\r\n                    e.fill();\r\n                    if (0 < r.lineThickness) {\r\n                        c.beginPath();\r\n                        c.moveTo(a.x, a.y);\r\n                        for (b = 0; b < t.length; b++)\r\n                            a = t[b], c.lineTo(a.x, a.y);\r\n                        c.stroke();\r\n                    }\r\n                    c.beginPath();\r\n                    c.moveTo(w, m);\r\n                    e.beginPath();\r\n                    e.moveTo(w, m);\r\n                    s = { x: w, y: m };\r\n                    t = [];\r\n                    t.push({ x: w, y: q });\r\n                }\r\n            }\r\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = this._eventManager.ghostCtx, g = [], h = this.plotArea;\r\n                c.save();\r\n                v && e.save();\r\n                c.beginPath();\r\n                c.rect(h.x1, h.y1, h.width, h.height);\r\n                c.clip();\r\n                v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());\r\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                    var t = [], k = a.dataSeriesIndexes[l], r = this.data[k], p = r.dataPoints, g = r.id;\r\n                    this._eventManager.objectMap[g] =\r\n                        { objectType: \"dataSeries\", dataSeriesIndex: k };\r\n                    g = S(g);\r\n                    e.fillStyle = g;\r\n                    var g = [], n = !0, d = 0, w, m, q, u, s = null;\r\n                    if (0 < p.length) {\r\n                        var y = r._colorSet[d % r._colorSet.length], x = r.lineColor = r.options.lineColor || y, B = x;\r\n                        c.fillStyle = y;\r\n                        c.strokeStyle = x;\r\n                        c.lineWidth = r.lineThickness;\r\n                        var A = \"solid\";\r\n                        if (c.setLineDash) {\r\n                            var z = G(r.nullDataLineDashType, r.lineThickness), A = r.lineDashType, C = G(A, r.lineThickness);\r\n                            c.setLineDash(C);\r\n                        }\r\n                        for (var K = !0; d < p.length; d++)\r\n                            if (u = p[d].x.getTime ? p[d].x.getTime() : p[d].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax &&\r\n                                (!r.connectNullData || !K)))\r\n                                if (null !== p[d].y && p[d].y.length && \"number\" === typeof p[d].y[0] && \"number\" === typeof p[d].y[1]) {\r\n                                    w = a.axisX.convertValueToPixel(u);\r\n                                    m = a.axisY.convertValueToPixel(p[d].y[0]);\r\n                                    q = a.axisY.convertValueToPixel(p[d].y[1]);\r\n                                    n || K ? (r.connectNullData && !n ? (c.setLineDash && (r.options.nullDataLineDashType || A === r.lineDashType && r.lineDashType !== r.nullDataLineDashType) && (t[t.length - 1].newLineDashArray = C, A = r.nullDataLineDashType, c.setLineDash(z)), c.lineTo(w, m), v && e.lineTo(w, m), t.push({ x: w, y: q })) : (c.beginPath(),\r\n                                        c.moveTo(w, m), s = { x: w, y: m }, t = [], t.push({ x: w, y: q }), v && (e.beginPath(), e.moveTo(w, m))), K = n = !1) : (c.lineTo(w, m), t.push({ x: w, y: q }), v && e.lineTo(w, m), 0 == d % 250 && f());\r\n                                    u = r.dataPointIds[d];\r\n                                    this._eventManager.objectMap[u] = { id: u, objectType: \"dataPoint\", dataSeriesIndex: k, dataPointIndex: d, x1: w, y1: m, y2: q };\r\n                                    d < p.length - 1 && (B !== (p[d].lineColor || x) || A !== (p[d].lineDashType || r.lineDashType)) && (f(), B = p[d].lineColor || x, t[t.length - 1].newStrokeStyle = B, c.strokeStyle = B, c.setLineDash && (p[d].lineDashType ? (A = p[d].lineDashType, t[t.length -\r\n                                        1].newLineDashArray = G(A, r.lineThickness), c.setLineDash(t[t.length - 1].newLineDashArray)) : (A = r.lineDashType, t[t.length - 1].newLineDashArray = C, c.setLineDash(C))));\r\n                                    if (0 !== p[d].markerSize && (0 < p[d].markerSize || 0 < r.markerSize)) {\r\n                                        var J = r.getMarkerProperties(d, w, q, c);\r\n                                        g.push(J);\r\n                                        var ca = S(u);\r\n                                        v && g.push({ x: w, y: q, ctx: e, type: J.type, size: J.size, color: ca, borderColor: ca, borderThickness: J.borderThickness });\r\n                                        J = r.getMarkerProperties(d, w, m, c);\r\n                                        g.push(J);\r\n                                        ca = S(u);\r\n                                        v && g.push({ x: w, y: m, ctx: e, type: J.type, size: J.size, color: ca, borderColor: ca,\r\n                                            borderThickness: J.borderThickness });\r\n                                    }\r\n                                    if (p[d].indexLabel || r.indexLabel || p[d].indexLabelFormatter || r.indexLabelFormatter)\r\n                                        this._indexLabels.push({ chartType: \"rangeArea\", dataPoint: p[d], dataSeries: r, indexKeyword: 0, point: { x: w, y: m }, direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? -1 : 1, color: y }), this._indexLabels.push({ chartType: \"rangeArea\", dataPoint: p[d], dataSeries: r, indexKeyword: 1, point: { x: w, y: q }, direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? 1 : -1, color: y });\r\n                                }\r\n                                else\r\n                                    K || n || f(), K = !0;\r\n                        f();\r\n                        ia.drawMarkers(g);\r\n                    }\r\n                }\r\n                v &&\r\n                    (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());\r\n                c.restore();\r\n                return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation,\r\n                    easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderRangeSplineArea = function (a) {\r\n            function f(a, b) {\r\n                var d = x(m, 2);\r\n                if (0 < d.length) {\r\n                    if (0 < k.lineThickness) {\r\n                        c.strokeStyle = b;\r\n                        c.setLineDash && c.setLineDash(a);\r\n                        c.beginPath();\r\n                        c.moveTo(d[0].x, d[0].y);\r\n                        for (var f = 0; f < d.length - 3; f += 3) {\r\n                            if (d[f].newStrokeStyle || d[f].newLineDashArray)\r\n                                c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), d[f].newStrokeStyle && (c.strokeStyle = d[f].newStrokeStyle), d[f].newLineDashArray && c.setLineDash(d[f].newLineDashArray);\r\n                            c.bezierCurveTo(d[f +\r\n                                1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\r\n                        }\r\n                        c.stroke();\r\n                    }\r\n                    c.beginPath();\r\n                    c.moveTo(d[0].x, d[0].y);\r\n                    v && (e.beginPath(), e.moveTo(d[0].x, d[0].y));\r\n                    for (f = 0; f < d.length - 3; f += 3)\r\n                        c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y), v && e.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\r\n                    d = x(q, 2);\r\n                    c.lineTo(q[q.length - 1].x, q[q.length - 1].y);\r\n                    for (f = d.length - 1; 2 < f; f -= 3)\r\n                        c.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y), v && e.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f -\r\n                            2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y);\r\n                    c.closePath();\r\n                    c.globalAlpha = k.fillOpacity;\r\n                    c.fill();\r\n                    v && (e.closePath(), e.fill());\r\n                    c.globalAlpha = 1;\r\n                    if (0 < k.lineThickness) {\r\n                        c.strokeStyle = b;\r\n                        c.setLineDash && c.setLineDash(a);\r\n                        c.beginPath();\r\n                        c.moveTo(d[0].x, d[0].y);\r\n                        for (var g = f = 0; f < d.length - 3; f += 3, g++) {\r\n                            if (m[g].newStrokeStyle || m[g].newLineDashArray)\r\n                                c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), m[g].newStrokeStyle && (c.strokeStyle = m[g].newStrokeStyle), m[g].newLineDashArray && c.setLineDash(m[g].newLineDashArray);\r\n                            c.bezierCurveTo(d[f +\r\n                                1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);\r\n                        }\r\n                        c.stroke();\r\n                    }\r\n                    c.beginPath();\r\n                }\r\n            }\r\n            var b = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : b;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var e = this._eventManager.ghostCtx, g = [], h = this.plotArea;\r\n                c.save();\r\n                v && e.save();\r\n                c.beginPath();\r\n                c.rect(h.x1, h.y1, h.width, h.height);\r\n                c.clip();\r\n                v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());\r\n                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {\r\n                    var t = a.dataSeriesIndexes[l], k = this.data[t], r = k.dataPoints, g = k.id;\r\n                    this._eventManager.objectMap[g] =\r\n                        { objectType: \"dataSeries\", dataSeriesIndex: t };\r\n                    g = S(g);\r\n                    e.fillStyle = g;\r\n                    var g = [], p = 0, n, d, w, m = [], q = [];\r\n                    if (0 < r.length) {\r\n                        var u = k._colorSet[p % k._colorSet.length], s = k.lineColor = k.options.lineColor || u, y = s;\r\n                        c.fillStyle = u;\r\n                        c.lineWidth = k.lineThickness;\r\n                        var z = \"solid\", B;\r\n                        if (c.setLineDash) {\r\n                            var A = G(k.nullDataLineDashType, k.lineThickness), z = k.lineDashType;\r\n                            B = G(z, k.lineThickness);\r\n                        }\r\n                        for (d = !1; p < r.length; p++)\r\n                            if (n = r[p].x.getTime ? r[p].x.getTime() : r[p].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!k.connectNullData ||\r\n                                !d)))\r\n                                if (null !== r[p].y && r[p].y.length && \"number\" === typeof r[p].y[0] && \"number\" === typeof r[p].y[1]) {\r\n                                    n = a.axisX.convertValueToPixel(n);\r\n                                    d = a.axisY.convertValueToPixel(r[p].y[0]);\r\n                                    w = a.axisY.convertValueToPixel(r[p].y[1]);\r\n                                    var C = k.dataPointIds[p];\r\n                                    this._eventManager.objectMap[C] = { id: C, objectType: \"dataPoint\", dataSeriesIndex: t, dataPointIndex: p, x1: n, y1: d, y2: w };\r\n                                    m[m.length] = { x: n, y: d };\r\n                                    q[q.length] = { x: n, y: w };\r\n                                    p < r.length - 1 && (y !== (r[p].lineColor || s) || z !== (r[p].lineDashType || k.lineDashType)) && (y = r[p].lineColor || s, m[m.length -\r\n                                        1].newStrokeStyle = y, c.setLineDash && (r[p].lineDashType ? (z = r[p].lineDashType, m[m.length - 1].newLineDashArray = G(z, k.lineThickness)) : (z = k.lineDashType, m[m.length - 1].newLineDashArray = B)));\r\n                                    if (0 !== r[p].markerSize && (0 < r[p].markerSize || 0 < k.markerSize)) {\r\n                                        var M = k.getMarkerProperties(p, n, d, c);\r\n                                        g.push(M);\r\n                                        var K = S(C);\r\n                                        v && g.push({ x: n, y: d, ctx: e, type: M.type, size: M.size, color: K, borderColor: K, borderThickness: M.borderThickness });\r\n                                        M = k.getMarkerProperties(p, n, w, c);\r\n                                        g.push(M);\r\n                                        K = S(C);\r\n                                        v && g.push({ x: n, y: w, ctx: e, type: M.type, size: M.size,\r\n                                            color: K, borderColor: K, borderThickness: M.borderThickness });\r\n                                    }\r\n                                    if (r[p].indexLabel || k.indexLabel || r[p].indexLabelFormatter || k.indexLabelFormatter)\r\n                                        this._indexLabels.push({ chartType: \"rangeSplineArea\", dataPoint: r[p], dataSeries: k, indexKeyword: 0, point: { x: n, y: d }, direction: r[p].y[0] <= r[p].y[1] ? -1 : 1, color: u }), this._indexLabels.push({ chartType: \"rangeSplineArea\", dataPoint: r[p], dataSeries: k, indexKeyword: 1, point: { x: n, y: w }, direction: r[p].y[0] <= r[p].y[1] ? 1 : -1, color: u });\r\n                                    d = !1;\r\n                                }\r\n                                else\r\n                                    0 < p && !d && (k.connectNullData ? c.setLineDash &&\r\n                                        (0 < m.length && (k.options.nullDataLineDashType || !r[p - 1].lineDashType)) && (m[m.length - 1].newLineDashArray = A, z = k.nullDataLineDashType) : (f(B, s), m = [], q = [])), d = !0;\r\n                        f(B, s);\r\n                        ia.drawMarkers(g);\r\n                    }\r\n                }\r\n                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());\r\n                c.restore();\r\n                return { source: b, dest: this.plotArea.ctx, animationCallback: I.xClipAnimation, easingFunction: I.easing.linear, animationBase: 0 };\r\n            }\r\n        };\r\n        s.prototype.renderWaterfall = function (a) {\r\n            var f = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : f;\r\n            if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                var c = this._eventManager.ghostCtx, e = null, g = this.plotArea, h = 0, l, t, k, r, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ?\r\n                    a.axisY.viewportMinimum : 0), h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;\r\n                t = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;\r\n                var n = a.axisX.dataInfo.minDiff;\r\n                isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));\r\n                n = this.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) /\r\n                    a.plotType.totalDataSeries) << 0;\r\n                this.dataPointMaxWidth && h > t && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, t));\r\n                !this.dataPointMaxWidth && (this.dataPointMinWidth && t < h) && (t = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, h));\r\n                n < h && (n = h);\r\n                n > t && (n = t);\r\n                b.save();\r\n                v && this._eventManager.ghostCtx.save();\r\n                b.beginPath();\r\n                b.rect(g.x1, g.y1, g.width, g.height);\r\n                b.clip();\r\n                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip());\r\n                for (var d = 0; d < a.dataSeriesIndexes.length; d++) {\r\n                    var w = a.dataSeriesIndexes[d], m = this.data[w], q = m.dataPoints, e = m._colorSet[0];\r\n                    m.risingColor = m.options.risingColor ? m.options.risingColor : e;\r\n                    m.fallingColor = m.options.fallingColor ? m.options.fallingColor : \"#e40a0a\";\r\n                    var u = \"number\" === typeof m.options.lineThickness ? Math.round(m.lineThickness) : 1, s = 1 === Math.round(u) % 2 ? -0.5 : 0;\r\n                    if (0 < q.length)\r\n                        for (var y = 5 < n && m.bevelEnabled ? !0 : !1, x = !1, B = null, A = null, h = 0; h < q.length; h++)\r\n                            if (q[h].getTime ? r = q[h].x.getTime() : r = q[h].x, \"number\" !==\r\n                                typeof q[h].y) {\r\n                                if (0 < h && !x && m.connectNullData)\r\n                                    var z = m.options.nullDataLineDashType || !q[h - 1].lineDashType ? m.nullDataLineDashType : q[h - 1].lineDashType;\r\n                                x = !0;\r\n                            }\r\n                            else {\r\n                                l = a.axisX.convertValueToPixel(r);\r\n                                t = 0 === m.dataPointEOs[h].cumulativeSum ? p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSum);\r\n                                k = 0 === m.dataPointEOs[h].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSumYStartValue);\r\n                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + d) * n << 0 :\r\n                                    l - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + d) * n << 0;\r\n                                var C = a.axisX.reversed ? l - n << 0 : l + n << 0;\r\n                                t > k && (e = t, t = k, k = e);\r\n                                a.axisY.reversed && (e = t, t = k, k = e);\r\n                                e = m.dataPointIds[h];\r\n                                this._eventManager.objectMap[e] = { id: e, objectType: \"dataPoint\", dataSeriesIndex: w, dataPointIndex: h, x1: l, y1: t, x2: C, y2: k };\r\n                                var K = q[h].color ? q[h].color : 0 < q[h].y ? m.risingColor : m.fallingColor;\r\n                                W(b, l, t, C, k, K, 0, K, y, y, !1, !1, m.fillOpacity);\r\n                                e = S(e);\r\n                                v && W(this._eventManager.ghostCtx, l, t, C, k, e, 0, null, !1, !1, !1, !1);\r\n                                var J, K = l;\r\n                                J = \"undefined\" !== typeof q[h].isIntermediateSum &&\r\n                                    !0 === q[h].isIntermediateSum || \"undefined\" !== typeof q[h].isCumulativeSum && !0 === q[h].isCumulativeSum ? 0 < q[h].y ? t : k : 0 < q[h].y ? k : t;\r\n                                0 < h && B && (!x || m.connectNullData) && (x && b.setLineDash && b.setLineDash(G(z, u)), b.beginPath(), b.moveTo(B, A - s), b.lineTo(K, J - s), 0 < u && b.stroke(), v && (c.beginPath(), c.moveTo(B, A - s), c.lineTo(K, J - s), 0 < u && c.stroke()));\r\n                                x = !1;\r\n                                B = C;\r\n                                A = 0 < q[h].y ? t : k;\r\n                                K = q[h].lineDashType ? q[h].lineDashType : m.options.lineDashType ? m.options.lineDashType : \"shortDash\";\r\n                                b.strokeStyle = q[h].lineColor ? q[h].lineColor : m.options.lineColor ?\r\n                                    m.options.lineColor : \"#9e9e9e\";\r\n                                b.lineWidth = u;\r\n                                b.setLineDash && (K = G(K, u), b.setLineDash(K));\r\n                                (q[h].indexLabel || m.indexLabel || q[h].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: \"waterfall\", dataPoint: q[h], dataSeries: m, point: { x: l + (C - l) / 2, y: 0 <= q[h].y ? t : k }, direction: 0 > q[h].y === a.axisY.reversed ? 1 : -1, bounds: { x1: l, y1: Math.min(t, k), x2: C, y2: Math.max(t, k) }, color: e });\r\n                            }\r\n                }\r\n                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = \"source-atop\", a.axisX.maskCanvas &&\r\n                    b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore());\r\n                b.restore();\r\n                return { source: f, dest: this.plotArea.ctx, animationCallback: I.fadeInAnimation, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n            }\r\n        };\r\n        var qa = function (a, f, b, c, e, g, h, l, t) {\r\n            if (!(0 >\r\n                b)) {\r\n                \"undefined\" === typeof l && (l = 1);\r\n                if (!v) {\r\n                    var k = Number((h % (2 * Math.PI)).toFixed(8));\r\n                    Number((g % (2 * Math.PI)).toFixed(8)) === k && (h -= 1E-4);\r\n                }\r\n                a.save();\r\n                a.globalAlpha = l;\r\n                \"pie\" === e ? (a.beginPath(), a.moveTo(f.x, f.y), a.arc(f.x, f.y, b, g, h, !1), a.fillStyle = c, a.strokeStyle = \"white\", a.lineWidth = 2, a.closePath(), a.fill()) : \"doughnut\" === e && (a.beginPath(), a.arc(f.x, f.y, b, g, h, !1), 0 <= t && a.arc(f.x, f.y, t * b, h, g, !0), a.closePath(), a.fillStyle = c, a.strokeStyle = \"white\", a.lineWidth = 2, a.fill());\r\n                a.globalAlpha = 1;\r\n                a.restore();\r\n            }\r\n        };\r\n        s.prototype.renderPie =\r\n            function (a) {\r\n                function f() {\r\n                    if (k && r) {\r\n                        for (var a = 0, b = 0, c = 0, e = 0, f = 0; f < r.length; f++) {\r\n                            var g = r[f], h = k.dataPointIds[f];\r\n                            d[f].id = h;\r\n                            d[f].objectType = \"dataPoint\";\r\n                            d[f].dataPointIndex = f;\r\n                            d[f].dataSeriesIndex = 0;\r\n                            var l = d[f], p = { percent: null, total: null }, m = null, p = t.getPercentAndTotal(k, g);\r\n                            if (k.indexLabelFormatter || g.indexLabelFormatter)\r\n                                m = { chart: t.options, dataSeries: k, dataPoint: g, total: p.total, percent: p.percent };\r\n                            p = g.indexLabelFormatter ? g.indexLabelFormatter(m) : g.indexLabel ? t.replaceKeywordsWithValue(g.indexLabel, g, k, f) : k.indexLabelFormatter ?\r\n                                k.indexLabelFormatter(m) : k.indexLabel ? t.replaceKeywordsWithValue(k.indexLabel, g, k, f) : g.label ? g.label : \"\";\r\n                            t._eventManager.objectMap[h] = l;\r\n                            l.center = { x: x.x, y: x.y };\r\n                            l.y = g.y;\r\n                            l.radius = A;\r\n                            l.percentInnerRadius = M;\r\n                            l.indexLabelText = p;\r\n                            l.indexLabelPlacement = k.indexLabelPlacement;\r\n                            l.indexLabelLineColor = g.indexLabelLineColor ? g.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : g.color ? g.color : k._colorSet[f % k._colorSet.length];\r\n                            l.indexLabelLineThickness = y(g.indexLabelLineThickness) ? k.indexLabelLineThickness :\r\n                                g.indexLabelLineThickness;\r\n                            l.indexLabelLineDashType = g.indexLabelLineDashType ? g.indexLabelLineDashType : k.indexLabelLineDashType;\r\n                            l.indexLabelFontColor = g.indexLabelFontColor ? g.indexLabelFontColor : k.indexLabelFontColor;\r\n                            l.indexLabelFontStyle = g.indexLabelFontStyle ? g.indexLabelFontStyle : k.indexLabelFontStyle;\r\n                            l.indexLabelFontWeight = g.indexLabelFontWeight ? g.indexLabelFontWeight : k.indexLabelFontWeight;\r\n                            l.indexLabelFontSize = y(g.indexLabelFontSize) ? k.indexLabelFontSize : g.indexLabelFontSize;\r\n                            l.indexLabelFontFamily =\r\n                                g.indexLabelFontFamily ? g.indexLabelFontFamily : k.indexLabelFontFamily;\r\n                            l.indexLabelBackgroundColor = g.indexLabelBackgroundColor ? g.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;\r\n                            l.indexLabelMaxWidth = g.indexLabelMaxWidth ? g.indexLabelMaxWidth : k.indexLabelMaxWidth ? k.indexLabelMaxWidth : 0.33 * n.width;\r\n                            l.indexLabelWrap = \"undefined\" !== typeof g.indexLabelWrap ? g.indexLabelWrap : k.indexLabelWrap;\r\n                            l.startAngle = 0 === f ? k.startAngle ? k.startAngle /\r\n                                180 * Math.PI : 0 : d[f - 1].endAngle;\r\n                            l.startAngle = (l.startAngle + 2 * Math.PI) % (2 * Math.PI);\r\n                            l.endAngle = l.startAngle + 2 * Math.PI / z * Math.abs(g.y);\r\n                            g = (l.endAngle + l.startAngle) / 2;\r\n                            g = (g + 2 * Math.PI) % (2 * Math.PI);\r\n                            l.midAngle = g;\r\n                            if (l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u) {\r\n                                if (0 === a || d[c].midAngle > l.midAngle)\r\n                                    c = f;\r\n                                a++;\r\n                            }\r\n                            else if (l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u) {\r\n                                if (0 === b || d[e].midAngle > l.midAngle)\r\n                                    e = f;\r\n                                b++;\r\n                            }\r\n                            l.hemisphere = g > Math.PI / 2 && g <= 3 * Math.PI / 2 ? \"left\" : \"right\";\r\n                            l.indexLabelTextBlock = new ka(t.plotArea.ctx, { fontSize: l.indexLabelFontSize,\r\n                                fontFamily: l.indexLabelFontFamily, fontColor: l.indexLabelFontColor, fontStyle: l.indexLabelFontStyle, fontWeight: l.indexLabelFontWeight, horizontalAlign: \"left\", backgroundColor: l.indexLabelBackgroundColor, maxWidth: l.indexLabelMaxWidth, maxHeight: l.indexLabelWrap ? 5 * l.indexLabelFontSize : 1.5 * l.indexLabelFontSize, text: l.indexLabelText, padding: 0, textBaseline: \"top\" });\r\n                            l.indexLabelTextBlock.measureText();\r\n                        }\r\n                        h = g = 0;\r\n                        p = !1;\r\n                        for (f = 0; f < r.length; f++)\r\n                            l = d[(c + f) % r.length], 1 < a && (l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u) &&\r\n                                (g <= a / 2 && !p ? (l.hemisphere = \"right\", g++) : (l.hemisphere = \"left\", p = !0));\r\n                        p = !1;\r\n                        for (f = 0; f < r.length; f++)\r\n                            l = d[(e + f) % r.length], 1 < b && (l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u) && (h <= b / 2 && !p ? (l.hemisphere = \"left\", h++) : (l.hemisphere = \"right\", p = !0));\r\n                    }\r\n                }\r\n                function b(a) {\r\n                    var b = t.plotArea.ctx;\r\n                    b.clearRect(n.x1, n.y1, n.width, n.height);\r\n                    b.fillStyle = t.backgroundColor;\r\n                    b.fillRect(n.x1, n.y1, n.width, n.height);\r\n                    for (b = 0; b < r.length; b++) {\r\n                        var c = d[b].startAngle, e = d[b].endAngle;\r\n                        if (e > c) {\r\n                            var f = 0.07 * A * Math.cos(d[b].midAngle), g = 0.07 * A *\r\n                                Math.sin(d[b].midAngle), h = !1;\r\n                            if (r[b].exploded) {\r\n                                if (1E-9 < Math.abs(d[b].center.x - (x.x + f)) || 1E-9 < Math.abs(d[b].center.y - (x.y + g)))\r\n                                    d[b].center.x = x.x + f * a, d[b].center.y = x.y + g * a, h = !0;\r\n                            }\r\n                            else if (0 < Math.abs(d[b].center.x - x.x) || 0 < Math.abs(d[b].center.y - x.y))\r\n                                d[b].center.x = x.x + f * (1 - a), d[b].center.y = x.y + g * (1 - a), h = !0;\r\n                            h && (f = {}, f.dataSeries = k, f.dataPoint = k.dataPoints[b], f.index = b, t.toolTip.highlightObjects([f]));\r\n                            qa(t.plotArea.ctx, d[b].center, d[b].radius, r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length], k.type, c, e, k.fillOpacity, d[b].percentInnerRadius);\r\n                        }\r\n                    }\r\n                    a = t.plotArea.ctx;\r\n                    a.save();\r\n                    a.fillStyle = \"black\";\r\n                    a.strokeStyle = \"grey\";\r\n                    a.textBaseline = \"middle\";\r\n                    a.lineJoin = \"round\";\r\n                    for (b = b = 0; b < r.length; b++)\r\n                        c = d[b], c.indexLabelText && (c.indexLabelTextBlock.y -= c.indexLabelTextBlock.height / 2, e = 0, e = \"left\" === c.hemisphere ? \"inside\" !== k.indexLabelPlacement ? -(c.indexLabelTextBlock.width + p) : -c.indexLabelTextBlock.width / 2 : \"inside\" !== k.indexLabelPlacement ? p : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += e, c.indexLabelTextBlock.render(!0),\r\n                            c.indexLabelTextBlock.x -= e, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, \"inside\" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (e = c.center.x + A * Math.cos(c.midAngle), f = c.center.y + A * Math.sin(c.midAngle), a.strokeStyle = c.indexLabelLineColor, a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(G(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(e, f), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + (\"left\" ===\r\n                            c.hemisphere ? -p : p), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = \"miter\");\r\n                    a.save();\r\n                }\r\n                function c(a, b) { var c = 0, c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2, d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2, e = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2, f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2; return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : c - f; }\r\n                function e(a) {\r\n                    for (var b = null, e = 1; e < r.length; e++)\r\n                        if (b = (a + e + d.length) % d.length, d[b].hemisphere !== d[a].hemisphere) {\r\n                            b =\r\n                                null;\r\n                            break;\r\n                        }\r\n                        else if (d[b].indexLabelText && b !== a && (0 > c(d[b], d[a]) || (\"right\" === d[a].hemisphere ? d[b].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y : d[b].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y)))\r\n                            break;\r\n                        else\r\n                            b = null;\r\n                    return b;\r\n                }\r\n                function g(a, b, f) {\r\n                    f = (f || 0) + 1;\r\n                    if (1E3 < f)\r\n                        return 0;\r\n                    b = b || 0;\r\n                    var k = 0, h = x.y - 1 * q, n = x.y + 1 * q;\r\n                    if (0 <= a && a < r.length) {\r\n                        var l = d[a];\r\n                        if (0 > b && l.indexLabelTextBlock.y < h || 0 < b && l.indexLabelTextBlock.y > n)\r\n                            return 0;\r\n                        var t = 0, p = 0, p = t = t = 0;\r\n                        0 > b ? l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 > h &&\r\n                            l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b < h && (b = -(h - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b))) : l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 < h && l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + b > n && (b = l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + b - n);\r\n                        b = l.indexLabelTextBlock.y + b;\r\n                        h = 0;\r\n                        h = \"right\" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2));\r\n                        p = x.x + A * Math.cos(l.midAngle);\r\n                        t = x.y + A * Math.sin(l.midAngle);\r\n                        t = Math.sqrt(Math.pow(h - p, 2) + Math.pow(b - t, 2));\r\n                        p = Math.acos(A / q);\r\n                        t = Math.acos((q * q + A * A - t * t) / (2 * A * q));\r\n                        b = t < p ? b - l.indexLabelTextBlock.y : 0;\r\n                        h = null;\r\n                        for (n = 1; n < r.length; n++)\r\n                            if (h = (a - n + d.length) % d.length, d[h].hemisphere !== d[a].hemisphere) {\r\n                                h = null;\r\n                                break;\r\n                            }\r\n                            else if (d[h].indexLabelText && d[h].hemisphere === d[a].hemisphere && h !== a && (0 > c(d[h], d[a]) || (\"right\" === d[a].hemisphere ? d[h].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y : d[h].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y)))\r\n                                break;\r\n                            else\r\n                                h = null;\r\n                        p = h;\r\n                        t = e(a);\r\n                        n = h = 0;\r\n                        0 >\r\n                            b ? (n = \"right\" === l.hemisphere ? p : t, k = b, null !== n && (p = -b, b = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - (d[n].indexLabelTextBlock.y + d[n].indexLabelTextBlock.height / 2), b - p < m && (h = -p, n = g(n, h, f + 1), +n.toFixed(v) > +h.toFixed(v) && (k = b > m ? -(b - m) : -(p - (n - h)))))) : 0 < b && (n = \"right\" === l.hemisphere ? t : p, k = b, null !== n && (p = b, b = d[n].indexLabelTextBlock.y - d[n].indexLabelTextBlock.height / 2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2), b - p < m && (h = p, n = g(n, h, f + 1), +n.toFixed(v) < +h.toFixed(v) && (k = b > m ? b - m : p - (h - n)))));\r\n                        k && (f = l.indexLabelTextBlock.y + k, b = 0, b = \"right\" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)), l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u ? (h = (a - 1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], \"left\" === l.hemisphere && \"right\" === h.hemisphere && b > h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x - 15 : \"right\" === l.hemisphere && (\"left\" === a.hemisphere && b < a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x + 15)) : l.midAngle > 3 * Math.PI / 2 - u &&\r\n                            l.midAngle < 3 * Math.PI / 2 + u && (h = (a - 1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], \"right\" === l.hemisphere && \"left\" === h.hemisphere && b < h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x + 15 : \"left\" === l.hemisphere && (\"right\" === a.hemisphere && b > a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x - 15)), l.indexLabelTextBlock.y = f, l.indexLabelTextBlock.x = b, l.indexLabelAngle = Math.atan2(l.indexLabelTextBlock.y - x.y, l.indexLabelTextBlock.x - x.x));\r\n                    }\r\n                    return k;\r\n                }\r\n                function h() {\r\n                    var a = t.plotArea.ctx;\r\n                    a.fillStyle = \"grey\";\r\n                    a.strokeStyle =\r\n                        \"grey\";\r\n                    a.font = \"16px Arial\";\r\n                    a.textBaseline = \"middle\";\r\n                    for (var b = a = 0, f = 0, h = !0, b = 0; 10 > b && (1 > b || 0 < f); b++) {\r\n                        if (k.radius || !k.radius && \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius && A - f <= C)\r\n                            h = !1;\r\n                        h && (A -= f);\r\n                        f = 0;\r\n                        if (\"inside\" !== k.indexLabelPlacement) {\r\n                            q = A * s;\r\n                            for (a = 0; a < r.length; a++) {\r\n                                var l = d[a];\r\n                                l.indexLabelTextBlock.x = x.x + q * Math.cos(l.midAngle);\r\n                                l.indexLabelTextBlock.y = x.y + q * Math.sin(l.midAngle);\r\n                                l.indexLabelAngle = l.midAngle;\r\n                                l.radius = A;\r\n                                l.percentInnerRadius = M;\r\n                            }\r\n                            for (var u, y, a = 0; a < r.length; a++) {\r\n                                var l = d[a], B = e(a);\r\n                                if (null !== B) {\r\n                                    u = d[a];\r\n                                    y = d[B];\r\n                                    var z = 0, z = c(u, y) - m;\r\n                                    if (0 > z) {\r\n                                        for (var G = y = 0, ta = 0; ta < r.length; ta++)\r\n                                            ta !== a && d[ta].hemisphere === l.hemisphere && (d[ta].indexLabelTextBlock.y < l.indexLabelTextBlock.y ? y++ : G++);\r\n                                        y = z / (y + G || 1) * G;\r\n                                        var G = -1 * (z - y), I = ta = 0;\r\n                                        \"right\" === l.hemisphere ? (ta = g(a, y), G = -1 * (z - ta), I = g(B, G), +I.toFixed(v) < +G.toFixed(v) && +ta.toFixed(v) <= +y.toFixed(v) && g(a, -(G - I))) : (ta = g(B, y), G = -1 * (z - ta), I = g(a, G), +I.toFixed(v) < +G.toFixed(v) && +ta.toFixed(v) <= +y.toFixed(v) && g(B, -(G - I)));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else\r\n                            for (a = 0; a < r.length; a++)\r\n                                l = d[a],\r\n                                    q = \"pie\" === k.type ? 0.7 * A : 0.8 * A, B = x.x + q * Math.cos(l.midAngle), y = x.y + q * Math.sin(l.midAngle), l.indexLabelTextBlock.x = B, l.indexLabelTextBlock.y = y;\r\n                        for (a = 0; a < r.length; a++)\r\n                            if (l = d[a], B = l.indexLabelTextBlock.measureText(), 0 !== B.height && 0 !== B.width)\r\n                                B = B = 0, \"right\" === l.hemisphere ? (B = n.x2 - (l.indexLabelTextBlock.x + l.indexLabelTextBlock.width + p), B *= -1) : B = n.x1 - (l.indexLabelTextBlock.x - l.indexLabelTextBlock.width - p), 0 < B && (!h && l.indexLabelText && (y = \"right\" === l.hemisphere ? n.x2 - l.indexLabelTextBlock.x : l.indexLabelTextBlock.x -\r\n                                    n.x1, 0.3 * l.indexLabelTextBlock.maxWidth > y ? l.indexLabelText = \"\" : l.indexLabelTextBlock.maxWidth = 0.85 * y, 0.3 * l.indexLabelTextBlock.maxWidth < y && (l.indexLabelTextBlock.x -= \"right\" === l.hemisphere ? 2 : -2)), Math.abs(l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - x.y) < A || Math.abs(l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 - x.y) < A) && (B /= Math.abs(Math.cos(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)), B = B = 0, 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? (B = n.y2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height /\r\n                                    2 + 5), B *= -1) : B = n.y1 - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - 5), 0 < B && (!h && l.indexLabelText && (y = 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a, B * y) && g(a, 2 * y)), Math.abs(l.indexLabelTextBlock.x - x.x) < A && (B /= Math.abs(Math.sin(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)));\r\n                        var L = function (a, b, c) {\r\n                            for (var e = [], f = 0; e.push(d[b]), b !== c; b = (b + 1 + r.length) % r.length)\r\n                                ;\r\n                            e.sort(function (a, b) { return a.y - b.y; });\r\n                            for (b = 0; b < e.length; b++)\r\n                                if (c = e[b], f < 0.7 * a)\r\n                                    f += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text =\r\n                                        \"\", c.indexLabelText = \"\", c.indexLabelTextBlock.measureText();\r\n                                else\r\n                                    break;\r\n                        };\r\n                        (function () {\r\n                            for (var a = -1, b = -1, f = 0, g = !1, h = 0; h < r.length; h++)\r\n                                if (g = !1, u = d[h], u.indexLabelText) {\r\n                                    var k = e(h);\r\n                                    if (null !== k) {\r\n                                        var l = d[k];\r\n                                        z = 0;\r\n                                        z = c(u, l);\r\n                                        var n;\r\n                                        if (n = 0 > z) {\r\n                                            n = u.indexLabelTextBlock.x;\r\n                                            var t = u.indexLabelTextBlock.y - u.indexLabelTextBlock.height / 2, m = u.indexLabelTextBlock.y + u.indexLabelTextBlock.height / 2, w = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2, q = l.indexLabelTextBlock.x + l.indexLabelTextBlock.width, s = l.indexLabelTextBlock.y +\r\n                                                l.indexLabelTextBlock.height / 2;\r\n                                            n = u.indexLabelTextBlock.x + u.indexLabelTextBlock.width < l.indexLabelTextBlock.x - p || n > q + p || t > s + p || m < w - p ? !1 : !0;\r\n                                        }\r\n                                        n ? (0 > a && (a = h), k !== a && (b = k, f += -z), 0 === h % Math.max(r.length / 10, 3) && (g = !0)) : g = !0;\r\n                                        g && (0 < f && 0 <= a && 0 <= b) && (L(f, a, b), b = a = -1, f = 0);\r\n                                    }\r\n                                }\r\n                            0 < f && L(f, a, b);\r\n                        })();\r\n                    }\r\n                }\r\n                function l() {\r\n                    t.plotArea.layoutManager.reset();\r\n                    t.title && (t.title.dockInsidePlotArea || \"center\" === t.title.horizontalAlign && \"center\" === t.title.verticalAlign) && t.title.render();\r\n                    if (t.subtitles)\r\n                        for (var a = 0; a < t.subtitles.length; a++) {\r\n                            var b = t.subtitles[a];\r\n                            (b.dockInsidePlotArea || \"center\" === b.horizontalAlign && \"center\" === b.verticalAlign) && b.render();\r\n                        }\r\n                    t.legend && (t.legend.dockInsidePlotArea || \"center\" === t.legend.horizontalAlign && \"center\" === t.legend.verticalAlign) && t.legend.render();\r\n                }\r\n                var t = this;\r\n                if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                    var k = this.data[a.dataSeriesIndexes[0]], r = k.dataPoints, p = 10, n = this.plotArea, d = k.dataPointEOs, m = 2, q, s = 1.3, u = 20 / 180 * Math.PI, v = 6, x = { x: (n.x2 + n.x1) / 2, y: (n.y2 + n.y1) / 2 }, z = 0;\r\n                    a = !1;\r\n                    for (var B = 0; B < r.length; B++)\r\n                        z += Math.abs(r[B].y),\r\n                            !a && (\"undefined\" !== typeof r[B].indexLabel && null !== r[B].indexLabel && 0 < r[B].indexLabel.toString().length) && (a = !0), !a && (\"undefined\" !== typeof r[B].label && null !== r[B].label && 0 < r[B].label.toString().length) && (a = !0);\r\n                    if (0 !== z) {\r\n                        a = a || \"undefined\" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;\r\n                        var A = \"inside\" !== k.indexLabelPlacement && a ? 0.75 * Math.min(n.width, n.height) / 2 : 0.92 * Math.min(n.width, n.height) / 2;\r\n                        k.radius && (A = P(k.radius, A));\r\n                        var C = \"undefined\" !== typeof k.innerRadius && null !== k.innerRadius ?\r\n                            P(k.innerRadius, A) : 0.7 * A;\r\n                        k.radius = A;\r\n                        \"doughnut\" === k.type && (k.innerRadius = C);\r\n                        var M = Math.min(C / A, (A - 1) / A);\r\n                        this.pieDoughnutClickHandler = function (a) { t.isAnimating || !y(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && t._animator.animate(0, 500, function (a) { b(a); l(); })); };\r\n                        f();\r\n                        h();\r\n                        h();\r\n                        h();\r\n                        h();\r\n                        this.disableToolTip = !0;\r\n                        this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {\r\n                            var b = t.plotArea.ctx;\r\n                            b.clearRect(n.x1, n.y1, n.width, n.height);\r\n                            b.fillStyle = t.backgroundColor;\r\n                            b.fillRect(n.x1, n.y1, n.width, n.height);\r\n                            a = d[0].startAngle + 2 * Math.PI * a;\r\n                            for (b = 0; b < r.length; b++) {\r\n                                var c = 0 === b ? d[b].startAngle : e, e = c + (d[b].endAngle - d[b].startAngle), f = !1;\r\n                                e > a && (e = a, f = !0);\r\n                                var g = r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length];\r\n                                e > c && qa(t.plotArea.ctx, d[b].center, d[b].radius, g, k.type, c, e, k.fillOpacity, d[b].percentInnerRadius);\r\n                                if (f)\r\n                                    break;\r\n                            }\r\n                            l();\r\n                        }, function () {\r\n                            t.disableToolTip = !1;\r\n                            t._animator.animate(0, t.animatedRender ? 500 : 0, function (a) {\r\n                                b(a);\r\n                                l();\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n        var ra = function (a, f, b, c) { \"undefined\" === typeof b && (b = 1); 0 >= Math.round(f.y4 - f.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(f.x1), Math.round(f.y1)), a.lineTo(Math.round(f.x2), Math.round(f.y2)), a.lineTo(Math.round(f.x3), Math.round(f.y3)), a.lineTo(Math.round(f.x4), Math.round(f.y4)), \"undefined\" !== f.x5 && (a.lineTo(Math.round(f.x5), Math.round(f.y5)), a.lineTo(Math.round(f.x6), Math.round(f.y6))), a.closePath(), a.fillStyle = c ? c : f.color, a.fill(), a.globalAplha = 1, a.restore()); };\r\n        s.prototype.renderFunnel =\r\n            function (a) {\r\n                function f() { for (var a = 0, b = [], c = 0; c < x.length; c++) {\r\n                    if (\"undefined\" === typeof x[c].y)\r\n                        return -1;\r\n                    x[c].y = \"number\" === typeof x[c].y ? x[c].y : 0;\r\n                    a += Math.abs(x[c].y);\r\n                } if (0 === a)\r\n                    return -1; for (c = b[0] = 0; c < x.length; c++)\r\n                    b.push(Math.abs(x[c].y) * P / a); return b; }\r\n                function b() {\r\n                    var a = Y, b = W, c = L, d = Z, e, f;\r\n                    e = R;\r\n                    f = aa - O;\r\n                    headArea = (f - e) * (b - a + (d - c)) / 2;\r\n                    headArea = Math.abs(headArea);\r\n                    c = Z - L;\r\n                    e = f - e;\r\n                    f = c * (f - aa);\r\n                    f = Math.abs(f);\r\n                    f = headArea + f;\r\n                    for (var d = [], g = 0, h = 0; h < x.length; h++) {\r\n                        if (\"undefined\" === typeof x[h].y)\r\n                            return -1;\r\n                        x[h].y = \"number\" === typeof x[h].y ?\r\n                            x[h].y : 0;\r\n                        g += Math.abs(x[h].y);\r\n                    }\r\n                    if (0 === g)\r\n                        return -1;\r\n                    for (var k = d[0] = 0, l = 0, n, b = b - a, t = !1, h = 0; h < x.length; h++)\r\n                        a = Math.abs(x[h].y) * f / g, t ? k = 0 == Number(c.toFixed(3)) ? 0 : a / c : (sqrt = ea * ea * b * b - 4 * Math.abs(ea) * a, 0 > sqrt ? (n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += 0 == n ? 0 : a / n, l += a / n, t = !0) : (k = (Math.abs(ea) * b - Math.sqrt(sqrt)) / 2, n = b - 2 * k / Math.abs(ea), l += k, l > e && (l -= k, n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += a / n, l += a / n, t = !0), b = n)), d.push(k);\r\n                    return d;\r\n                }\r\n                function c() {\r\n                    if (u && x) {\r\n                        for (var a, b, c, e, f, g, h, k, l, n, t, p, r, m, w = [], q = [], A = { percent: null,\r\n                            total: null }, B = null, z = 0; z < x.length; z++)\r\n                            m = N[z], m = \"undefined\" !== typeof m.x5 ? (m.y2 + m.y4) / 2 : (m.y2 + m.y3) / 2, m = d(m).x2 + 1, w[z] = Q - m - V;\r\n                        m = 0.5 * V;\r\n                        for (var z = 0, za = x.length - 1; z < x.length || 0 <= za; z++, za--) {\r\n                            b = u.reversed ? x[za] : x[z];\r\n                            a = b.color ? b.color : u.reversed ? u._colorSet[(x.length - 1 - z) % u._colorSet.length] : u._colorSet[z % u._colorSet.length];\r\n                            c = b.indexLabelPlacement || u.indexLabelPlacement || \"outside\";\r\n                            e = b.indexLabelBackgroundColor || u.indexLabelBackgroundColor || (v ? \"transparent\" : null);\r\n                            f = b.indexLabelFontColor || u.indexLabelFontColor ||\r\n                                \"#979797\";\r\n                            g = y(b.indexLabelFontSize) ? u.indexLabelFontSize : b.indexLabelFontSize;\r\n                            h = b.indexLabelFontStyle || u.indexLabelFontStyle || \"normal\";\r\n                            k = b.indexLabelFontFamily || u.indexLabelFontFamily || \"arial\";\r\n                            l = b.indexLabelFontWeight || u.indexLabelFontWeight || \"normal\";\r\n                            a = b.indexLabelLineColor || u.options.indexLabelLineColor || a;\r\n                            n = \"number\" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : \"number\" === typeof u.indexLabelLineThickness ? u.indexLabelLineThickness : 2;\r\n                            t = b.indexLabelLineDashType || u.indexLabelLineDashType ||\r\n                                \"solid\";\r\n                            p = \"undefined\" !== typeof b.indexLabelWrap ? b.indexLabelWrap : \"undefined\" !== typeof u.indexLabelWrap ? u.indexLabelWrap : !0;\r\n                            r = u.dataPointIds[z];\r\n                            s._eventManager.objectMap[r] = { id: r, objectType: \"dataPoint\", dataPointIndex: z, dataSeriesIndex: 0, funnelSection: N[u.reversed ? x.length - 1 - z : z] };\r\n                            \"inside\" === u.indexLabelPlacement && (w[z] = z !== fa ? u.reversed ? N[z].x2 - N[z].x1 : N[z].x3 - N[z].x4 : N[z].x3 - N[z].x6, 20 > w[z] && (w[z] = z !== fa ? u.reversed ? N[z].x3 - N[z].x4 : N[z].x2 - N[z].x1 : N[z].x2 - N[z].x1, w[z] /= 2));\r\n                            r = b.indexLabelMaxWidth ? b.indexLabelMaxWidth :\r\n                                u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth : w[z];\r\n                            if (r > w[z] || 0 > r)\r\n                                r = w[z];\r\n                            q[z] = \"inside\" === u.indexLabelPlacement ? N[z].height : !1;\r\n                            A = s.getPercentAndTotal(u, b);\r\n                            if (u.indexLabelFormatter || b.indexLabelFormatter)\r\n                                B = { chart: s.options, dataSeries: u, dataPoint: b, total: A.total, percent: A.percent };\r\n                            b = b.indexLabelFormatter ? b.indexLabelFormatter(B) : b.indexLabel ? s.replaceKeywordsWithValue(b.indexLabel, b, u, z) : u.indexLabelFormatter ? u.indexLabelFormatter(B) : u.indexLabel ? s.replaceKeywordsWithValue(u.indexLabel, b, u, z) : b.label ?\r\n                                b.label : \"\";\r\n                            0 >= n && (n = 0);\r\n                            1E3 > r && 1E3 - r < m && (r += 1E3 - r);\r\n                            S.roundRect || Ca(S);\r\n                            c = new ka(S, { fontSize: g, fontFamily: k, fontColor: f, fontStyle: h, fontWeight: l, horizontalAlign: c, backgroundColor: e, maxWidth: r, maxHeight: !1 === q[z] ? p ? 4.28571429 * g : 1.5 * g : q[z], text: b, padding: ga });\r\n                            c.measureText();\r\n                            F.push({ textBlock: c, id: u.reversed ? za : z, isDirty: !1, lineColor: a, lineThickness: n, lineDashType: t, height: c.height < c.maxHeight ? c.height : c.maxHeight, width: c.width < c.maxWidth ? c.width : c.maxWidth });\r\n                        }\r\n                    }\r\n                }\r\n                function e() {\r\n                    var a, b, c, d, e, f = [];\r\n                    e = !1;\r\n                    c = 0;\r\n                    for (var g = Q - W - V / 2, g = u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth > g ? g : u.indexLabelMaxWidth : g, h = F.length - 1; 0 <= h; h--) {\r\n                        dataPoint = x[F[h].id];\r\n                        c = F[h];\r\n                        d = c.textBlock;\r\n                        b = (a = n(h) < N.length ? F[n(h)] : null) ? a.textBlock : null;\r\n                        c = c.height;\r\n                        a && d.y + c + ga > b.y && (e = !0);\r\n                        c = dataPoint.indexLabelMaxWidth || g;\r\n                        if (c > g || 0 > c)\r\n                            c = g;\r\n                        f.push(c);\r\n                    }\r\n                    if (e)\r\n                        for (h = F.length - 1; 0 <= h; h--)\r\n                            a = N[h], F[h].textBlock.maxWidth = f[f.length - (h + 1)], F[h].textBlock.measureText(), F[h].textBlock.x = Q - g, c = F[h].textBlock.height < F[h].textBlock.maxHeight ? F[h].textBlock.height :\r\n                                F[h].textBlock.maxHeight, e = F[h].textBlock.width < F[h].textBlock.maxWidth ? F[h].textBlock.width : F[h].textBlock.maxWidth, F[h].height = c, F[h].width = e, c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, F[h].textBlock.y = c - F[h].height / 2, u.reversed ? (F[h].textBlock.y + F[h].height > U + C && (F[h].textBlock.y = U + C - F[h].height), F[h].textBlock.y < sa - C && (F[h].textBlock.y = sa - C)) : (F[h].textBlock.y < U - C && (F[h].textBlock.y = U - C), F[h].textBlock.y + F[h].height > sa + C && (F[h].textBlock.y = sa + C - F[h].height));\r\n                }\r\n                function g() {\r\n                    var a, b, c, e;\r\n                    if (\"inside\" !== u.indexLabelPlacement)\r\n                        for (var f = 0; f < N.length; f++)\r\n                            0 == F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = N[f], c = \"undefined\" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = u.reversed ? \"undefined\" !== typeof a.x5 ? c > ba ? d(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : \"undefined\" !== typeof a.x5 ? c < ba ? d(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, F[f].textBlock.x = b + V, F[f].textBlock.y = c - F[f].height / 2, u.reversed ? (F[f].textBlock.y + F[f].height > U + C && (F[f].textBlock.y = U + C - F[f].height), F[f].textBlock.y < sa - C && (F[f].textBlock.y =\r\n                                sa - C)) : (F[f].textBlock.y < U - C && (F[f].textBlock.y = U - C), F[f].textBlock.y + F[f].height > sa + C && (F[f].textBlock.y = sa + C - F[f].height)));\r\n                    else\r\n                        for (f = 0; f < N.length; f++)\r\n                            0 == F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = N[f], b = a.height, c = F[f].height, e = F[f].width, b >= c ? (b = f != fa ? (a.x4 + a.x3) / 2 - e / 2 : (a.x5 + a.x4) / 2 - e / 2, c = f != fa ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, F[f].textBlock.x = b, F[f].textBlock.y = c) : F[f].isDirty = !0);\r\n                }\r\n                function h() {\r\n                    function a(b, c) {\r\n                        var d;\r\n                        if (0 > b || b >= F.length)\r\n                            return 0;\r\n                        var e, f = F[b].textBlock;\r\n                        if (0 > c) {\r\n                            c *= -1;\r\n                            e = p(b);\r\n                            d = l(e, b);\r\n                            if (d >= c)\r\n                                return f.y -= c, c;\r\n                            if (0 == b)\r\n                                return 0 < d && (f.y -= d), d;\r\n                            d += a(e, -(c - d));\r\n                            0 < d && (f.y -= d);\r\n                            return d;\r\n                        }\r\n                        e = n(b);\r\n                        d = l(b, e);\r\n                        if (d >= c)\r\n                            return f.y += c, c;\r\n                        if (b == N.length - 1)\r\n                            return 0 < d && (f.y += d), d;\r\n                        d += a(e, c - d);\r\n                        0 < d && (f.y += d);\r\n                        return d;\r\n                    }\r\n                    function b() {\r\n                        var a, d, e, f, g = 0, h;\r\n                        f = (aa - R + 2 * C) / t;\r\n                        h = t;\r\n                        for (var k, l = 1; l < h; l++) {\r\n                            e = l * f;\r\n                            for (var r = F.length - 1; 0 <= r; r--)\r\n                                !F[r].isDirty && (F[r].textBlock.y < e && F[r].textBlock.y + F[r].height > e) && (k = n(r), !(k >= F.length - 1) && F[r].textBlock.y + F[r].height + ga > F[k].textBlock.y && (F[r].textBlock.y = F[r].textBlock.y +\r\n                                    F[r].height - e > e - F[r].textBlock.y ? e + 1 : e - F[r].height - 1));\r\n                        }\r\n                        for (k = N.length - 1; 0 < k; k--)\r\n                            if (!F[k].isDirty) {\r\n                                e = p(k);\r\n                                if (0 > e && (e = 0, F[e].isDirty))\r\n                                    break;\r\n                                if (F[k].textBlock.y < F[e].textBlock.y + F[e].height) {\r\n                                    d = d || k;\r\n                                    f = k;\r\n                                    for (h = 0; F[f].textBlock.y < F[e].textBlock.y + F[e].height + ga;) {\r\n                                        a = a || F[f].textBlock.y + F[f].height;\r\n                                        h += F[f].height;\r\n                                        h += ga;\r\n                                        f = e;\r\n                                        if (0 >= f) {\r\n                                            f = 0;\r\n                                            h += F[f].height;\r\n                                            break;\r\n                                        }\r\n                                        e = p(f);\r\n                                        if (0 > e) {\r\n                                            f = 0;\r\n                                            h += F[f].height;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (f != k) {\r\n                                        g = F[f].textBlock.y;\r\n                                        a -= g;\r\n                                        a = h - a;\r\n                                        g = c(a, d, f);\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        return g;\r\n                    }\r\n                    function c(a, b, d) {\r\n                        var e = [], f = 0, g = 0;\r\n                        for (a = Math.abs(a); d <=\r\n                            b; d++)\r\n                            e.push(N[d]);\r\n                        e.sort(function (a, b) { return a.height - b.height; });\r\n                        for (d = 0; d < e.length; d++)\r\n                            if (b = e[d], f < a)\r\n                                g++, f += F[b.id].height + ga, F[b.id].textBlock.text = \"\", F[b.id].indexLabelText = \"\", F[b.id].isDirty = !0, F[b.id].textBlock.measureText();\r\n                            else\r\n                                break;\r\n                        return g;\r\n                    }\r\n                    for (var d, e, f, g, h, k, t = 1, r = 0; r < 2 * t; r++) {\r\n                        for (var m = F.length - 1; 0 <= m && !(previousTextBlock = (previousLabel = 0 <= p(m) ? F[p(m)] : null) ? previousLabel.textBlock : null, f = F[m], g = f.textBlock, k = (h = n(m) < N.length ? F[n(m)] : null) ? h.textBlock : null, d = +f.height.toFixed(6), e = +g.y.toFixed(6),\r\n                            !f.isDirty && (h && e + d + ga > +k.y.toFixed(6)) && (d = g.y + d + ga - k.y, e = a(m, -d), e < d && (0 < e && (d -= e), e = a(n(m), d), e != d))); m--)\r\n                            ;\r\n                        b();\r\n                    }\r\n                }\r\n                function l(a, b) { return (b < N.length ? F[b].textBlock.y : u.reversed ? U + C : sa + C) - (0 > a ? u.reversed ? sa - C : U - C : F[a].textBlock.y + F[a].height + ga); }\r\n                function t(a, b, c) {\r\n                    var d, e, f, h = [], l = C, n = [];\r\n                    -1 !== b && (0 <= la.indexOf(b) ? (e = la.indexOf(b), la.splice(e, 1)) : (la.push(b), la = la.sort(function (a, b) { return a - b; })));\r\n                    if (0 === la.length)\r\n                        h = ja;\r\n                    else {\r\n                        e = C * (1 != la.length || 0 != la[0] && la[0] != N.length - 1 ? 2 : 1) / k();\r\n                        for (var t = 0; t < N.length; t++) {\r\n                            if (1 ==\r\n                                la.length && 0 == la[0]) {\r\n                                if (0 === t) {\r\n                                    h.push(ja[t]);\r\n                                    d = l;\r\n                                    continue;\r\n                                }\r\n                            }\r\n                            else\r\n                                0 === t && (d = -1 * l);\r\n                            h.push(ja[t] + d);\r\n                            if (0 <= la.indexOf(t) || t < N.length && 0 <= la.indexOf(t + 1))\r\n                                d += e;\r\n                        }\r\n                    }\r\n                    f = function () { for (var a = [], b = 0; b < N.length; b++)\r\n                        a.push(h[b] - N[b].y1); return a; }();\r\n                    var p = { startTime: (new Date).getTime(), duration: c || 500, easingFunction: function (a, b, c, d) { return I.easing.easeOutQuart(a, b, c, d); }, changeSection: function (a) {\r\n                            for (var b, c, d = 0; d < N.length; d++)\r\n                                b = f[d], c = N[d], newY = b * a, \"undefined\" === typeof n[d] && (n[d] = 0), 0 > n && (n *= -1), c.y1 += newY - n[d],\r\n                                    c.y2 += newY - n[d], c.y3 += newY - n[d], c.y4 += newY - n[d], c.y5 && (c.y5 += newY - n[d], c.y6 += newY - n[d]), n[d] = newY;\r\n                        } };\r\n                    a._animator.animate(0, c, function (c) {\r\n                        var d = a.plotArea.ctx || a.ctx;\r\n                        ia = !0;\r\n                        d.clearRect(z.x1, z.y1, z.x2 - z.x1, z.y2 - z.y1);\r\n                        d.fillStyle = a.backgroundColor;\r\n                        d.fillRect(z.x1, z.y1, z.width, z.height);\r\n                        p.changeSection(c, b);\r\n                        var e = {};\r\n                        e.dataSeries = u;\r\n                        e.dataPoint = u.reversed ? u.dataPoints[x.length - 1 - b] : u.dataPoints[b];\r\n                        e.index = u.reversed ? x.length - 1 - b : b;\r\n                        a.toolTip.highlightObjects([e]);\r\n                        for (e = 0; e < N.length; e++)\r\n                            ra(d, N[e], u.fillOpacity);\r\n                        q(d);\r\n                        K && (\"inside\" !== u.indexLabelPlacement ? r(d) : g(), m(d));\r\n                        1 <= c && (ia = !1);\r\n                    }, null, I.easing.easeOutQuart);\r\n                }\r\n                function k() { for (var a = 0, b = 0; b < N.length - 1; b++)\r\n                    (0 <= la.indexOf(b) || 0 <= la.indexOf(b + 1)) && a++; return a; }\r\n                function r(a) {\r\n                    for (var b, c, e, f, g = 0; g < N.length; g++)\r\n                        f = 1 === F[g].lineThickness % 2 ? 0.5 : 0, c = ((N[g].y2 + N[g].y4) / 2 << 0) + f, b = d(c).x2 - 1, e = F[g].textBlock.x, f = (F[g].textBlock.y + F[g].height / 2 << 0) + f, F[g].isDirty || 0 == F[g].lineThickness || (a.strokeStyle = F[g].lineColor, a.lineWidth = F[g].lineThickness, a.setLineDash && a.setLineDash(G(F[g].lineDashType, F[g].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(e, f), a.stroke());\r\n                }\r\n                function p(a) { for (a -= 1; -1 <= a && -1 != a && F[a].isDirty; a--)\r\n                    ; return a; }\r\n                function n(a) { for (a += 1; a <= N.length && a != N.length && F[a].isDirty; a++)\r\n                    ; return a; }\r\n                function d(a) { for (var b, c = 0; c < x.length; c++)\r\n                    if (N[c].y1 < a && N[c].y4 > a) {\r\n                        b = N[c];\r\n                        break;\r\n                    } return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), { x1: a, x2: a }) : -1; }\r\n                function m(a) {\r\n                    for (var b = 0; b < N.length; b++)\r\n                        F[b].isDirty ||\r\n                            (a && (F[b].textBlock.ctx = a), F[b].textBlock.render(!0));\r\n                }\r\n                function q(a) {\r\n                    s.plotArea.layoutManager.reset();\r\n                    a.roundRect || Ca(a);\r\n                    s.title && (s.title.dockInsidePlotArea || \"center\" === s.title.horizontalAlign && \"center\" === s.title.verticalAlign) && (s.title.ctx = a, s.title.render());\r\n                    if (s.subtitles)\r\n                        for (var b = 0; b < s.subtitles.length; b++) {\r\n                            var c = s.subtitles[b];\r\n                            if (c.dockInsidePlotArea || \"center\" === c.horizontalAlign && \"center\" === c.verticalAlign)\r\n                                s.subtitles.ctx = a, c.render();\r\n                        }\r\n                    s.legend && (s.legend.dockInsidePlotArea || \"center\" === s.legend.horizontalAlign &&\r\n                        \"center\" === s.legend.verticalAlign) && (s.legend.ctx = a, s.legend.render());\r\n                    $.fNg && $.fNg(s);\r\n                }\r\n                var s = this;\r\n                if (!(0 >= a.dataSeriesIndexes.length)) {\r\n                    for (var u = this.data[a.dataSeriesIndexes[0]], x = u.dataPoints, z = this.plotArea, C = 0.025 * z.width, B = 0.01 * z.width, A = 0, P = z.height - 2 * C, M = Math.min(z.width - 2 * B, 2.8 * z.height), K = !1, J = 0; J < x.length; J++)\r\n                        if (!K && (\"undefined\" !== typeof x[J].indexLabel && null !== x[J].indexLabel && 0 < x[J].indexLabel.toString().length) && (K = !0), !K && (\"undefined\" !== typeof x[J].label && null !== x[J].label && 0 < x[J].label.toString().length) &&\r\n                            (K = !0), !K && \"function\" === typeof u.indexLabelFormatter || \"function\" === typeof x[J].indexLabelFormatter)\r\n                            K = !0;\r\n                    K = K || \"undefined\" !== typeof u.indexLabel && null !== u.indexLabel && 0 < u.indexLabel.toString().length;\r\n                    \"inside\" !== u.indexLabelPlacement && K || (B = (z.width - 0.75 * M) / 2);\r\n                    var J = z.x1 + B, Q = z.x2 - B, R = z.y1 + C, aa = z.y2 - C, S = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;\r\n                    if (0 != u.length && (u.dataPoints && u.visible) && 0 !== x.length) {\r\n                        var O, E;\r\n                        a = 75 * M / 100;\r\n                        var V = 30 * (Q - a) / 100;\r\n                        \"funnel\" === u.type ? (O = y(u.options.neckHeight) ? 0.35 * P : u.neckHeight,\r\n                            E = y(u.options.neckWidth) ? 0.25 * a : u.neckWidth, \"string\" === typeof O && O.match(/%$/) ? (O = parseInt(O), O = O * P / 100) : O = parseInt(O), \"string\" === typeof E && E.match(/%$/) ? (E = parseInt(E), E = E * a / 100) : E = parseInt(E), O > P ? O = P : 0 >= O && (O = 0), E > a ? E = a - 0.5 : 0 >= E && (E = 0)) : \"pyramid\" === u.type && (E = O = 0, u.reversed = u.reversed ? !1 : !0);\r\n                        var B = J + a / 2, Y = J, W = J + a, U = u.reversed ? aa : R, L = B - E / 2, Z = B + E / 2, ba = u.reversed ? R + O : aa - O, sa = u.reversed ? R : aa;\r\n                        a = [];\r\n                        var B = [], N = [], M = [], X = R, fa, ea = (ba - U) / (L - Y), ha = -ea, J = \"area\" === (u.valueRepresents ? u.valueRepresents : \"height\") ?\r\n                            b() : f();\r\n                        if (-1 !== J) {\r\n                            if (u.reversed)\r\n                                for (M.push(X), E = J.length - 1; 0 < E; E--)\r\n                                    X += J[E], M.push(X);\r\n                            else\r\n                                for (E = 0; E < J.length; E++)\r\n                                    X += J[E], M.push(X);\r\n                            if (u.reversed)\r\n                                for (E = 0; E < J.length; E++)\r\n                                    M[E] < ba ? (a.push(L), B.push(Z), fa = E) : (a.push((M[E] - U + ea * Y) / ea), B.push((M[E] - U + ha * W) / ha));\r\n                            else\r\n                                for (E = 0; E < J.length; E++)\r\n                                    M[E] < ba ? (a.push((M[E] - U + ea * Y) / ea), B.push((M[E] - U + ha * W) / ha), fa = E) : (a.push(L), B.push(Z));\r\n                            for (E = 0; E < J.length - 1; E++)\r\n                                X = u.reversed ? x[x.length - 1 - E].color ? x[x.length - 1 - E].color : u._colorSet[(x.length - 1 - E) % u._colorSet.length] : x[E].color ?\r\n                                    x[E].color : u._colorSet[E % u._colorSet.length], E === fa ? N.push({ x1: a[E], y1: M[E], x2: B[E], y2: M[E], x3: Z, y3: ba, x4: B[E + 1], y4: M[E + 1], x5: a[E + 1], y5: M[E + 1], x6: L, y6: ba, id: E, height: M[E + 1] - M[E], color: X }) : N.push({ x1: a[E], y1: M[E], x2: B[E], y2: M[E], x3: B[E + 1], y3: M[E + 1], x4: a[E + 1], y4: M[E + 1], id: E, height: M[E + 1] - M[E], color: X });\r\n                            var ga = 2, F = [], ia = !1, la = [], ja = [], J = !1;\r\n                            a = a = 0;\r\n                            Da(la);\r\n                            for (E = 0; E < x.length; E++)\r\n                                x[E].exploded && (J = !0, u.reversed ? la.push(x.length - 1 - E) : la.push(E));\r\n                            S.clearRect(z.x1, z.y1, z.width, z.height);\r\n                            S.fillStyle = s.backgroundColor;\r\n                            S.fillRect(z.x1, z.y1, z.width, z.height);\r\n                            if (K && u.visible && (c(), g(), e(), \"inside\" !== u.indexLabelPlacement)) {\r\n                                h();\r\n                                for (E = 0; E < x.length; E++)\r\n                                    F[E].isDirty || (a = F[E].textBlock.x + F[E].width, a = (Q - a) / 2, 0 == E && (A = a), A > a && (A = a));\r\n                                for (E = 0; E < N.length; E++)\r\n                                    N[E].x1 += A, N[E].x2 += A, N[E].x3 += A, N[E].x4 += A, N[E].x5 && (N[E].x5 += A, N[E].x6 += A), F[E].textBlock.x += A;\r\n                            }\r\n                            for (E = 0; E < N.length; E++)\r\n                                A = N[E], ra(S, A, u.fillOpacity), ja.push(A.y1);\r\n                            q(S);\r\n                            K && u.visible && (\"inside\" === u.indexLabelPlacement || s.animationEnabled || r(S), s.animationEnabled || m());\r\n                            if (!K)\r\n                                for (E =\r\n                                    0; E < x.length; E++)\r\n                                    A = u.dataPointIds[E], a = { id: A, objectType: \"dataPoint\", dataPointIndex: E, dataSeriesIndex: 0, funnelSection: N[u.reversed ? x.length - 1 - E : E] }, s._eventManager.objectMap[A] = a;\r\n                            !s.animationEnabled && J ? t(s, -1, 0) : s.animationEnabled && !s.animatedRender && t(s, -1, 0);\r\n                            this.funnelPyramidClickHandler = function (a) {\r\n                                var b = -1;\r\n                                if (!ia && !s.isAnimating && (y(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = u.reversed ? x.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {\r\n                                    a = b;\r\n                                    if (\"funnel\" === u.type || \"pyramid\" ===\r\n                                        u.type)\r\n                                        u.reversed ? x[x.length - 1 - a].exploded = x[x.length - 1 - a].exploded ? !1 : !0 : x[a].exploded = x[a].exploded ? !1 : !0;\r\n                                    t(s, b, 500);\r\n                                }\r\n                            };\r\n                            return { source: S, dest: this.plotArea.ctx, animationCallback: function (a, b) { I.fadeInAnimation(a, b); 1 <= a && (t(s, -1, 500), q(s.plotArea.ctx || s.ctx)); }, easingFunction: I.easing.easeInQuad, animationBase: 0 };\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        s.prototype.animationRequestId = null;\r\n        s.prototype.requestAnimFrame = function () {\r\n            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||\r\n                window.msRequestAnimationFrame || function (a) { window.setTimeout(a, 1E3 / 60); };\r\n        }();\r\n        s.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;\r\n        s.prototype.set = function (a, f, b) { b = \"undefined\" === typeof b ? !0 : b; \"options\" === a ? (this.options = f, b && this.render()) : s.base.set.call(this, a, f, b); };\r\n        s.prototype.exportChart = function (a) {\r\n            a = \"undefined\" === typeof a ?\r\n                {} : a;\r\n            var f = a.format ? a.format : \"png\", b = a.fileName ? a.fileName : this.exportFileName;\r\n            if (a.toDataURL)\r\n                return this.canvas.toDataURL(\"image/\" + f);\r\n            q(this.canvas, f, b);\r\n        };\r\n        s.prototype.print = function () {\r\n            var a = this.exportChart({ toDataURL: !0 }), f = document.createElement(\"iframe\");\r\n            f.setAttribute(\"class\", \"canvasjs-chart-print-frame\");\r\n            f.setAttribute(\"style\", \"position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;\");\r\n            f.style.height = this.height + \"px\";\r\n            this._canvasJSContainer.appendChild(f);\r\n            var b = this, c = f.contentWindow || f.contentDocument.document || f.contentDocument;\r\n            c.document.open();\r\n            c.document.write('<!DOCTYPE HTML>\\n<html><body style=\"margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;\"><img src=\"' + a + '\"/><body/></html>');\r\n            c.document.close();\r\n            setTimeout(function () { c.focus(); c.print(); setTimeout(function () { b._canvasJSContainer.removeChild(f); }, 1E3); }, 500);\r\n        };\r\n        s.prototype.getPercentAndTotal = function (a, f) {\r\n            var b = null, c = null, e = null;\r\n            if (0 <= a.type.indexOf(\"stacked\"))\r\n                c = 0, b = f.x.getTime ? f.x.getTime() :\r\n                    f.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(f.y) ? 0 : 100 * (f.y / c));\r\n            else if (\"pie\" === a.type || \"doughnut\" === a.type || \"funnel\" === a.type || \"pyramid\" === a.type) {\r\n                for (i = c = 0; i < a.dataPoints.length; i++)\r\n                    isNaN(a.dataPoints[i].y) || (c += a.dataPoints[i].y);\r\n                e = isNaN(f.y) ? 0 : 100 * (f.y / c);\r\n            }\r\n            return { percent: e, total: c };\r\n        };\r\n        s.prototype.replaceKeywordsWithValue = function (a, f, b, c, e) {\r\n            var g = this;\r\n            e = \"undefined\" === typeof e ? 0 : e;\r\n            if ((0 <= b.type.indexOf(\"stacked\") || \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" ===\r\n                b.type) && (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"))) {\r\n                var h = \"#percent\", l = \"#total\", t = this.getPercentAndTotal(b, f), l = isNaN(t.total) ? l : t.total, h = isNaN(t.percent) ? h : t.percent;\r\n                do {\r\n                    t = \"\";\r\n                    if (b.percentFormatString)\r\n                        t = b.percentFormatString;\r\n                    else {\r\n                        var t = \"#,##0.\", k = Math.max(Math.ceil(Math.log(1 / Math.abs(h)) / Math.LN10), 2);\r\n                        if (isNaN(k) || !isFinite(k))\r\n                            k = 2;\r\n                        for (var r = 0; r < k; r++)\r\n                            t += \"#\";\r\n                        b.percentFormatString = t;\r\n                    }\r\n                    a = a.replace(\"#percent\", X(h, t, g._cultureInfo));\r\n                    a = a.replace(\"#total\", X(l, b.yValueFormatString ? b.yValueFormatString :\r\n                        \"#,##0.########\", g._cultureInfo));\r\n                } while (0 <= a.indexOf(\"#percent\") || 0 <= a.indexOf(\"#total\"));\r\n            }\r\n            return a.replace(/\\{.*?\\}|\"[^\"]*\"|'[^']*'/g, function (a) {\r\n                if ('\"' === a[0] && '\"' === a[a.length - 1] || \"'\" === a[0] && \"'\" === a[a.length - 1])\r\n                    return a.slice(1, a.length - 1);\r\n                a = Ga(a.slice(1, a.length - 1));\r\n                a = a.replace(\"#index\", e);\r\n                var h = null;\r\n                try {\r\n                    var d = a.match(/(.*?)\\s*\\[\\s*(.*?)\\s*\\]/);\r\n                    d && 0 < d.length && (h = Ga(d[2]), a = Ga(d[1]));\r\n                }\r\n                catch (k) { }\r\n                d = null;\r\n                if (\"color\" === a)\r\n                    return \"waterfall\" === b.type ? f.color ? f.color : 0 < f.y ? b.risingColor : b.fallingColor : \"error\" ===\r\n                        b.type ? b.color ? b.color : b._colorSet[h % b._colorSet.length] : f.color ? f.color : b.color ? b.color : b._colorSet[c % b._colorSet.length];\r\n                if (f.hasOwnProperty(a))\r\n                    d = f;\r\n                else if (b.hasOwnProperty(a))\r\n                    d = b;\r\n                else\r\n                    return \"\";\r\n                d = d[a];\r\n                null !== h && (d = d[h]);\r\n                if (\"x\" === a)\r\n                    if (\"dateTime\" === b.axisX.valueType || \"dateTime\" === b.xValueType || f.x && f.x.getTime) {\r\n                        if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic)\r\n                            return Ba(d, f.xValueFormatString ? f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString :\r\n                                b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : \"DD MMM YY\", g._cultureInfo);\r\n                    }\r\n                    else\r\n                        return X(d, f.xValueFormatString ? f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = \"#,##0.########\", g._cultureInfo);\r\n                else\r\n                    return \"y\" === a ? X(d, f.yValueFormatString ? f.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = \"#,##0.########\", g._cultureInfo) : \"z\" === a ? X(d, f.zValueFormatString ? f.zValueFormatString : b.zValueFormatString ?\r\n                        b.zValueFormatString : b.zValueFormatString = \"#,##0.########\", g._cultureInfo) : d;\r\n            });\r\n        };\r\n        oa(U, Y);\r\n        U.prototype.render = function () {\r\n            var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, f = a.layoutManager.getFreeSpace(), b = null, c = 0, e = 0, g = 0, h = 0, l = this.markerMargin = this.chart.options.legend && !y(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;\r\n            this.height = 0;\r\n            var t = [], k = [];\r\n            \"top\" === this.verticalAlign || \"bottom\" === this.verticalAlign ? (this.orientation = \"horizontal\", b =\r\n                this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * f.height) : \"center\" === this.verticalAlign && (this.orientation = \"vertical\", b = this.horizontalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : f.height);\r\n            for (var r = [], p = 0; p < this.dataSeries.length; p++) {\r\n                var n = this.dataSeries[p];\r\n                if (n.dataPoints && n.dataPoints.length)\r\n                    if (\"pie\" !== n.type && \"doughnut\" !== n.type &&\r\n                        \"funnel\" !== n.type && \"pyramid\" !== n.type) {\r\n                        var d = n.legendMarkerType = n.legendMarkerType ? n.legendMarkerType : \"line\" !== n.type && \"stepLine\" !== n.type && \"spline\" !== n.type && \"scatter\" !== n.type && \"bubble\" !== n.type || !n.markerType ? \"error\" === n.type && n._linkedSeries ? n._linkedSeries.legendMarkerType ? n._linkedSeries.legendMarkerType : R.getDefaultLegendMarker(n._linkedSeries.type) : R.getDefaultLegendMarker(n.type) : n.markerType, m = n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options,\r\n                            dataSeries: n, dataPoint: null }) : n.name, q = n.legendMarkerColor = n.legendMarkerColor ? n.legendMarkerColor : n.markerColor ? n.markerColor : \"error\" === n.type ? y(n.whiskerColor) ? n._colorSet[0] : n.whiskerColor : n._colorSet[0], s = n.markerSize || \"line\" !== n.type && \"stepLine\" !== n.type && \"spline\" !== n.type ? 0.75 * this.lineHeight : 0, u = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : n.markerBorderColor, v = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : n.markerBorderThickness ? Math.max(1, Math.round(0.2 * s)) : 0;\r\n                        \"error\" ===\r\n                            n.type && r.push(q);\r\n                        m = this.chart.replaceKeywordsWithValue(m, n.dataPoints[0], n, p);\r\n                        d = { markerType: d, markerColor: q, text: m, textBlock: null, chartType: n.type, markerSize: s, lineColor: n._colorSet[0], dataSeriesIndex: n.index, dataPointIndex: null, markerBorderColor: u, markerBorderThickness: v };\r\n                        t.push(d);\r\n                    }\r\n                    else\r\n                        for (var x = 0; x < n.dataPoints.length; x++) {\r\n                            var z = n.dataPoints[x], d = z.legendMarkerType ? z.legendMarkerType : n.legendMarkerType ? n.legendMarkerType : R.getDefaultLegendMarker(n.type), m = z.legendText ? z.legendText : n.legendText ?\r\n                                n.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: n, dataPoint: z }) : z.name ? z.name : \"DataPoint: \" + (x + 1), q = z.legendMarkerColor ? z.legendMarkerColor : n.legendMarkerColor ? n.legendMarkerColor : z.color ? z.color : n.color ? n.color : n._colorSet[x % n._colorSet.length], s = 0.75 * this.lineHeight, u = z.legendMarkerBorderColor ? z.legendMarkerBorderColor : n.legendMarkerBorderColor ? n.legendMarkerBorderColor : z.markerBorderColor ? z.markerBorderColor : n.markerBorderColor, v = z.legendMarkerBorderThickness ?\r\n                                z.legendMarkerBorderThickness : n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : z.markerBorderThickness || n.markerBorderThickness ? Math.max(1, Math.round(0.2 * s)) : 0, m = this.chart.replaceKeywordsWithValue(m, z, n, x), d = { markerType: d, markerColor: q, text: m, textBlock: null, chartType: n.type, markerSize: s, dataSeriesIndex: p, dataPointIndex: x, markerBorderColor: u, markerBorderThickness: v };\r\n                            (z.showInLegend || n.showInLegend && !1 !== z.showInLegend) && t.push(d);\r\n                        }\r\n            }\r\n            !0 === this.reversed && t.reverse();\r\n            if (0 < t.length) {\r\n                n = null;\r\n                m =\r\n                    x = z = v = 0;\r\n                z = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth, g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth = g;\r\n                s = 0 === s ? 0.75 * this.lineHeight : s;\r\n                z -= s + l;\r\n                for (p = 0; p < t.length; p++) {\r\n                    d = t[p];\r\n                    q = z;\r\n                    if (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType)\r\n                        q -= 2 * 0.1 * this.lineHeight;\r\n                    if (!(0 >= h || \"undefined\" === typeof h || 0 >= q || \"undefined\" === typeof q)) {\r\n                        if (\"horizontal\" === this.orientation) {\r\n                            d.textBlock =\r\n                                new ka(this.ctx, { x: 0, y: 0, maxWidth: q, maxHeight: this.itemWrap ? h : this.lineHeight, angle: 0, text: d.text, horizontalAlign: \"left\", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" });\r\n                            d.textBlock.measureText();\r\n                            null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)));\r\n                            if (!n || n.width + Math.round(d.textBlock.width +\r\n                                s + l + (0 === n.width ? 0 : this.horizontalSpacing) + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g)\r\n                                n = { items: [], width: 0 }, k.push(n), this.height += x, x = 0;\r\n                            x = Math.max(x, d.textBlock.height);\r\n                        }\r\n                        else\r\n                            d.textBlock = new ka(this.ctx, { x: 0, y: 0, maxWidth: z, maxHeight: !0 === this.itemWrap ? h : 1.5 * this.fontSize, angle: 0, text: d.text, horizontalAlign: \"left\", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: \"middle\" }),\r\n                                d.textBlock.measureText(), null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < h - this.lineHeight ? (n = { items: [], width: 0 }, k.push(n)) : (n = k[v], v = (v + 1) % k.length), this.height += d.textBlock.height;\r\n                        d.textBlock.x = n.width;\r\n                        d.textBlock.y = 0;\r\n                        n.width += Math.round(d.textBlock.width + s + l + (0 === n.width ? 0 : this.horizontalSpacing) + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 *\r\n                            0.1 * this.lineHeight : 0));\r\n                        n.items.push(d);\r\n                        this.width = Math.max(n.width, this.width);\r\n                        m = d.textBlock.width + (s + l + (\"line\" === d.chartType || \"spline\" === d.chartType || \"stepLine\" === d.chartType ? 2 * 0.1 * this.lineHeight : 0));\r\n                    }\r\n                }\r\n                this.itemWidth = m;\r\n                this.height = !1 === this.itemWrap ? k.length * this.lineHeight : this.height + x;\r\n                this.height = Math.min(h, this.height);\r\n                this.width = Math.min(g, this.width);\r\n            }\r\n            \"top\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2,\r\n                c = f.y1) : \"center\" === this.verticalAlign ? (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y1 + f.height / 2 - this.height / 2) : \"bottom\" === this.verticalAlign && (e = \"left\" === this.horizontalAlign ? f.x1 : \"right\" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y2 - this.height);\r\n            this.items = t;\r\n            for (p = 0; p < this.items.length; p++)\r\n                d = t[p], d.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[d.id] = { id: d.id, objectType: \"legendItem\",\r\n                    legendItemIndex: p, dataSeriesIndex: d.dataSeriesIndex, dataPointIndex: d.dataPointIndex };\r\n            (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(e, c, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);\r\n            for (p = f = 0; p < k.length; p++) {\r\n                n = k[p];\r\n                for (z = x = 0; z < n.items.length; z++) {\r\n                    d = n.items[z];\r\n                    q = d.textBlock.x + e + (0 === z ? 0.2 * s : this.horizontalSpacing);\r\n                    u = c + f;\r\n                    m = q;\r\n                    this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);\r\n                    this.ctx.save();\r\n                    this.ctx.beginPath();\r\n                    this.ctx.rect(e, c, g, Math.max(h - h % this.lineHeight, 0));\r\n                    this.ctx.clip();\r\n                    if (\"line\" === d.chartType || \"stepLine\" === d.chartType || \"spline\" === d.chartType)\r\n                        this.ctx.strokeStyle = d.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(q - 0.1 * this.lineHeight, u + this.lineHeight / 2), this.ctx.lineTo(q + 0.85 * this.lineHeight, u + this.lineHeight / 2), this.ctx.stroke(), m -= 0.1 * this.lineHeight;\r\n                    if (\"error\" === d.chartType) {\r\n                        this.ctx.strokeStyle = r[0];\r\n                        v = s / 8;\r\n                        this.ctx.lineWidth =\r\n                            v;\r\n                        this.ctx.beginPath();\r\n                        var v = q - 0.08 * this.lineHeight + 0.1 * this.lineHeight, B = u + 0.15 * this.lineHeight, A = 0.7 * this.lineHeight, C = A + 0.02 * this.lineHeight;\r\n                        this.ctx.moveTo(v, B);\r\n                        this.ctx.lineTo(v + A, B);\r\n                        this.ctx.stroke();\r\n                        this.ctx.beginPath();\r\n                        this.ctx.moveTo(v + A / 2, B);\r\n                        this.ctx.lineTo(v + A / 2, B + C);\r\n                        this.ctx.stroke();\r\n                        this.ctx.beginPath();\r\n                        this.ctx.moveTo(v, B + C);\r\n                        this.ctx.lineTo(v + A, B + C);\r\n                        this.ctx.stroke();\r\n                        r.shift();\r\n                    }\r\n                    ia.drawMarker(q + s / 2, u + this.lineHeight / 2, this.ctx, d.markerType, \"error\" === d.chartType || \"line\" === d.chartType ||\r\n                        \"spline\" === d.chartType ? d.markerSize / 2 : d.markerSize, d.markerColor, d.markerBorderColor, d.markerBorderThickness);\r\n                    d.textBlock.x = q + l + s;\r\n                    if (\"line\" === d.chartType || \"stepLine\" === d.chartType || \"spline\" === d.chartType)\r\n                        d.textBlock.x += 0.1 * this.lineHeight;\r\n                    d.textBlock.y = Math.round(u + this.lineHeight / 2);\r\n                    d.textBlock.render(!0);\r\n                    this.ctx.restore();\r\n                    x = 0 < z ? Math.max(x, d.textBlock.height) : d.textBlock.height;\r\n                    this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);\r\n                    v = S(d.id);\r\n                    this.ghostCtx.fillStyle = v;\r\n                    this.ghostCtx.beginPath();\r\n                    this.ghostCtx.fillRect(m, d.textBlock.y - this.lineHeight / 2, d.textBlock.x + d.textBlock.width - m, d.textBlock.height);\r\n                    d.x1 = this.chart._eventManager.objectMap[d.id].x1 = m;\r\n                    d.y1 = this.chart._eventManager.objectMap[d.id].y1 = d.textBlock.y - this.lineHeight / 2;\r\n                    d.x2 = this.chart._eventManager.objectMap[d.id].x2 = d.textBlock.x + d.textBlock.width;\r\n                    d.y2 = this.chart._eventManager.objectMap[d.id].y2 = d.textBlock.y + d.textBlock.height - this.lineHeight / 2;\r\n                }\r\n                f += x;\r\n            }\r\n            0 < t.length && a.layoutManager.registerSpace(b, { width: this.width + 2 + 2, height: this.height +\r\n                    5 + 5 });\r\n            this.bounds = { x1: e, y1: c, x2: e + this.width, y2: c + this.height };\r\n        };\r\n        oa(R, Y);\r\n        R.prototype.getDefaultAxisPlacement = function () {\r\n            var a = this.type;\r\n            if (\"column\" === a || \"line\" === a || \"stepLine\" === a || \"spline\" === a || \"area\" === a || \"stepArea\" === a || \"splineArea\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedArea\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stackedArea100\" === a || \"candlestick\" === a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" ===\r\n                a || \"waterfall\" === a)\r\n                return \"normal\";\r\n            if (\"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"rangeBar\" === a)\r\n                return \"xySwapped\";\r\n            if (\"pie\" === a || \"doughnut\" === a || \"funnel\" === a || \"pyramid\" === a)\r\n                return \"none\";\r\n            \"error\" !== a && window.console.log(\"Unknown Chart Type: \" + a);\r\n            return null;\r\n        };\r\n        R.getDefaultLegendMarker = function (a) {\r\n            if (\"column\" === a || \"stackedColumn\" === a || \"stackedLine\" === a || \"bar\" === a || \"stackedBar\" === a || \"stackedBar100\" === a || \"bubble\" === a || \"scatter\" === a || \"stackedColumn100\" === a || \"stackedLine100\" === a || \"stepArea\" === a || \"candlestick\" ===\r\n                a || \"ohlc\" === a || \"rangeColumn\" === a || \"rangeBar\" === a || \"rangeArea\" === a || \"rangeSplineArea\" === a || \"boxAndWhisker\" === a || \"waterfall\" === a)\r\n                return \"square\";\r\n            if (\"line\" === a || \"stepLine\" === a || \"spline\" === a || \"pie\" === a || \"doughnut\" === a)\r\n                return \"circle\";\r\n            if (\"area\" === a || \"splineArea\" === a || \"stackedArea\" === a || \"stackedArea100\" === a || \"funnel\" === a || \"pyramid\" === a)\r\n                return \"triangle\";\r\n            if (\"error\" === a)\r\n                return \"none\";\r\n            window.console.log(\"Unknown Chart Type: \" + a);\r\n            return null;\r\n        };\r\n        R.prototype.getDataPointAtX = function (a, f) {\r\n            if (!this.dataPoints || 0 === this.dataPoints.length)\r\n                return null;\r\n            var b = { dataPoint: null, distance: Infinity, index: NaN }, c = null, e = 0, g = 0, h = 1, l = Infinity, t = 0, k = 0, r = 0;\r\n            \"none\" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (r = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), r = 1 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (r = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, r = 0 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * (a - this.dataPoints[0].x) >>\r\n                0, 0), this.dataPoints.length) : 0));\r\n            for (;;) {\r\n                g = 0 < h ? r + e : r - e;\r\n                if (0 <= g && g < this.dataPoints.length) {\r\n                    var c = this.dataPoints[g], p = this.axisX.logarithmic ? c.x > a ? c.x / a : a / c.x : Math.abs(c.x - a);\r\n                    p < b.distance && (b.dataPoint = c, b.distance = p, b.index = g);\r\n                    c = p;\r\n                    c <= l ? l = c : 0 < h ? t++ : k++;\r\n                    if (1E3 < t && 1E3 < k)\r\n                        break;\r\n                }\r\n                else if (0 > r - e && r + e >= this.dataPoints.length)\r\n                    break;\r\n                -1 === h ? (e++, h = 1) : h = -1;\r\n            }\r\n            return f || b.dataPoint.x !== a ? f && null !== b.dataPoint ? b : null : b;\r\n        };\r\n        R.prototype.getDataPointAtXY = function (a, f, b) {\r\n            if (!this.dataPoints || 0 === this.dataPoints.length || a <\r\n                this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || f < this.chart.plotArea.y1 || f > this.chart.plotArea.y2)\r\n                return null;\r\n            b = b || !1;\r\n            var c = [], e = 0, g = 0, h = 1, l = !1, t = Infinity, k = 0, r = 0, p = 0;\r\n            if (\"none\" !== this.chart.plotInfo.axisPlacement)\r\n                if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a, y: f }), this.axisX.logarithmic)\r\n                    var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), p = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(p / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;\r\n                else\r\n                    n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;\r\n            for (;;) {\r\n                g = 0 < h ? p + e : p - e;\r\n                if (0 <= g && g < this.dataPoints.length) {\r\n                    var n = this.chart._eventManager.objectMap[this.dataPointIds[g]], d = this.dataPoints[g], m = null;\r\n                    if (n) {\r\n                        switch (this.type) {\r\n                            case \"column\":\r\n                            case \"stackedColumn\":\r\n                            case \"stackedColumn100\":\r\n                            case \"bar\":\r\n                            case \"stackedBar\":\r\n                            case \"stackedBar100\":\r\n                            case \"rangeColumn\":\r\n                            case \"rangeBar\":\r\n                            case \"waterfall\":\r\n                            case \"error\":\r\n                                a >=\r\n                                    n.x1 && (a <= n.x2 && f >= n.y1 && f <= n.y2) && (c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y1 - f), Math.abs(n.y2 - f)) }), l = !0);\r\n                                break;\r\n                            case \"line\":\r\n                            case \"stepLine\":\r\n                            case \"spline\":\r\n                            case \"area\":\r\n                            case \"stepArea\":\r\n                            case \"stackedArea\":\r\n                            case \"stackedArea100\":\r\n                            case \"splineArea\":\r\n                            case \"scatter\":\r\n                                var q = ma(\"markerSize\", d, this) || 4, s = b ? 20 : q, m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));\r\n                                m <= s && c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: m });\r\n                                n =\r\n                                    Math.abs(n.x1 - a);\r\n                                n <= t ? t = n : 0 < h ? k++ : r++;\r\n                                m <= q / 2 && (l = !0);\r\n                                break;\r\n                            case \"rangeArea\":\r\n                            case \"rangeSplineArea\":\r\n                                q = ma(\"markerSize\", d, this) || 4;\r\n                                s = b ? 20 : q;\r\n                                m = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - f, 2)));\r\n                                m <= s && c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: m });\r\n                                n = Math.abs(n.x1 - a);\r\n                                n <= t ? t = n : 0 < h ? k++ : r++;\r\n                                m <= q / 2 && (l = !0);\r\n                                break;\r\n                            case \"bubble\":\r\n                                q = n.size;\r\n                                m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));\r\n                                m <= q / 2 && (c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this,\r\n                                    distance: m }), l = !0);\r\n                                break;\r\n                            case \"pie\":\r\n                            case \"doughnut\":\r\n                                q = n.center;\r\n                                s = \"doughnut\" === this.type ? n.percentInnerRadius * n.radius : 0;\r\n                                m = Math.sqrt(Math.pow(q.x - a, 2) + Math.pow(q.y - f, 2));\r\n                                m < n.radius && m > s && (m = Math.atan2(f - q.y, a - q.x), 0 > m && (m += 2 * Math.PI), m = Number(((180 * (m / Math.PI) % 360 + 360) % 360).toFixed(12)), q = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), s = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === s && 1 < n.endAngle && (s = 360), q >= s && 0 !== d.y && (s += 360, m < q && (m += 360)), m > q && m < s && (c.push({ dataPoint: d,\r\n                                    dataPointIndex: g, dataSeries: this, distance: 0 }), l = !0));\r\n                                break;\r\n                            case \"funnel\":\r\n                            case \"pyramid\":\r\n                                m = n.funnelSection;\r\n                                f > m.y1 && f < m.y4 && (m.y6 ? f > m.y6 ? (g = m.x6 + (m.x5 - m.x6) / (m.y5 - m.y6) * (f - m.y6), m = m.x3 + (m.x4 - m.x3) / (m.y4 - m.y3) * (f - m.y3)) : (g = m.x1 + (m.x6 - m.x1) / (m.y6 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)) : (g = m.x1 + (m.x4 - m.x1) / (m.y4 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)), a > g && a < m && (c.push({ dataPoint: d, dataPointIndex: n.dataPointIndex, dataSeries: this, distance: 0 }), l = !0));\r\n                                break;\r\n                            case \"boxAndWhisker\":\r\n                                if (a >=\r\n                                    n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y1 && f <= n.y4)\r\n                                    c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;\r\n                                break;\r\n                            case \"candlestick\":\r\n                                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y2 - n.borderThickness / 2 && f <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness &&\r\n                                    f >= n.y1 && f <= n.y4)\r\n                                    c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;\r\n                                break;\r\n                            case \"ohlc\": if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y2 && f <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && f >= n.y1 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y4 + n.borderThickness / 2)\r\n                                c.push({ dataPoint: d, dataPointIndex: g, dataSeries: this, distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f)) }), l = !0;\r\n                        }\r\n                        if (l || 1E3 < k && 1E3 < r)\r\n                            break;\r\n                    }\r\n                }\r\n                else if (0 > p - e && p + e >= this.dataPoints.length)\r\n                    break;\r\n                -1 === h ? (e++, h = 1) : h = -1;\r\n            }\r\n            a = null;\r\n            for (f = 0; f < c.length; f++)\r\n                a ? c[f].distance <= a.distance && (a = c[f]) : a = c[f];\r\n            return a;\r\n        };\r\n        R.prototype.getMarkerProperties = function (a, f, b, c) {\r\n            var e = this.dataPoints;\r\n            return { x: f, y: b, ctx: c, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor :\r\n                    e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null };\r\n        };\r\n        oa(C, Y);\r\n        C.prototype.createExtraLabelsForLog = function (a) {\r\n            a = (a || 0) + 1;\r\n            if (!(5 < a)) {\r\n                var f = this.logLabelValues[0] || this.intervalStartPosition;\r\n                if (Math.log(this.range) / Math.log(f / this.viewportMinimum) <\r\n                    this.noTicks - 1) {\r\n                    for (var b = C.getNiceNumber((f - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), c = Math.ceil(this.viewportMinimum / b) * b; c < f; c += b)\r\n                        c < this.viewportMinimum || this.logLabelValues.push(c);\r\n                    this.logLabelValues.sort(Qa);\r\n                    this.createExtraLabelsForLog(a);\r\n                }\r\n            }\r\n        };\r\n        C.prototype.createLabels = function () {\r\n            var a, f, b = 0, c = 0, e, g = 0, h = 0, c = 0, c = this.interval, l = 0, t, k = 0.6 * this.chart.height, m;\r\n            a = !1;\r\n            var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], n = p.length ? y(this.scaleBreaks.firstBreakIndex) ?\r\n                0 : this.scaleBreaks.firstBreakIndex : 0;\r\n            if (\"axisX\" !== this.type || \"dateTime\" !== this.valueType || this.logarithmic) {\r\n                e = this.viewportMaximum;\r\n                if (this.labels) {\r\n                    a = Math.ceil(c);\r\n                    for (var c = Math.ceil(this.intervalStartPosition), d = !1, b = c; b < this.viewportMaximum; b += a)\r\n                        if (this.labels[b])\r\n                            d = !0;\r\n                        else {\r\n                            d = !1;\r\n                            break;\r\n                        }\r\n                    d && (this.interval = a, this.intervalStartPosition = c);\r\n                }\r\n                if (this.logarithmic && !this.equidistantInterval)\r\n                    for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, d = n; c < this.logLabelValues.length; c++)\r\n                        if (b =\r\n                            this.logLabelValues[c], b < this.viewportMinimum)\r\n                            c++;\r\n                        else {\r\n                            for (; d < p.length && b > p[d].endValue; d++)\r\n                                ;\r\n                            a = d < p.length && b >= p[d].startValue && b <= p[d].endValue;\r\n                            m = b;\r\n                            a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ? this.labels[m] : X(m, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, backgroundColor: this.labelBackgroundColor,\r\n                                borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\", borderThickness: 0 }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));\r\n                        }\r\n                d = n;\r\n                for (b = this.intervalStartPosition; b <= e; b = parseFloat(1E-12 > this.interval ? this.logarithmic && this.equidistantInterval ?\r\n                    b * Math.pow(this.logarithmBase, this.interval) : b + this.interval : (this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {\r\n                    for (; d < p.length && b > p[d].endValue; d++)\r\n                        ;\r\n                    a = d < p.length && b >= p[d].startValue && b <= p[d].endValue;\r\n                    m = b;\r\n                    a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ? this.labels[m] : X(m, this.valueFormatString, this.chart._cultureInfo),\r\n                        a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: \"left\", backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }), this._labels.push({ position: m, textBlock: a, effectiveHeight: null }));\r\n                }\r\n            }\r\n            else\r\n                for (this.intervalStartPosition =\r\n                    this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = Ua(new Date(this.viewportMaximum), this.interval, this.intervalType), d = n, b = this.intervalStartPosition; b < e; Ua(b, c, this.intervalType)) {\r\n                    for (a = b.getTime(); d < p.length && a > p[d].endValue; d++)\r\n                        ;\r\n                    m = a;\r\n                    a = d < p.length && a >= p[d].startValue && a <= p[d].endValue;\r\n                    a || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: new Date(m), label: this.labels[m] ? this.labels[m] : null }) : \"axisX\" === this.type && this.labels[m] ?\r\n                        this.labels[m] : Ba(m, this.valueFormatString, this.chart._cultureInfo), a = new ka(this.ctx, { x: 0, y: 0, maxWidth: g, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxHeight: h, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" }),\r\n                        this._labels.push({ position: m, textBlock: a, effectiveHeight: null, breaksLabelType: void 0 }));\r\n                }\r\n            if (\"bottom\" === this._position || \"top\" === this._position)\r\n                l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) /\r\n                    Math.log(this.logarithmBase) : Math.abs(this.range)) * V[this.intervalType + \"Duration\"] * this.interval, g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);\r\n            else if (\"left\" === this._position || \"right\" === this._position)\r\n                l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length -\r\n                    1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * V[this.intervalType + \"Duration\"] * this.interval, this.chart.panEnabled || (g = \"undefined\" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ?\r\n                    0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\r\n            for (c = 0; c < this._labels.length; c++) {\r\n                a = this._labels[c].textBlock;\r\n                a.maxWidth = g;\r\n                a.maxHeight = h;\r\n                var q = a.measureText();\r\n                t = q.height;\r\n            }\r\n            e = [];\r\n            n = p = 0;\r\n            if (this.labelAutoFit || this.options.labelAutoFit)\r\n                if (y(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), \"bottom\" === this._position || \"top\" === this._position)\r\n                    if (g = 0.9 * l >> 0, n = 0, !this.chart.panEnabled &&\r\n                        1 <= this._labels.length) {\r\n                        this.sessionVariables.labelFontSize = this.labelFontSize;\r\n                        this.sessionVariables.labelMaxWidth = g;\r\n                        this.sessionVariables.labelMaxHeight = h;\r\n                        this.sessionVariables.labelAngle = this.labelAngle;\r\n                        this.sessionVariables.labelWrap = this.labelWrap;\r\n                        for (b = 0; b < this._labels.length; b++)\r\n                            if (!this._labels[b].breaksLabelType) {\r\n                                a = this._labels[b].textBlock;\r\n                                for (var s, d = a.text.split(\" \"), c = 0; c < d.length; c++)\r\n                                    m = d[c], this.ctx.font = a.fontStyle + \" \" + a.fontWeight + \" \" + a.fontSize + \"px \" + a.fontFamily, m = this.ctx.measureText(m),\r\n                                        m.width > n && (s = b, n = m.width);\r\n                            }\r\n                        b = 0;\r\n                        for (b = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; b < this._labels.length; b++)\r\n                            if (!this._labels[b].breaksLabelType) {\r\n                                a = this._labels[b].textBlock;\r\n                                q = a.measureText();\r\n                                for (d = b + 1; d < this._labels.length; d++)\r\n                                    if (!this._labels[d].breaksLabelType) {\r\n                                        f = this._labels[d].textBlock;\r\n                                        f = f.measureText();\r\n                                        break;\r\n                                    }\r\n                                e.push(a.height);\r\n                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);\r\n                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                c = g * Math.sin(Math.PI /\r\n                                    180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                if (y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)\r\n                                    if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !y(this.options.labelWrap))\r\n                                        this.labelWrap ? y(this.options.labelMaxWidth) ?\r\n                                            (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), this.sessionVariables.labelWrap = this.labelWrap, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight =\r\n                                            h, this.sessionVariables.labelMaxWidth = g, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = this.labelWrap);\r\n                                    else {\r\n                                        if (y(this.options.labelWrap))\r\n                                            if (!y(this.options.labelMaxWidth))\r\n                                                this.options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth =\r\n                                                    this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h);\r\n                                            else if (!y(f))\r\n                                                if (c = q.width + f.width >> 0, d = this.labelFontSize, n < g)\r\n                                                    c - 2 * g > p && (p = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize,\r\n                                                        this.sessionVariables.labelAngle = this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = d) : c >= 2.8 * g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize,\r\n                                                        this.sessionVariables.labelAngle = this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth =\r\n                                                        m) : c > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = d, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = this.labelAngle));\r\n                                                else if (s === b && (0 === s && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p || s === this._labels.length - 1 && n + this._labels[s - 1].textBlock.measureText().width - 2 * g > p || 0 < s && s < this._labels.length - 1 && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p && n + this._labels[s - 1].textBlock.measureText().width -\r\n                                                    2 * g > p))\r\n                                                    p = 0 === s ? n + this._labels[s + 1].textBlock.measureText().width - 2 * g : n + this._labels[s - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m;\r\n                                                else if (0 === p)\r\n                                                    for (this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, c = 0; c < this._labels.length; c++)\r\n                                                        a =\r\n                                                            this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), q = a.measureText(), c < this._labels.length - 1 && (d = c + 1, f = this._labels[d].textBlock, f.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), f = f.measureText(), q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25));\r\n                                    }\r\n                                else\r\n                                    (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) /\r\n                                        Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = 0 != this.labelAngle ? (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = h = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, y(this.options.labelWrap)) ? y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap =\r\n                                        this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = c < 0.9 * l ? 0.9 * l : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) :\r\n                                        (y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = h);\r\n                            }\r\n                        for (c = 0; c < this._labels.length; c++)\r\n                            a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight =\r\n                                this.sessionVariables.labelMaxHeight, a.measureText();\r\n                    }\r\n                    else\r\n                        for (b = 0; b < this._labels.length; b++)\r\n                            a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ?\r\n                                this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\r\n                else if (\"left\" === this._position || \"right\" === this._position)\r\n                    if (g = y(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, h = \"undefined\" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {\r\n                        this.sessionVariables.labelFontSize = this.labelFontSize;\r\n                        this.sessionVariables.labelMaxWidth =\r\n                            g;\r\n                        this.sessionVariables.labelMaxHeight = h;\r\n                        this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;\r\n                        this.sessionVariables.labelWrap = this.labelWrap;\r\n                        for (b = 0; b < this._labels.length; b++)\r\n                            if (!this._labels[b].breaksLabelType) {\r\n                                a = this._labels[b].textBlock;\r\n                                q = a.measureText();\r\n                                for (d = b + 1; d < this._labels.length; d++)\r\n                                    if (!this._labels[d].breaksLabelType) {\r\n                                        f = this._labels[d].textBlock;\r\n                                        f = f.measureText();\r\n                                        break;\r\n                                    }\r\n                                e.push(a.height);\r\n                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);\r\n                                c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                                y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? y(this.options.labelWrap) ? y(this.options.labelWrap) && (y(this.options.labelMaxWidth) ? y(f) || (l = q.height + f.height >> 0, l - 2 * h > n && (n = l - 2 * h, l >= 2 * h && l < 2.4 * h ? (y(this.options.labelFontSize) && 12 < this.labelFontSize &&\r\n                                    (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : l >= 2.4 * h && l < 2.8 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : l >= 2.8 * h && l < 3.2 * h ? (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 <\r\n                                    this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * h && l < 3.6 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * h && l < 10 * h ? (y(this.options.labelFontSize) &&\r\n                                    12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * h && l < 50 * h && (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize),\r\n                                    a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth =\r\n                                    this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), h), y(this.options.labelWrap)) ?\r\n                                    y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, y(this.options.labelMaxWidth) &&\r\n                                        (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = h, y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);\r\n                            }\r\n                        for (c = 0; c < this._labels.length; c++)\r\n                            a =\r\n                                this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\r\n                    }\r\n                    else\r\n                        for (b = 0; b < this._labels.length; b++)\r\n                            a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth,\r\n                                a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();\r\n            for (b = 0; b < this.stripLines.length; b++) {\r\n                var g = this.stripLines[b], x;\r\n                if (\"outside\" === g.labelPlacement) {\r\n                    h = this.sessionVariables.labelMaxWidth;\r\n                    if (\"bottom\" === this._position || \"top\" === this._position)\r\n                        x = y(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;\r\n                    if (\"left\" === this._position || \"right\" === this._position)\r\n                        x = y(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;\r\n                    y(g.labelBackgroundColor) && (g.labelBackgroundColor = \"#EEEEEE\");\r\n                }\r\n                else\r\n                    h = \"bottom\" === this._position || \"top\" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >>\r\n                        0, x = y(g.options.labelWrap) || g.labelWrap ? \"bottom\" === this._position || \"top\" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, y(g.labelBackgroundColor) && (y(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor = v ? \"transparent\" : null : g.labelBackgroundColor = \"#EEEEEE\");\r\n                a = new ka(this.ctx, { x: 0, y: 0, backgroundColor: g.labelBackgroundColor, borderColor: g.labelBorderColor, borderThickness: g.labelBorderThickness, cornerRadius: g.labelCornerRadius, maxWidth: g.options.labelMaxWidth ?\r\n                        g.options.labelMaxWidth : h, maxHeight: x, angle: this.labelAngle, text: g.labelFormatter ? g.labelFormatter({ chart: this.chart, axis: this, stripLine: g }) : g.label, horizontalAlign: \"left\", fontSize: \"outside\" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize : this.labelFontSize : g.labelFontSize, fontFamily: \"outside\" === g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily, fontWeight: \"outside\" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight :\r\n                        g.labelFontWeight, fontColor: g.labelFontColor || g.color, fontStyle: \"outside\" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle, textBaseline: \"middle\" });\r\n                this._stripLineLabels.push({ position: g.value, textBlock: a, effectiveHeight: null, stripLine: g });\r\n            }\r\n        };\r\n        C.prototype.createLabelsAndCalculateWidth = function () {\r\n            var a = 0, f = 0;\r\n            this._labels = [];\r\n            this._stripLineLabels = [];\r\n            if (\"left\" === this._position || \"right\" === this._position) {\r\n                this.createLabels();\r\n                for (f = 0; f < this._labels.length; f++) {\r\n                    var b = this._labels[f].textBlock, c = b.measureText(), e = 0, e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                    a < e && (a = e);\r\n                    this._labels[f].effectiveWidth = e;\r\n                }\r\n                for (f = 0; f < this._stripLineLabels.length; f++)\r\n                    \"outside\" === this._stripLineLabels[f].stripLine.labelPlacement && (this._stripLineLabels[f].stripLine.value >= this.viewportMinimum && this._stripLineLabels[f].stripLine.value <= this.viewportMaximum) && (b = this._stripLineLabels[f].textBlock,\r\n                        c = b.measureText(), e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[f].effectiveWidth = e);\r\n            }\r\n            f = this.title ? this._titleTextBlock.measureText().height + 2 : 0;\r\n            return b = \"inside\" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5;\r\n        };\r\n        C.prototype.createLabelsAndCalculateHeight = function () {\r\n            var a = 0;\r\n            this._labels = [];\r\n            this._stripLineLabels = [];\r\n            var f, b = 0;\r\n            this.createLabels();\r\n            if (\"bottom\" ===\r\n                this._position || \"top\" === this._position) {\r\n                for (b = 0; b < this._labels.length; b++) {\r\n                    f = this._labels[b].textBlock;\r\n                    var c = f.measureText(), e = 0, e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));\r\n                    a < e && (a = e);\r\n                    this._labels[b].effectiveHeight = e;\r\n                }\r\n                for (b = 0; b < this._stripLineLabels.length; b++)\r\n                    \"outside\" === this._stripLineLabels[b].stripLine.labelPlacement && (this._stripLineLabels[b].stripLine.value >= this.viewportMinimum &&\r\n                        this._stripLineLabels[b].stripLine.value <= this.viewportMaximum) && (f = this._stripLineLabels[b].textBlock, c = f.measureText(), e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[b].effectiveHeight = e);\r\n            }\r\n            f = this.title ? this._titleTextBlock.measureText().height + 2 : 0;\r\n            return b = \"inside\" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5;\r\n        };\r\n        C.setLayoutAndRender = function (a, f, b, c, e, g) {\r\n            var h, l, t, k, m = a[0] ? a[0].chart : f[0].chart, p = m.ctx, n = m._axes;\r\n            if (a && 0 < a.length)\r\n                for (var d = 0; d < a.length; d++)\r\n                    a[d] && a[d].calculateAxisParameters();\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].calculateAxisParameters();\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].calculateAxisParameters();\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].calculateAxisParameters();\r\n            for (d = 0; d < n.length; d++)\r\n                if (n[d] && n[d].scaleBreaks && n[d].scaleBreaks._appliedBreaks.length)\r\n                    for (var q = n[d].scaleBreaks._appliedBreaks, s = 0; s < q.length &&\r\n                        !(q[s].startValue > n[d].viewportMaximum); s++)\r\n                        q[s].endValue < n[d].viewportMinimum || (y(n[d].scaleBreaks.firstBreakIndex) && (n[d].scaleBreaks.firstBreakIndex = s), q[s].startValue >= n[d].viewPortMinimum && (n[d].scaleBreaks.lastBreakIndex = s));\r\n            for (var x = s = 0, u = 0, z = 0, C = 0, G = 0, B = 0, A, I, M = l = 0, K, J, O, q = K = J = O = !1, d = 0; d < n.length; d++)\r\n                n[d] && n[d].title && (n[d]._titleTextBlock = new ka(n[d].ctx, { text: n[d].title, horizontalAlign: \"center\", fontSize: n[d].titleFontSize, fontFamily: n[d].titleFontFamily, fontWeight: n[d].titleFontWeight,\r\n                    fontColor: n[d].titleFontColor, fontStyle: n[d].titleFontStyle, borderColor: n[d].titleBorderColor, borderThickness: n[d].titleBorderThickness, backgroundColor: n[d].titleBackgroundColor, cornerRadius: n[d].titleCornerRadius, textBaseline: \"top\" }));\r\n            for (d = 0; d < n.length; d++)\r\n                if (n[d].title)\r\n                    switch (n[d]._position) {\r\n                        case \"left\":\r\n                            n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.height;\r\n                            n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.width : 1.5 * n[d].titleFontSize;\r\n                            n[d]._titleTextBlock.angle = -90;\r\n                            break;\r\n                        case \"right\":\r\n                            n[d]._titleTextBlock.maxWidth =\r\n                                n[d].titleMaxWidth || g.height;\r\n                            n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.width : 1.5 * n[d].titleFontSize;\r\n                            n[d]._titleTextBlock.angle = 90;\r\n                            break;\r\n                        default: n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.width, n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.height : 1.5 * n[d].titleFontSize, n[d]._titleTextBlock.angle = 0;\r\n                    }\r\n            if (\"normal\" === e) {\r\n                for (var z = [], C = [], G = [], B = [], P = [], Q = [], S = [], R = []; 4 > s;) {\r\n                    var E = 0, U = 0, V = 0, Y = 0, W = e = 0, L = 0, $ = 0, Z = 0, X = 0, N = 0, ba = 0;\r\n                    if (b && 0 < b.length)\r\n                        for (G = [], d = N = 0; d < b.length; d++)\r\n                            G.push(Math.ceil(b[d] ?\r\n                                b[d].createLabelsAndCalculateWidth() : 0)), N += G[d], L += b[d] ? b[d].margin : 0;\r\n                    else\r\n                        G.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));\r\n                    S.push(G);\r\n                    if (c && 0 < c.length)\r\n                        for (B = [], d = ba = 0; d < c.length; d++)\r\n                            B.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateWidth() : 0)), ba += B[d], $ += c[d] ? c[d].margin : 0;\r\n                    else\r\n                        B.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));\r\n                    R.push(B);\r\n                    h = Math.round(g.x1 + N + L);\r\n                    t = Math.round(g.x2 - ba - $ > m.width - 10 ? m.width - 10 : g.x2 - ba - $);\r\n                    if (a && 0 < a.length)\r\n                        for (z = [], d = Z = 0; d < a.length; d++)\r\n                            a[d] &&\r\n                                (a[d].lineCoordinates = {}), a[d].lineCoordinates.width = Math.abs(t - h), a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.width ? a[d].titleMaxWidth : a[d].lineCoordinates.width), z.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateHeight() : 0)), Z += z[d], e += a[d] ? a[d].margin : 0;\r\n                    else\r\n                        z.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));\r\n                    P.push(z);\r\n                    if (f && 0 < f.length)\r\n                        for (C = [], d = X = 0; d < f.length; d++)\r\n                            f[d] && (f[d].lineCoordinates = {}), f[d].lineCoordinates.width =\r\n                                Math.abs(t - h), f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth && f[d].titleMaxWidth < f[d].lineCoordinates.width ? f[d].titleMaxWidth : f[d].lineCoordinates.width), C.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateHeight() : 0)), X += C[d], W += f[d] ? f[d].margin : 0;\r\n                    else\r\n                        C.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateHeight() : 0));\r\n                    Q.push(C);\r\n                    if (a && 0 < a.length)\r\n                        for (d = 0; d < a.length; d++)\r\n                            a[d] && (a[d].lineCoordinates.x1 = h, t = Math.round(g.x2 - ba - $ > m.width - 10 ? m.width - 10 : g.x2 - ba - $), a[d]._labels && 1 < a[d]._labels.length &&\r\n                                (l = k = 0, k = a[d]._labels[1], l = \"dateTime\" === a[d].valueType ? a[d]._labels[a[d]._labels.length - 2] : a[d]._labels[a[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), a[d] && (a[d].labelAutoFit && !y(A) && !y(I)) && (l = 0,\r\n                                0 < a[d].labelAngle ? I + u > t && (l += 0 < a[d].labelAngle ? I + u - t - ba : 0) : 0 > a[d].labelAngle ? A - x < h && A - x < a[d].viewportMinimum && (M = h - (L + a[d].tickLength + G + A - x + a[d].labelFontSize / 2)) : 0 === a[d].labelAngle && (I + u > t && (l = I + u / 2 - t - ba), A - x < h && A - x < a[d].viewportMinimum && (M = h - L - a[d].tickLength - G - A + x / 2)), a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 < a[d].labelAngle && 0 < l ? t -= l : a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 > a[d].labelAngle && 0 < M ? h += M : a[d].viewportMaximum === a[d].maximum &&\r\n                                a[d].viewportMinimum === a[d].minimum && 0 === a[d].labelAngle && (0 < M && (h += M), 0 < l && (t -= l))), m.panEnabled ? Z = m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = Z, l = Math.round(g.y2 - Z - e + E), k = Math.round(g.y2), a[d].lineCoordinates.x2 = t, a[d].lineCoordinates.width = t - h, a[d].lineCoordinates.y1 = l, a[d].lineCoordinates.y2 = l, a[d].bounds = { x1: h, y1: l, x2: t, y2: k - (Z + e - z[d] - E), width: t - h, height: k - l }), E += z[d] + a[d].margin;\r\n                    if (f && 0 < f.length)\r\n                        for (d = 0; d < f.length; d++)\r\n                            f[d].lineCoordinates.x1 = Math.round(g.x1 + N + L), f[d].lineCoordinates.x2 =\r\n                                Math.round(g.x2 - ba - $ > m.width - 10 ? m.width - 10 : g.x2 - ba - $), f[d].lineCoordinates.width = Math.abs(t - h), f[d]._labels && 1 < f[d]._labels.length && (k = f[d]._labels[1], l = \"dateTime\" === f[d].valueType ? f[d]._labels[f[d]._labels.length - 2] : f[d]._labels[f[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height -\r\n                                l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), m.panEnabled ? X = m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = X, l = Math.round(g.y1), k = Math.round(g.y2 + f[d].margin), f[d].lineCoordinates.y1 = l + X + W - U, f[d].lineCoordinates.y2 = l, f[d].bounds = { x1: h, y1: l + (X + W - C[d] - U), x2: t, y2: k, width: t - h, height: k - l }, U += C[d] + f[d].margin;\r\n                    if (b && 0 < b.length)\r\n                        for (d = 0; d < b.length; d++)\r\n                            L = 10, b[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), L = b[d]._labels && 0 < b[d]._labels.length ?\r\n                                b[d]._labels[b[d]._labels.length - 1].textBlock.height / 2 : 10, l = Math.round(g.y1 + X + W < Math.max(L, 10) ? Math.max(L, 10) : g.y1 + X + W), t = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), L = 0 < a.length ? 0 : b[d]._labels && 0 < b[d]._labels.length ? b[d]._labels[0].textBlock.height / 2 : 10, k = Math.round(g.y2 - Z - e - L), b[d].lineCoordinates = { x1: t - V, y1: l, x2: t - V, y2: k, height: Math.abs(k - l) }, b[d].bounds = { x1: h - (G[d] + V), y1: l, x2: t, y2: k, width: t - h, height: k - l }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth <\r\n                                b[d].lineCoordinates.height ? b[d].titleMaxWidth : b[d].lineCoordinates.height), V += G[d] + b[d].margin);\r\n                    if (c && 0 < c.length)\r\n                        for (d = 0; d < c.length; d++)\r\n                            c[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x2 : f[0].lineCoordinates.x2), t = Math.round(h), L = c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[c[d]._labels.length - 1].textBlock.height / 2 : 0, l = Math.round(g.y1 + X + W < Math.max(L, 10) ? Math.max(L, 10) : g.y1 + X + W), L = 0 < a.length ? 0 : c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[0].textBlock.height / 2 : 0, k = Math.round(g.y2 - (Z + e + L)), c[d].lineCoordinates =\r\n                                { x1: h + Y, y1: l, x2: h + Y, y2: k, height: Math.abs(k - l) }, c[d].bounds = { x1: h, y1: l, x2: t + (B[d] + Y), y2: k, width: t - h, height: k - l }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.height ? c[d].titleMaxWidth : c[d].lineCoordinates.height), Y += B[d] + c[d].margin);\r\n                    if (a && 0 < a.length)\r\n                        for (d = 0; d < a.length; d++)\r\n                            a[d] && (a[d].calculateValueToPixelConversionParameters(), a[d].calculateBreaksSizeInValues(), a[d]._labels && 1 < a[d]._labels.length && (A = (a[d].logarithmic ? Math.log(a[d]._labels[1].position /\r\n                                a[d].viewportMinimum) / a[d].conversionParameters.lnLogarithmBase : a[d]._labels[1].position - a[d].viewportMinimum) * Math.abs(a[d].conversionParameters.pixelPerUnit) + a[d].lineCoordinates.x1, h = a[d]._labels[a[d]._labels.length - (\"dateTime\" === a[d].valueType ? 2 : 1)].position, h = a[d].getApparentDifference(a[d].viewportMinimum, h), I = a[d].logarithmic ? (1 < h ? Math.log(h) / a[d].conversionParameters.lnLogarithmBase * Math.abs(a[d].conversionParameters.pixelPerUnit) : 0) + a[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(a[d].conversionParameters.pixelPerUnit) :\r\n                                0) + a[d].lineCoordinates.x1));\r\n                    if (f && 0 < f.length)\r\n                        for (d = 0; d < f.length; d++)\r\n                            f[d].calculateValueToPixelConversionParameters(), f[d].calculateBreaksSizeInValues(), f[d]._labels && 1 < f[d]._labels.length && (A = (f[d].logarithmic ? Math.log(f[d]._labels[1].position / f[d].viewportMinimum) / f[d].conversionParameters.lnLogarithmBase : f[d]._labels[1].position - f[d].viewportMinimum) * Math.abs(f[d].conversionParameters.pixelPerUnit) + f[d].lineCoordinates.x1, h = f[d]._labels[f[d]._labels.length - (\"dateTime\" === f[d].valueType ? 2 : 1)].position,\r\n                                h = f[d].getApparentDifference(f[d].viewportMinimum, h), I = f[d].logarithmic ? (1 < h ? Math.log(h) / f[d].conversionParameters.lnLogarithmBase * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1);\r\n                    for (d = 0; d < n.length; d++)\r\n                        \"axisY\" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());\r\n                    if (0 < s) {\r\n                        if (a && 0 < a.length)\r\n                            for (d = 0; d < a.length; d++)\r\n                                q = P[s - 1][d] === P[s][d] ? !0 : !1;\r\n                        else\r\n                            q =\r\n                                !0;\r\n                        if (f && 0 < f.length)\r\n                            for (d = 0; d < f.length; d++)\r\n                                K = Q[s - 1][d] === Q[s][d] ? !0 : !1;\r\n                        else\r\n                            K = !0;\r\n                        if (b && 0 < b.length)\r\n                            for (d = 0; d < b.length; d++)\r\n                                J = S[s - 1][d] === S[s][d] ? !0 : !1;\r\n                        else\r\n                            J = !0;\r\n                        if (c && 0 < c.length)\r\n                            for (d = 0; d < c.length; d++)\r\n                                O = R[s - 1][d] === R[s][d] ? !0 : !1;\r\n                        else\r\n                            O = !0;\r\n                    }\r\n                    if (q && K && J && O)\r\n                        break;\r\n                    s++;\r\n                }\r\n                p.save();\r\n                p.beginPath();\r\n                a[0] && p.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height);\r\n                f[0] && p.rect(5, f[f.length - 1].bounds.y1, f[0].chart.width - 10, f[0].bounds.height);\r\n                p.clip();\r\n                if (a && 0 < a.length)\r\n                    for (d = 0; d < a.length; d++)\r\n                        a[d].calculateStripLinesThicknessInValues(),\r\n                            a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();\r\n                if (f && 0 < f.length)\r\n                    for (d = 0; d < f.length; d++)\r\n                        f[d].calculateStripLinesThicknessInValues(), f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle();\r\n                p.restore();\r\n                if (b && 0 < b.length)\r\n                    for (d = 0; d < b.length; d++)\r\n                        b[d].calculateStripLinesThicknessInValues(), b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();\r\n                if (c && 0 < c.length)\r\n                    for (d = 0; d < c.length; d++)\r\n                        c[d].calculateStripLinesThicknessInValues(), c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle();\r\n            }\r\n            else {\r\n                A =\r\n                    [];\r\n                M = [];\r\n                x = [];\r\n                I = [];\r\n                u = [];\r\n                P = [];\r\n                Q = [];\r\n                for (S = []; 4 > s;) {\r\n                    X = Z = N = Y = $ = L = W = e = V = R = U = E = 0;\r\n                    if (a && 0 < a.length)\r\n                        for (x = [], d = Z = 0; d < a.length; d++)\r\n                            x.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateWidth() : 0)), Z += x[d], e += a[d] ? a[d].margin : 0;\r\n                    else\r\n                        x.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));\r\n                    Q.push(x);\r\n                    if (f && 0 < f.length)\r\n                        for (I = [], d = X = 0; d < f.length; d++)\r\n                            I.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateWidth() : 0)), X += I[d], W += f[d] ? f[d].margin : 0;\r\n                    else\r\n                        I.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateWidth() : 0));\r\n                    S.push(I);\r\n                    if (b && 0 < b.length)\r\n                        for (d = 0; d < b.length; d++)\r\n                            b[d].lineCoordinates = {}, h = Math.round(g.x1 + Z + e), t = Math.round(g.x2 - X - W > m.width - 10 ? m.width - 10 : g.x2 - X - W), b[d].labelAutoFit && !y(z) && (0 < !a.length && (h = 0 > b[d].labelAngle ? Math.max(h, z) : 0 === b[d].labelAngle ? Math.max(h, z / 2) : h), 0 < !f.length && (t = 0 < b[d].labelAngle ? t - C / 2 : 0 === b[d].labelAngle ? t - C / 2 : t)), b[d].lineCoordinates.x1 = h, b[d].lineCoordinates.x2 = t, b[d].lineCoordinates.width = Math.abs(t - h), b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth <\r\n                                b[d].lineCoordinates.width ? b[d].titleMaxWidth : b[d].lineCoordinates.width);\r\n                    if (c && 0 < c.length)\r\n                        for (d = 0; d < c.length; d++)\r\n                            c[d].lineCoordinates = {}, h = Math.round(g.x1 + Z + e), t = Math.round(g.x2 - X - W > c[d].chart.width - 10 ? c[d].chart.width - 10 : g.x2 - X - W), c[d] && c[d].labelAutoFit && !y(G) && (0 < !a.length && (h = 0 < c[d].labelAngle ? Math.max(h, G) : 0 === c[d].labelAngle ? Math.max(h, G / 2) : h), 0 < !f.length && (t -= B / 2)), c[d].lineCoordinates.x1 = h, c[d].lineCoordinates.x2 = t, c[d].lineCoordinates.width = Math.abs(t - h), c[d].title && (c[d]._titleTextBlock.maxWidth =\r\n                                0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width);\r\n                    if (b && 0 < b.length)\r\n                        for (A = [], d = Y = 0; d < b.length; d++)\r\n                            A.push(Math.ceil(b[d] ? b[d].createLabelsAndCalculateHeight() : 0)), Y += A[d] + b[d].margin, L += b[d].margin;\r\n                    else\r\n                        A.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));\r\n                    u.push(A);\r\n                    if (c && 0 < c.length)\r\n                        for (M = [], d = N = 0; d < c.length; d++)\r\n                            M.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateHeight() : 0)), N += M[d], $ += c[d].margin;\r\n                    else\r\n                        M.push(Math.ceil(c[0] ?\r\n                            c[0].createLabelsAndCalculateHeight() : 0));\r\n                    P.push(M);\r\n                    if (b && 0 < b.length)\r\n                        for (d = 0; d < b.length; d++)\r\n                            0 < b[d]._labels.length && (k = b[d]._labels[0], l = b[d]._labels[b[d]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), C = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\r\n                    if (c && 0 < c.length)\r\n                        for (d = 0; d < c.length; d++)\r\n                            c[d] && 0 < c[d]._labels.length && (k = c[d]._labels[0], l = c[d]._labels[c[d]._labels.length - 1], G = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), B = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));\r\n                    if (m.panEnabled)\r\n                        for (d = 0; d < b.length; d++)\r\n                            A[d] = m.sessionVariables.axisY.height;\r\n                    else\r\n                        for (d = 0; d < b.length; d++)\r\n                            m.sessionVariables.axisY.height = A[d];\r\n                    if (b && 0 < b.length)\r\n                        for (d = b.length - 1; 0 <= d; d--)\r\n                            l = Math.round(g.y2), k = Math.round(g.y2 > b[d].chart.height - 10 ? b[d].chart.height - 10 : g.y2), b[d].lineCoordinates.y1 = l - (A[d] + b[d].margin + E), b[d].lineCoordinates.y2 = l - (A[d] + b[d].margin + E), b[d].bounds = { x1: h, y1: l - (A[d] + E + b[d].margin), x2: t, y2: k - (E + b[d].margin), width: t - h, height: A[d] }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.width ? b[d].titleMaxWidth :\r\n                                b[d].lineCoordinates.width), E += A[d] + b[d].margin;\r\n                    if (c && 0 < c.length)\r\n                        for (d = c.length - 1; 0 <= d; d--)\r\n                            c[d] && (l = Math.round(g.y1), k = Math.round(g.y1 + (M[d] + c[d].margin + U)), c[d].lineCoordinates.y1 = k, c[d].lineCoordinates.y2 = k, c[d].bounds = { x1: h, y1: l + (c[d].margin + U), x2: t, y2: k, width: t - h, height: N }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width), U += M[d] + c[d].margin);\r\n                    if (a && 0 < a.length)\r\n                        for (d = 0; d < a.length; d++) {\r\n                            L = a[d]._labels &&\r\n                                0 < a[d]._labels.length ? a[d]._labels[0].textBlock.fontSize / 2 : 0;\r\n                            h = Math.round(g.x1 + e);\r\n                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(L, 10) ? Math.max(L, 10) : g.y1) : g.y1 < Math.max(L, 10) ? Math.max(L, 10) : g.y1;\r\n                            t = Math.round(g.x1 + Z + e);\r\n                            k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - Y > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : g.y2 - Y) : g.y2 > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : g.y2;\r\n                            if (b && 0 < b.length)\r\n                                for (L = 0; L < b.length; L++)\r\n                                    b[L] && b[L].labelAutoFit && (t = 0 > b[L].labelAngle ?\r\n                                        Math.max(t, z) : 0 === b[L].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[L].labelAngle || 0 === b[L].labelAngle ? t - Z : h);\r\n                            if (c && 0 < c.length)\r\n                                for (L = 0; L < c.length; L++)\r\n                                    c[L] && c[L].labelAutoFit && (t = c[L].lineCoordinates.x1, h = t - Z);\r\n                            a[d].lineCoordinates = { x1: t - R, y1: l, x2: t - R, y2: k, height: Math.abs(k - l) };\r\n                            a[d].bounds = { x1: t - (x[d] + R), y1: l, x2: t, y2: k, width: t - h, height: k - l };\r\n                            a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.height ? a[d].titleMaxWidth : a[d].lineCoordinates.height);\r\n                            a[d].calculateValueToPixelConversionParameters();\r\n                            a[d].calculateBreaksSizeInValues();\r\n                            R += x[d] + a[d].margin;\r\n                        }\r\n                    if (f && 0 < f.length)\r\n                        for (d = 0; d < f.length; d++) {\r\n                            L = f[d]._labels && 0 < f[d]._labels.length ? f[d]._labels[0].textBlock.fontSize / 2 : 0;\r\n                            h = Math.round(g.x1 - e);\r\n                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(L, 10) ? Math.max(L, 10) : g.y1) : g.y1 < Math.max(L, 10) ? Math.max(L, 10) : g.y1;\r\n                            t = Math.round(g.x2 - X - W);\r\n                            k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - Y > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : g.y2 - Y) : g.y2 > m.height - Math.max(L, 10) ?\r\n                                m.height - Math.max(L, 10) : g.y2;\r\n                            if (b && 0 < b.length)\r\n                                for (L = 0; L < b.length; L++)\r\n                                    b[L] && b[L].labelAutoFit && (t = 0 > b[L].labelAngle ? Math.max(t, z) : 0 === b[L].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[L].labelAngle || 0 === b[L].labelAngle ? t - X : h);\r\n                            if (c && 0 < c.length)\r\n                                for (L = 0; L < c.length; L++)\r\n                                    c[L] && c[L].labelAutoFit && (t = c[L].lineCoordinates.x2, h = t - X);\r\n                            f[d].lineCoordinates = { x1: t + V, y1: l, x2: t + V, y2: k, height: Math.abs(k - l) };\r\n                            f[d].bounds = { x1: h, y1: l, x2: t + I[d] + V, y2: k, width: t - h, height: k - l };\r\n                            f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth &&\r\n                                f[d].titleMaxWidth < f[d].lineCoordinates.height ? f[d].titleMaxWidth : f[d].lineCoordinates.height);\r\n                            f[d].calculateValueToPixelConversionParameters();\r\n                            f[d].calculateBreaksSizeInValues();\r\n                            V += I[d] + f[d].margin;\r\n                        }\r\n                    for (d = 0; d < n.length; d++)\r\n                        \"axisY\" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());\r\n                    if (0 < s) {\r\n                        if (a && 0 < a.length)\r\n                            for (d = 0; d < a.length; d++)\r\n                                q = Q[s - 1][d] === Q[s][d] ? !0 : !1;\r\n                        else\r\n                            q = !0;\r\n                        if (f && 0 < f.length)\r\n                            for (d = 0; d < f.length; d++)\r\n                                K = S[s - 1][d] === S[s][d] ? !0 : !1;\r\n                        else\r\n                            K = !0;\r\n                        if (b && 0 <\r\n                            b.length)\r\n                            for (d = 0; d < b.length; d++)\r\n                                J = u[s - 1][d] === u[s][d] ? !0 : !1;\r\n                        else\r\n                            J = !0;\r\n                        if (c && 0 < c.length)\r\n                            for (d = 0; d < c.length; d++)\r\n                                O = P[s - 1][d] === P[s][d] ? !0 : !1;\r\n                        else\r\n                            O = !0;\r\n                    }\r\n                    if (q && K && J && O)\r\n                        break;\r\n                    s++;\r\n                }\r\n                if (b && 0 < b.length)\r\n                    for (d = 0; d < b.length; d++)\r\n                        b[d].calculateStripLinesThicknessInValues(), b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();\r\n                if (c && 0 < c.length)\r\n                    for (d = 0; d < c.length; d++)\r\n                        c[d].calculateStripLinesThicknessInValues(), c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle();\r\n                if (a && 0 < a.length)\r\n                    for (d = 0; d < a.length; d++)\r\n                        a[d].calculateStripLinesThicknessInValues(),\r\n                            a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();\r\n                if (f && 0 < f.length)\r\n                    for (d = 0; d < f.length; d++)\r\n                        f[d].calculateStripLinesThicknessInValues(), f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle();\r\n            }\r\n            m.preparePlotArea();\r\n            g = m.plotArea;\r\n            p.save();\r\n            p.beginPath();\r\n            p.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1));\r\n            p.clip();\r\n            if (a && 0 < a.length)\r\n                for (d = 0; d < n.length; d++)\r\n                    n[d].renderStripLinesOfThicknessType(\"value\");\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].renderStripLinesOfThicknessType(\"value\");\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].renderStripLinesOfThicknessType(\"value\");\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].renderStripLinesOfThicknessType(\"value\");\r\n            if (a && 0 < a.length)\r\n                for (d = 0; d < a.length; d++)\r\n                    a[d].renderInterlacedColors();\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].renderInterlacedColors();\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].renderInterlacedColors();\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].renderInterlacedColors();\r\n            p.restore();\r\n            if (a && 0 < a.length)\r\n                for (d = 0; d < a.length; d++)\r\n                    a[d].renderGrid(),\r\n                        v && (a[d].createMask(), a[d].renderBreaksBackground());\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].renderGrid(), v && (f[d].createMask(), f[d].renderBreaksBackground());\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].renderGrid(), v && (b[d].createMask(), b[d].renderBreaksBackground());\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].renderGrid(), v && (c[d].createMask(), c[d].renderBreaksBackground());\r\n            if (a && 0 < a.length)\r\n                for (d = 0; d < a.length; d++)\r\n                    a[d].renderAxisLine();\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].renderAxisLine();\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].renderAxisLine();\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].renderAxisLine();\r\n            if (a && 0 < a.length)\r\n                for (d = 0; d < a.length; d++)\r\n                    a[d].renderStripLinesOfThicknessType(\"pixel\");\r\n            if (f && 0 < f.length)\r\n                for (d = 0; d < f.length; d++)\r\n                    f[d].renderStripLinesOfThicknessType(\"pixel\");\r\n            if (b && 0 < b.length)\r\n                for (d = 0; d < b.length; d++)\r\n                    b[d].renderStripLinesOfThicknessType(\"pixel\");\r\n            if (c && 0 < c.length)\r\n                for (d = 0; d < c.length; d++)\r\n                    c[d].renderStripLinesOfThicknessType(\"pixel\");\r\n        };\r\n        C.prototype.calculateStripLinesThicknessInValues =\r\n            function () {\r\n                for (var a = 0; a < this.stripLines.length; a++)\r\n                    if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {\r\n                        var f = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), f = this.getApparentDifference(f, b);\r\n                        this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value * Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(f)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue -\r\n                            this.stripLines[a].startValue) - f) / 2;\r\n                        this.stripLines[a].thickness = f;\r\n                        this.stripLines[a]._thicknessType = \"value\";\r\n                    }\r\n            };\r\n        C.prototype.calculateBreaksSizeInValues = function () {\r\n            for (var a = \"left\" === this._position || \"right\" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum -\r\n                this.conversionParameters.minimum), c = this.scaleBreaks && !y(this.scaleBreaks.options.spacing), e, g = 0; g < f.length; g++)\r\n                e = c || !y(f[g].options.spacing), f[g].spacing = P(f[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, f[g].size = 0 > f[g].spacing ? 0 : Math.abs(f[g].spacing / b), this.logarithmic && (f[g].size = Math.pow(this.logarithmBase, f[g].size));\r\n        };\r\n        C.prototype.calculateBreaksInPixels = function () {\r\n            if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {\r\n                var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\r\n                a.length && (this.scaleBreaks.firstBreakIndex =\r\n                    this.scaleBreaks.lastBreakIndex = null);\r\n                for (var f = 0; f < a.length && !(a[f].startValue > this.conversionParameters.maximum); f++)\r\n                    a[f].endValue < this.conversionParameters.minimum || (y(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = f), a[f].startValue >= this.conversionParameters.minimum && (a[f].startPixel = this.convertValueToPixel(a[f].startValue), this.scaleBreaks.lastBreakIndex = f), a[f].endValue <= this.conversionParameters.maximum && (a[f].endPixel = this.convertValueToPixel(a[f].endValue)));\r\n            }\r\n        };\r\n        C.prototype.renderLabelsTicksAndTitle =\r\n            function () {\r\n                var a = this, f = !1, b = 0, c = 0, e = 1, g = 0;\r\n                0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);\r\n                if (\"undefined\" === typeof this.options.interval) {\r\n                    if (\"bottom\" === this._position || \"top\" === this._position)\r\n                        if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\r\n                            for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, h, l = this.viewportMaximum, m = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\r\n                                p = this._labels[k];\r\n                                if (p.position < this.viewportMinimum)\r\n                                    break;\r\n                                p.position >\r\n                                    this.viewportMaximum || !(k === this._labels.length - 1 || h < Math.log(l / p.position) * m / e) || (b.push(p), l = p.position, h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\r\n                            }\r\n                            this._labels = b;\r\n                        }\r\n                        else {\r\n                            for (k = 0; k < this._labels.length; k++)\r\n                                p = this._labels[k], p.position < this.viewportMinimum || (h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += h);\r\n                            b > this.lineCoordinates.width *\r\n                                e && this.labelAutoFit && (f = !0);\r\n                        }\r\n                    if (\"left\" === this._position || \"right\" === this._position)\r\n                        if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {\r\n                            for (var b = [], r, l = this.viewportMaximum, m = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {\r\n                                p = this._labels[k];\r\n                                if (p.position < this.viewportMinimum)\r\n                                    break;\r\n                                p.position > this.viewportMaximum || !(k === this._labels.length - 1 || r < Math.log(l / p.position) * m) || (b.push(p), l = p.position, r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) +\r\n                                    p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));\r\n                            }\r\n                            this._labels = b;\r\n                        }\r\n                        else {\r\n                            for (k = 0; k < this._labels.length; k++)\r\n                                p = this._labels[k], p.position < this.viewportMinimum || (r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += r);\r\n                            c > this.lineCoordinates.height * e && this.labelAutoFit && (f = !0);\r\n                        }\r\n                }\r\n                this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function (a, b) { return a.position - b.position; });\r\n                var k = 0, p, n;\r\n                if (\"bottom\" === this._position) {\r\n                    for (k = 0; k < this._labels.length; k++)\r\n                        p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y + this.tickLength << 0),\r\n                            this.ctx.stroke()), 0 === p.textBlock.angle ? (n.x -= p.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ? n.y - (this.tickLength + p.textBlock.fontSize / 2) : n.y + this.tickLength + p.textBlock.fontSize / 2) : (n.x = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 > this.labelAngle ? n.y - this.tickLength - 5 : n.y - this.tickLength - Math.abs(p.textBlock.width *\r\n                            Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + this.tickLength + Math.abs(0 > this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p.textBlock.x = n.x, p.textBlock.y = n.y);\r\n                    \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\r\n                        for (k = 0; k < a._labels.length; k++)\r\n                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\r\n                                a.ctx.lineWidth =\r\n                                    a.tickThickness;\r\n                                a.ctx.strokeStyle = a.tickColor;\r\n                                var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;\r\n                                a.ctx.save();\r\n                                a.ctx.beginPath();\r\n                                a.ctx.moveTo(b, n.y << 0);\r\n                                a.ctx.lineTo(b, n.y - a.tickLength << 0);\r\n                                a.ctx.stroke();\r\n                                a.ctx.restore();\r\n                            }\r\n                    }, this);\r\n                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\r\n                }\r\n                else if (\"top\" ===\r\n                    this._position) {\r\n                    for (k = 0; k < this._labels.length; k++)\r\n                        p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y - this.tickLength << 0), this.ctx.stroke()), 0 === p.textBlock.angle ?\r\n                            (n.x -= p.textBlock.width / 2, n.y = \"inside\" === this.labelPlacement ? n.y + this.labelFontSize / 2 + this.tickLength + 5 : n.y - (this.tickLength + p.textBlock.height - p.textBlock.fontSize / 2)) : (n.x = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (p.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = \"inside\" === this.labelPlacement ? 0 < this.labelAngle ?\r\n                            n.y + this.tickLength + 5 : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : n.y - (this.tickLength + ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p.textBlock.x = n.x, p.textBlock.y = n.y);\r\n                    \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\r\n                        for (k = 0; k < a._labels.length; k++)\r\n                            if (p = a._labels[k], !(p.position < a.viewportMinimum ||\r\n                                p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\r\n                                a.ctx.lineWidth = a.tickThickness;\r\n                                a.ctx.strokeStyle = a.tickColor;\r\n                                var b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;\r\n                                a.ctx.save();\r\n                                a.ctx.beginPath();\r\n                                a.ctx.moveTo(b, n.y << 0);\r\n                                a.ctx.lineTo(b, n.y + a.tickLength << 0);\r\n                                a.ctx.stroke();\r\n                                a.ctx.restore();\r\n                            }\r\n                    }, this);\r\n                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width /\r\n                        2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\r\n                }\r\n                else if (\"left\" === this._position) {\r\n                    for (k = 0; k < this._labels.length; k++)\r\n                        p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth %\r\n                            2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x - this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (p.textBlock.y = n.y, p.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? n.y : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? n.x + this.tickLength + 5 : 0 < this.labelAngle ?\r\n                            n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));\r\n                    \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\r\n                        for (k = 0; k < a._labels.length; k++)\r\n                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position),\r\n                                a.tickThickness)) {\r\n                                a.ctx.lineWidth = a.tickThickness;\r\n                                a.ctx.strokeStyle = a.tickColor;\r\n                                var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;\r\n                                a.ctx.save();\r\n                                a.ctx.beginPath();\r\n                                a.ctx.moveTo(n.x << 0, b);\r\n                                a.ctx.lineTo(n.x + a.tickLength << 0, b);\r\n                                a.ctx.stroke();\r\n                                a.ctx.restore();\r\n                            }\r\n                    }, this);\r\n                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\r\n                }\r\n                else if (\"right\" ===\r\n                    this._position) {\r\n                    for (k = 0; k < this._labels.length; k++)\r\n                        p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && \"inside\" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x + this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ?\r\n                            (p.textBlock.y = n.y, p.textBlock.x = \"inside\" === this.labelPlacement ? n.x - p.textBlock.width - this.tickLength - 5 : n.x + this.tickLength + 5) : (p.textBlock.y = \"inside\" === this.labelPlacement ? n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), p.textBlock.x = \"inside\" === this.labelPlacement ? n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? n.x + (p.textBlock.height -\r\n                            p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : n.x + this.tickLength + 5));\r\n                    \"inside\" === this.labelPlacement && this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\r\n                        for (k = 0; k < a._labels.length; k++)\r\n                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {\r\n                                a.ctx.lineWidth = a.tickThickness;\r\n                                a.ctx.strokeStyle = a.tickColor;\r\n                                var b = 1 === a.ctx.lineWidth % 2 ? (n.y <<\r\n                                    0) + 0.5 : n.y << 0;\r\n                                a.ctx.save();\r\n                                a.ctx.beginPath();\r\n                                a.ctx.moveTo(n.x << 0, b);\r\n                                a.ctx.lineTo(n.x - a.tickLength << 0, b);\r\n                                a.ctx.stroke();\r\n                                a.ctx.restore();\r\n                            }\r\n                    }, this);\r\n                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));\r\n                }\r\n                g = 0;\r\n                if (\"inside\" === this.labelPlacement)\r\n                    this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (k = 0; k < a._labels.length; k++)\r\n                        p = a._labels[k], p.position < a.viewportMinimum || (p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(!0), a.ctx.restore()); }, p.textBlock);\r\n                else\r\n                    for (k = 0; k < this._labels.length; k++)\r\n                        p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || p.textBlock.render(!0);\r\n            };\r\n        C.prototype.renderInterlacedColors = function () {\r\n            var a = this.chart.plotArea.ctx, f, b, c = this.chart.plotArea, e = 0;\r\n            f = !0;\r\n            if ((\"bottom\" === this._position || \"top\" === this._position) && this.interlacedColor)\r\n                for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)\r\n                    f ? (f = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, f.x), c.y1, Math.abs(b.x - f.x), Math.abs(c.y1 - c.y2)), f = !1) : f = !0;\r\n            else if ((\"left\" === this._position || \"right\" === this._position) && this.interlacedColor)\r\n                for (a.fillStyle =\r\n                    this.interlacedColor, e = 0; e < this._labels.length; e++)\r\n                    f ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), f = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1, Math.min(b.y, f.y), Math.abs(c.x1 - c.x2), Math.abs(f.y - b.y)), f = !1) : f = !0;\r\n            a.beginPath();\r\n        };\r\n        C.prototype.renderStripLinesOfThicknessType = function (a) {\r\n            if (this.stripLines && 0 < this.stripLines.length && a) {\r\n                for (var f = this, b, c = 0, e = 0, g = !1, h = !1, l = [], m = [], h = !1, c = 0; c < this.stripLines.length; c++) {\r\n                    var k = this.stripLines[c];\r\n                    k._thicknessType === a && (\"pixel\" === a && (k.value < this.viewportMinimum || k.value > this.viewportMaximum || y(k.value) || isNaN(this.range)) || l.push(k));\r\n                }\r\n                for (c = 0; c < this._stripLineLabels.length; c++)\r\n                    if (k = this.stripLines[c], b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {\r\n                        a = this.getPixelCoordinatesOnAxis(b.position);\r\n                        if (\"outside\" === b.stripLine.labelPlacement)\r\n                            if (k && (this.ctx.strokeStyle =\r\n                                k.color, \"pixel\" === k._thicknessType && (this.ctx.lineWidth = k.thickness)), \"bottom\" === this._position) {\r\n                                var r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0;\r\n                                this.ctx.beginPath();\r\n                                this.ctx.moveTo(r, a.y << 0);\r\n                                this.ctx.lineTo(r, a.y + this.tickLength << 0);\r\n                                this.ctx.stroke();\r\n                                0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI /\r\n                                    180 * this.labelAngle) - 5 : 5));\r\n                            }\r\n                            else\r\n                                \"top\" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(r, a.y << 0), this.ctx.lineTo(r, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height *\r\n                                    Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : \"left\" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x - this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width *\r\n                                    Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : \"right\" === this._position && (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x + this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize /\r\n                                    2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));\r\n                        else\r\n                            b.textBlock.angle = -90, \"bottom\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize /\r\n                                2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : \"center\" ===\r\n                                b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : \"top\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ? a.x +=\r\n                                b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 -\r\n                                b.textBlock.width - 3) : \"left\" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize /\r\n                                2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : \"right\" === this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ?\r\n                                y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = \"near\" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : \"center\" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 +\r\n                                3);\r\n                        b.textBlock.x = a.x;\r\n                        b.textBlock.y = a.y;\r\n                        m.push(b);\r\n                    }\r\n                if (!h) {\r\n                    h = !1;\r\n                    this.ctx.save();\r\n                    this.ctx.beginPath();\r\n                    this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\r\n                    this.ctx.clip();\r\n                    for (c = 0; c < l.length; c++)\r\n                        k = l[c], k.showOnTop ? g || (g = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () {\r\n                            this.ctx.save();\r\n                            this.ctx.beginPath();\r\n                            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\r\n                            this.ctx.clip();\r\n                            for (e = 0; e < l.length; e++)\r\n                                k = l[e], k.showOnTop && k.render();\r\n                            this.ctx.restore();\r\n                        }, k)) : k.render();\r\n                    for (c = 0; c < m.length; c++)\r\n                        b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (e = 0; e < m.length; e++)\r\n                            b = m[e], \"inside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (f.ctx.save(), f.ctx.beginPath(), f.ctx.rect(f.chart.plotArea.x1, f.chart.plotArea.y1, f.chart.plotArea.width, f.chart.plotArea.height), f.ctx.clip(), b.textBlock.render(!0), f.ctx.restore()); }, b.textBlock)) :\r\n                            \"inside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\r\n                    this.ctx.restore();\r\n                    h = !0;\r\n                }\r\n                if (h)\r\n                    for (h = !1, c = 0; c < m.length; c++)\r\n                        b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener(\"dataAnimationIterationEnd\", function () { for (e = 0; e < m.length; e++)\r\n                            b = m[e], \"outside\" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0); }, b.textBlock)) : \"outside\" === b.stripLine.labelPlacement && b.textBlock.render(!0);\r\n            }\r\n        };\r\n        C.prototype.renderBreaksBackground = function () {\r\n            this.chart._breaksCanvas && (this.scaleBreaks &&\r\n                0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());\r\n        };\r\n        C.prototype.createMask = function () {\r\n            if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {\r\n                var a = this.scaleBreaks._appliedBreaks;\r\n                v ? (this.maskCanvas = ua(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext(\"2d\")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);\r\n                this.maskCtx.save();\r\n                this.maskCtx.beginPath();\r\n                this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\r\n                this.maskCtx.clip();\r\n                for (var f = 0; f < a.length; f++)\r\n                    a[f].endValue < this.viewportMinimum || (a[f].startValue > this.viewportMaximum ||\r\n                        isNaN(this.range)) || a[f].render(this.maskCtx);\r\n                this.maskCtx.restore();\r\n            }\r\n        };\r\n        C.prototype.renderCrosshair = function (a, f) { this.crosshair.render(a, f); };\r\n        C.prototype.renderGrid = function () {\r\n            if (this.gridThickness && 0 < this.gridThickness) {\r\n                var a = this.chart.ctx;\r\n                a.save();\r\n                var f, b = this.chart.plotArea;\r\n                a.lineWidth = this.gridThickness;\r\n                a.strokeStyle = this.gridColor;\r\n                a.setLineDash && a.setLineDash(G(this.gridDashType, this.gridThickness));\r\n                if (\"bottom\" === this._position || \"top\" === this._position)\r\n                    for (c = 0; c < this._labels.length; c++)\r\n                        this._labels[c].position <\r\n                            this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.x << 0) + 0.5 : f.x << 0, a.moveTo(f, b.y1 << 0), a.lineTo(f, b.y2 << 0), a.stroke());\r\n                else if (\"left\" === this._position || \"right\" === this._position)\r\n                    for (var c = 0; c < this._labels.length; c++)\r\n                        this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(),\r\n                            f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.y << 0) + 0.5 : f.y << 0, a.moveTo(b.x1 << 0, f), a.lineTo(b.x2 << 0, f), a.stroke());\r\n                a.restore();\r\n            }\r\n        };\r\n        C.prototype.renderAxisLine = function () {\r\n            var a = this.chart.ctx, f = v ? this.chart._preRenderCtx : a, b = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, g;\r\n            f.save();\r\n            if (\"bottom\" === this._position || \"top\" === this._position) {\r\n                if (this.lineThickness) {\r\n                    this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) :\r\n                        (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2);\r\n                    f.lineWidth = this.lineThickness;\r\n                    f.strokeStyle = this.lineColor ? this.lineColor : \"black\";\r\n                    f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));\r\n                    var h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;\r\n                    f.beginPath();\r\n                    if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex))\r\n                        if (y(this.scaleBreaks.lastBreakIndex))\r\n                            e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;\r\n                        else\r\n                            for (var l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)\r\n                                f.moveTo(e, h), f.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + b, h), e = this.scaleBreaks._appliedBreaks[l].endPixel + c;\r\n                    e && (f.moveTo(e, h), f.lineTo(g, h));\r\n                    f.stroke();\r\n                }\r\n            }\r\n            else if ((\"left\" === this._position || \"right\" === this._position) && this.lineThickness) {\r\n                this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1);\r\n                f.lineWidth = this.lineThickness;\r\n                f.strokeStyle = this.lineColor;\r\n                f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));\r\n                h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;\r\n                f.beginPath();\r\n                if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex))\r\n                    if (y(this.scaleBreaks.lastBreakIndex))\r\n                        e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;\r\n                    else\r\n                        for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++)\r\n                            f.moveTo(h, e), f.lineTo(h, this.scaleBreaks._appliedBreaks[l].startPixel + c),\r\n                                e = this.scaleBreaks._appliedBreaks[l].endPixel + b;\r\n                e && (f.moveTo(h, e), f.lineTo(h, g));\r\n                f.stroke();\r\n            }\r\n            v && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), f.clearRect(0, 0, this.chart.width, this.chart.height));\r\n            f.restore();\r\n        };\r\n        C.prototype.getPixelCoordinatesOnAxis = function (a) {\r\n            var f = {};\r\n            if (\"bottom\" === this._position || \"top\" === this._position)\r\n                f.x = this.convertValueToPixel(a),\r\n                    f.y = this.lineCoordinates.y1;\r\n            if (\"left\" === this._position || \"right\" === this._position)\r\n                f.y = this.convertValueToPixel(a), f.x = this.lineCoordinates.x2;\r\n            return f;\r\n        };\r\n        C.prototype.convertPixelToValue = function (a) {\r\n            if (\"undefined\" === typeof a)\r\n                return null;\r\n            var f = 0, b = 0, c, f = !0, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = \"number\" === typeof a ? a : \"left\" === this._position || \"right\" === this._position ? a.y : a.x;\r\n            if (this.logarithmic) {\r\n                a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);\r\n                if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed)\r\n                    for (b = 0; b < e.length; b++) {\r\n                        if (!(e[b].endValue < this.conversionParameters.minimum))\r\n                            if (f)\r\n                                if (e[b].startValue < this.conversionParameters.minimum) {\r\n                                    if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) {\r\n                                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a *= e[b].endValue / this.conversionParameters.minimum /\r\n                                            Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue));\r\n                                    f = !1;\r\n                                }\r\n                                else if (c > e[b].startValue / this.conversionParameters.minimum) {\r\n                                    c /= e[b].startValue / this.conversionParameters.minimum;\r\n                                    if (c < e[b].size) {\r\n                                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a *= e[b].endValue / e[b].startValue /\r\n                                            e[b].size;\r\n                                    c /= e[b].size;\r\n                                    f = !1;\r\n                                }\r\n                                else\r\n                                    break;\r\n                            else if (c > e[b].startValue / e[b - 1].endValue) {\r\n                                c /= e[b].startValue / e[b - 1].endValue;\r\n                                if (c < e[b].size) {\r\n                                    a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                    a *= e[b].endValue / e[b].startValue / e[b].size;\r\n                                c /= e[b].size;\r\n                            }\r\n                            else\r\n                                break;\r\n                    }\r\n                else\r\n                    for (b = e.length - 1; 0 <= b; b--)\r\n                        if (!(e[b].startValue > this.conversionParameters.minimum))\r\n                            if (f)\r\n                                if (e[b].endValue > this.conversionParameters.minimum) {\r\n                                    if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue /\r\n                                        e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) {\r\n                                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue));\r\n                                    f = !1;\r\n                                }\r\n                                else if (c < e[b].endValue / this.conversionParameters.minimum) {\r\n                                    c /=\r\n                                        e[b].endValue / this.conversionParameters.minimum;\r\n                                    if (c > 1 / e[b].size) {\r\n                                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a /= e[b].endValue / e[b].startValue / e[b].size;\r\n                                    c *= e[b].size;\r\n                                    f = !1;\r\n                                }\r\n                                else\r\n                                    break;\r\n                            else if (c < e[b].endValue / e[b + 1].startValue) {\r\n                                c /= e[b].endValue / e[b + 1].startValue;\r\n                                if (c > 1 / e[b].size) {\r\n                                    a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                    a /= e[b].endValue / e[b].startValue / e[b].size;\r\n                                c *= e[b].size;\r\n                            }\r\n                            else\r\n                                break;\r\n                f = a * this.viewportMinimum;\r\n            }\r\n            else {\r\n                a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;\r\n                if (b <= this.conversionParameters.reference === (\"left\" === this._position || \"right\" === this._position) !== this.reversed)\r\n                    for (b = 0; b < e.length; b++) {\r\n                        if (!(e[b].endValue < this.conversionParameters.minimum))\r\n                            if (f)\r\n                                if (e[b].startValue < this.conversionParameters.minimum) {\r\n                                    if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) {\r\n                                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue -\r\n                                            e[b].startValue) / e[b].size;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue);\r\n                                    f = !1;\r\n                                }\r\n                                else if (c > e[b].startValue - this.conversionParameters.minimum) {\r\n                                    c -= e[b].startValue - this.conversionParameters.minimum;\r\n                                    if (c < e[b].size) {\r\n                                        a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a += e[b].endValue -\r\n                                            e[b].startValue - e[b].size;\r\n                                    c -= e[b].size;\r\n                                    f = !1;\r\n                                }\r\n                                else\r\n                                    break;\r\n                            else if (c > e[b].startValue - e[b - 1].endValue) {\r\n                                c -= e[b].startValue - e[b - 1].endValue;\r\n                                if (c < e[b].size) {\r\n                                    a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                    a += e[b].endValue - e[b].startValue - e[b].size;\r\n                                c -= e[b].size;\r\n                            }\r\n                            else\r\n                                break;\r\n                    }\r\n                else\r\n                    for (b = e.length - 1; 0 <= b; b--)\r\n                        if (!(e[b].startValue > this.conversionParameters.minimum))\r\n                            if (f)\r\n                                if (e[b].endValue > this.conversionParameters.minimum)\r\n                                    if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue -\r\n                                        e[b].startValue) / e[b].size > e[b].startValue) {\r\n                                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), f = !1;\r\n                                else if (c < e[b].endValue - this.conversionParameters.minimum) {\r\n                                    c -= e[b].endValue - this.conversionParameters.minimum;\r\n                                    if (c > -1 * e[b].size) {\r\n                                        a += (e[b].endValue -\r\n                                            e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;\r\n                                        break;\r\n                                    }\r\n                                    else\r\n                                        a -= e[b].endValue - e[b].startValue - e[b].size;\r\n                                    c += e[b].size;\r\n                                    f = !1;\r\n                                }\r\n                                else\r\n                                    break;\r\n                            else if (c < e[b].endValue - e[b + 1].startValue) {\r\n                                c -= e[b].endValue - e[b + 1].startValue;\r\n                                if (c > -1 * e[b].size) {\r\n                                    a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                    a -= e[b].endValue - e[b].startValue - e[b].size;\r\n                                c += e[b].size;\r\n                            }\r\n                            else\r\n                                break;\r\n                f = this.conversionParameters.minimum + a;\r\n            }\r\n            return f;\r\n        };\r\n        C.prototype.convertValueToPixel = function (a) {\r\n            a = this.getApparentDifference(this.conversionParameters.minimum, a, a);\r\n            return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : \"axisX\" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5;\r\n        };\r\n        C.prototype.getApparentDifference = function (a, f, b, c) {\r\n            var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\r\n            if (this.logarithmic) {\r\n                b = y(b) ? f / a : b;\r\n                for (var g = 0; g < e.length && !(f < e[g].startValue); g++)\r\n                    a > e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue / a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && f <= e[g].endValue ? b = b / f * e[g].startValue * Math.pow(e[g].size, Math.log(f / e[g].startValue) / Math.log(e[g].endValue /\r\n                        e[g].startValue)) : !c && (a > e[g].startValue && f < e[g].endValue) && (b = a * Math.pow(e[g].size, Math.log(f / a) / Math.log(e[g].endValue / e[g].startValue))));\r\n            }\r\n            else\r\n                for (b = y(b) ? Math.abs(f - a) : b, g = 0; g < e.length && !(f < e[g].startValue); g++)\r\n                    a > e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && f < e[g].endValue ? b = b - f + e[g].startValue + e[g].size * (f - e[g].startValue) /\r\n                        (e[g].endValue - e[g].startValue) : !c && (a > e[g].startValue && f < e[g].endValue) && (b = a + e[g].size * (f - a) / (e[g].endValue - e[g].startValue)));\r\n            return b;\r\n        };\r\n        C.prototype.setViewPortRange = function (a, f) { this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, f); this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, f); };\r\n        C.prototype.getXValueAt = function (a) {\r\n            if (!a)\r\n                return null;\r\n            var f = null;\r\n            \"left\" === this._position ? f = this.convertPixelToValue(a.y) : \"bottom\" === this._position && (f = this.convertPixelToValue(a.x));\r\n            return f;\r\n        };\r\n        C.prototype.calculateValueToPixelConversionParameters = function (a) {\r\n            a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];\r\n            var f = { pixelPerUnit: null, minimum: null, reference: null }, b = this.lineCoordinates.width, c = this.lineCoordinates.height, b = \"bottom\" === this._position || \"top\" === this._position ? b : c, c = Math.abs(this.range);\r\n            if (this.logarithmic)\r\n                for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)\r\n                    this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <=\r\n                        a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) :\r\n                        b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));\r\n            else\r\n                for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++)\r\n                    this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum,\r\n                        b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf(\"%\") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) :\r\n                        b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));\r\n            f.minimum = this.viewportMinimum;\r\n            f.maximum = this.viewportMaximum;\r\n            f.range = c;\r\n            if (\"bottom\" === this._position || \"top\" === this._position)\r\n                this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase), f.pixelPerUnit = (this.reversed ? -1 : 1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;\r\n            if (\"left\" ===\r\n                this._position || \"right\" === this._position)\r\n                this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase), f.pixelPerUnit = (this.reversed ? 1 : -1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;\r\n            this.conversionParameters = f;\r\n        };\r\n        C.prototype.calculateAxisParameters = function () {\r\n            if (this.logarithmic)\r\n                this.calculateLogarithmicAxisParameters();\r\n            else {\r\n                var a = this.chart.layoutManager.getFreeSpace(), f = !1, b = !1;\r\n                \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\r\n                var a = \"axisX\" === this.type ? \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 62 : 70 : \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 : 40, c = 4;\r\n                \"axisX\" === this.type && (c = 600 > this.maxWidth ? 8 : 6);\r\n                var a = Math.max(c, Math.floor(this.maxWidth / a)), e, g, h, c = 0;\r\n                !y(this.options.viewportMinimum) && (!y(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) &&\r\n                    (this.viewportMinimum = this.viewportMaximum = null);\r\n                if (y(this.options.viewportMinimum) && !y(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))\r\n                    this.viewportMinimum = this.sessionVariables.newViewportMinimum;\r\n                else if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\r\n                    this.viewportMinimum = this.minimum;\r\n                if (y(this.options.viewportMaximum) && !y(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))\r\n                    this.viewportMaximum = this.sessionVariables.newViewportMaximum;\r\n                else if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\r\n                    this.viewportMaximum = this.maximum;\r\n                if (this.scaleBreaks)\r\n                    for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++)\r\n                        if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) &&\r\n                            (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue || !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {\r\n                            this.scaleBreaks._appliedBreaks.splice(c, 1);\r\n                            break;\r\n                        }\r\n                if (\"axisX\" === this.type) {\r\n                    if (this.dataSeries && 0 < this.dataSeries.length)\r\n                        for (e = 0; e < this.dataSeries.length; e++)\r\n                            \"dateTime\" === this.dataSeries[e].xValueType &&\r\n                                (b = !0);\r\n                    e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;\r\n                    g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;\r\n                    0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c);\r\n                    Infinity !== this.dataInfo.minDiff ? h = this.dataInfo.minDiff : 1 < g - e ? h = 0.5 * Math.abs(g - e) : (h = 1, b && (f = !0));\r\n                }\r\n                else\r\n                    \"axisY\" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum :\r\n                        this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0));\r\n                c = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum, null, !0);\r\n                if (\"axisX\" === this.type && b) {\r\n                    this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = \"millisecond\") : c / 2 <= a ? (this.interval = 2, this.intervalType = \"millisecond\") : c / 5 <= a ? (this.interval = 5, this.intervalType = \"millisecond\") : c / 10 <= a ? (this.interval = 10, this.intervalType = \"millisecond\") : c / 20 <= a ? (this.interval = 20, this.intervalType = \"millisecond\") : c / 50 <= a ? (this.interval = 50, this.intervalType = \"millisecond\") : c / 100 <= a ? (this.interval = 100, this.intervalType = \"millisecond\") : c / 200 <= a ? (this.interval = 200, this.intervalType =\r\n                        \"millisecond\") : c / 250 <= a ? (this.interval = 250, this.intervalType = \"millisecond\") : c / 300 <= a ? (this.interval = 300, this.intervalType = \"millisecond\") : c / 400 <= a ? (this.interval = 400, this.intervalType = \"millisecond\") : c / 500 <= a ? (this.interval = 500, this.intervalType = \"millisecond\") : c / (1 * V.secondDuration) <= a ? (this.interval = 1, this.intervalType = \"second\") : c / (2 * V.secondDuration) <= a ? (this.interval = 2, this.intervalType = \"second\") : c / (5 * V.secondDuration) <= a ? (this.interval = 5, this.intervalType = \"second\") : c / (10 * V.secondDuration) <= a ? (this.interval =\r\n                        10, this.intervalType = \"second\") : c / (15 * V.secondDuration) <= a ? (this.interval = 15, this.intervalType = \"second\") : c / (20 * V.secondDuration) <= a ? (this.interval = 20, this.intervalType = \"second\") : c / (30 * V.secondDuration) <= a ? (this.interval = 30, this.intervalType = \"second\") : c / (1 * V.minuteDuration) <= a ? (this.interval = 1, this.intervalType = \"minute\") : c / (2 * V.minuteDuration) <= a ? (this.interval = 2, this.intervalType = \"minute\") : c / (5 * V.minuteDuration) <= a ? (this.interval = 5, this.intervalType = \"minute\") : c / (10 * V.minuteDuration) <= a ? (this.interval =\r\n                        10, this.intervalType = \"minute\") : c / (15 * V.minuteDuration) <= a ? (this.interval = 15, this.intervalType = \"minute\") : c / (20 * V.minuteDuration) <= a ? (this.interval = 20, this.intervalType = \"minute\") : c / (30 * V.minuteDuration) <= a ? (this.interval = 30, this.intervalType = \"minute\") : c / (1 * V.hourDuration) <= a ? (this.interval = 1, this.intervalType = \"hour\") : c / (2 * V.hourDuration) <= a ? (this.interval = 2, this.intervalType = \"hour\") : c / (3 * V.hourDuration) <= a ? (this.interval = 3, this.intervalType = \"hour\") : c / (6 * V.hourDuration) <= a ? (this.interval = 6, this.intervalType =\r\n                        \"hour\") : c / (1 * V.dayDuration) <= a ? (this.interval = 1, this.intervalType = \"day\") : c / (2 * V.dayDuration) <= a ? (this.interval = 2, this.intervalType = \"day\") : c / (4 * V.dayDuration) <= a ? (this.interval = 4, this.intervalType = \"day\") : c / (1 * V.weekDuration) <= a ? (this.interval = 1, this.intervalType = \"week\") : c / (2 * V.weekDuration) <= a ? (this.interval = 2, this.intervalType = \"week\") : c / (3 * V.weekDuration) <= a ? (this.interval = 3, this.intervalType = \"week\") : c / (1 * V.monthDuration) <= a ? (this.interval = 1, this.intervalType = \"month\") : c / (2 * V.monthDuration) <= a ? (this.interval =\r\n                        2, this.intervalType = \"month\") : c / (3 * V.monthDuration) <= a ? (this.interval = 3, this.intervalType = \"month\") : c / (6 * V.monthDuration) <= a ? (this.interval = 6, this.intervalType = \"month\") : (this.interval = c / (1 * V.yearDuration) <= a ? 1 : c / (2 * V.yearDuration) <= a ? 2 : c / (4 * V.yearDuration) <= a ? 4 : Math.floor(C.getNiceNumber(c / (a - 1), !0) / V.yearDuration), this.intervalType = \"year\"));\r\n                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\r\n                        this.viewportMinimum = e - h / 2;\r\n                    if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\r\n                        this.viewportMaximum =\r\n                            g + h / 2;\r\n                    f ? this.autoValueFormatString = \"MMM DD YYYY HH:mm\" : \"year\" === this.intervalType ? this.autoValueFormatString = \"YYYY\" : \"month\" === this.intervalType ? this.autoValueFormatString = \"MMM YYYY\" : \"week\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"day\" === this.intervalType ? this.autoValueFormatString = \"MMM DD YYYY\" : \"hour\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"minute\" === this.intervalType ? this.autoValueFormatString = \"hh:mm TT\" : \"second\" === this.intervalType ? this.autoValueFormatString =\r\n                        \"hh:mm:ss TT\" : \"millisecond\" === this.intervalType && (this.autoValueFormatString = \"fff'ms'\");\r\n                    this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);\r\n                }\r\n                else {\r\n                    this.intervalType = \"number\";\r\n                    c = C.getNiceNumber(c, !1);\r\n                    this.interval = this.options && 0 < this.options.interval ? this.options.interval : C.getNiceNumber(c / (a - 1), !0);\r\n                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\r\n                        this.viewportMinimum = \"axisX\" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval;\r\n                    if (null === this.viewportMaximum ||\r\n                        isNaN(this.viewportMaximum))\r\n                        this.viewportMaximum = \"axisX\" === this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval;\r\n                    0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\r\n                }\r\n                if (null === this.minimum || null === this.maximum)\r\n                    if (\"axisX\" === this.type ? (e =\r\n                        null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : \"axisY\" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)) : (g = \"undefined\" === typeof this.options.interval ? -Infinity : this.options.interval, e = \"undefined\" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum ||\r\n                        isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, !0)), \"axisX\" === this.type && b) {\r\n                        this.valueType = \"dateTime\";\r\n                        if (null === this.minimum || isNaN(this.minimum))\r\n                            this.minimum = e - h / 2;\r\n                        if (null === this.maximum || isNaN(this.maximum))\r\n                            this.maximum = g + h / 2;\r\n                    }\r\n                    else\r\n                        this.intervalType = this.valueType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = \"axisX\" === this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 ===\r\n                            this.options.maximum && (this.minimum -= 10));\r\n                y(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));\r\n                y(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));\r\n                this.range = this.viewportMaximum - this.viewportMinimum;\r\n                this.intervalStartPosition = \"axisX\" === this.type && b ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) /\r\n                    this.interval) * this.interval;\r\n                this.valueFormatString || (this.valueFormatString = C.generateValueFormatString(this.range, 2));\r\n            }\r\n        };\r\n        C.prototype.calculateLogarithmicAxisParameters = function () {\r\n            var a = this.chart.layoutManager.getFreeSpace(), f = Math.log(this.logarithmBase), b;\r\n            \"bottom\" === this._position || \"top\" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);\r\n            var a = \"axisX\" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth /\r\n                50), 3), c, e, g, h;\r\n            h = 1;\r\n            if (null === this.viewportMinimum || isNaN(this.viewportMinimum))\r\n                this.viewportMinimum = this.minimum;\r\n            if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\r\n                this.viewportMaximum = this.maximum;\r\n            if (this.scaleBreaks)\r\n                for (h = 0; h < this.scaleBreaks._appliedBreaks.length; h++)\r\n                    if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[h].startValue ||\r\n                        !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue) && (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue || !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[h].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue)) {\r\n                        this.scaleBreaks._appliedBreaks.splice(h, 1);\r\n                        break;\r\n                    }\r\n            \"axisX\" === this.type ?\r\n                (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (h = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin,\r\n                e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, c = 1) : 1 === e / c ? (h = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= h, c /= h) : c > e ? (h = Math.min(c / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));\r\n            h = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null ===\r\n                this.viewportMinimum ? c : this.viewportMinimum);\r\n            linearRange = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);\r\n            this.intervalType = \"number\";\r\n            h = Math.pow(this.logarithmBase, C.getNiceNumber(Math.abs(Math.log(h) / f), !1));\r\n            this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = C.getNiceExponent(Math.log(h) / f / (a - 1), !0), b = C.getNiceNumber(linearRange / (a - 1), !0));\r\n            if (null ===\r\n                this.viewportMinimum || isNaN(this.viewportMinimum))\r\n                this.viewportMinimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval));\r\n            if (null === this.viewportMaximum || isNaN(this.viewportMaximum))\r\n                this.viewportMaximum = \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval));\r\n            1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase -\r\n                1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && \"undefined\" === typeof this.options.interval && (this.interval = C.getNiceExponent(Math.ceil(Math.log(h) / f) / (a - 1)), b = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));\r\n            if (null === this.minimum || null === this.maximum)\r\n                \"axisX\" === this.type ? (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (h = Math.pow(this.logarithmBase, \"undefined\" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : \"axisY\" === this.type && (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) || isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (h = Math.pow(this.logarithmBase, this.interval), e *= h, c /= h) : c > e ? (h =\r\n                    Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)) : (e = \"undefined\" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) &&\r\n                    1 > e && (e = 1)), this.intervalType = \"number\", null === this.minimum && (this.minimum = \"axisX\" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? \"undefined\" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum =\r\n                    \"axisX\" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? \"undefined\" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase :\r\n                    1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));\r\n            this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);\r\n            this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);\r\n            this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum =\r\n                (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);\r\n            c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval);\r\n            this.range = this.viewportMaximum / this.viewportMinimum;\r\n            this.noTicks = a;\r\n            if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {\r\n                for (f = Math.floor(this.viewportMinimum /\r\n                    b + 0.5) * b; f < this.viewportMinimum;)\r\n                    f += b;\r\n                this.equidistantInterval = !1;\r\n                this.intervalStartPosition = f;\r\n                this.interval = b;\r\n            }\r\n            else\r\n                this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = c;\r\n            if (!this.valueFormatString && (this.valueFormatString = \"#,##0.##\", 1 > this.viewportMinimum)) {\r\n                f = Math.floor(Math.abs(Math.log(this.viewportMinimum) /\r\n                    Math.LN10)) + 2;\r\n                if (isNaN(f) || !isFinite(f))\r\n                    f = 2;\r\n                if (2 < f)\r\n                    for (h = 0; h < f - 2; h++)\r\n                        this.valueFormatString += \"#\";\r\n            }\r\n        };\r\n        C.generateValueFormatString = function (a, f) { var b = \"#,##0.\", c = f; 1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = f); for (var e = 0; e < c; e++)\r\n            b += \"#\"; return b; };\r\n        C.getNiceExponent = function (a, f) { var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = 0 > b ? 1 >= c ? 1 : 5 >= c ? 5 : 10 : Math.max(Math.floor(c), 1); return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20)); };\r\n        C.getNiceNumber =\r\n            function (a, f) { var b = Math.floor(Math.log(a) / Math.LN10), c = a / Math.pow(10, b), c = f ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10; return -20 > b ? Number(c * Math.pow(10, b)) : Number((c * Math.pow(10, b)).toFixed(20)); };\r\n        C.prototype.getLabelStartPoint = function () {\r\n            var a = V[this.intervalType + \"Duration\"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a);\r\n            if (\"millisecond\" !== this.intervalType)\r\n                if (\"second\" === this.intervalType)\r\n                    0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));\r\n                else if (\"minute\" ===\r\n                    this.intervalType) {\r\n                    if (0 < a.getSeconds() || 0 < a.getMilliseconds())\r\n                        a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0);\r\n                }\r\n                else if (\"hour\" === this.intervalType) {\r\n                    if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\r\n                        a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\r\n                }\r\n                else if (\"day\" === this.intervalType) {\r\n                    if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\r\n                        a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\r\n                }\r\n                else if (\"week\" ===\r\n                    this.intervalType) {\r\n                    if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\r\n                        a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\r\n                }\r\n                else if (\"month\" === this.intervalType) {\r\n                    if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds())\r\n                        a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);\r\n                }\r\n                else\r\n                    \"year\" === this.intervalType && (0 < a.getMonth() || 1 <\r\n                        a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));\r\n            return a;\r\n        };\r\n        oa(Q, Y);\r\n        oa(ba, Y);\r\n        ba.prototype.createUserOptions = function (a) {\r\n            if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\r\n                var f = 0;\r\n                this.parent.options._isPlaceholder && this.parent.createUserOptions();\r\n                this.options._isPlaceholder || (Da(this.parent[this.optionsName]), f = this.parent.options[this.optionsName].indexOf(this.options));\r\n                this.options = \"undefined\" === typeof a ? {} : a;\r\n                this.parent.options[this.optionsName][f] = this.options;\r\n            }\r\n        };\r\n        ba.prototype.render = function (a) {\r\n            if (0 !== this.spacing || 0 !== this.options.lineThickness && (\"undefined\" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {\r\n                var f = this.ctx, b = this.ctx.globalAlpha;\r\n                this.ctx = a || this.ctx;\r\n                this.ctx.save();\r\n                this.ctx.beginPath();\r\n                this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);\r\n                this.ctx.clip();\r\n                var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);\r\n                this.ctx.strokeStyle = this.lineColor;\r\n                this.ctx.fillStyle = this.color;\r\n                this.ctx.beginPath();\r\n                this.ctx.globalAlpha = 1;\r\n                S(this.id);\r\n                var g, h, l, m, k, r;\r\n                a = Math.max(this.spacing, 3);\r\n                var p = Math.max(0, this.lineThickness);\r\n                this.ctx.lineWidth = p;\r\n                this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, p));\r\n                if (\"bottom\" === this.scaleBreaks.parent._position || \"top\" === this.scaleBreaks.parent._position)\r\n                    if (c = 1 === p % 2 ? (c.x << 0) + 0.5 : c.x << 0, h = 1 === p % 2 ? (e.x << 0) + 0.5 :\r\n                        e.x << 0, \"top\" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, l = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, l = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c - p / 2, y1: e, x2: h + p / 2, y2: l }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"top\" === this.scaleBreaks.parent._position && 0 >= a || \"bottom\" === this.scaleBreaks.parent._position && 0 <= a)\r\n                        this.ctx.lineTo(c, l), this.ctx.lineTo(h, l), this.ctx.lineTo(h, e);\r\n                    else if (\"wavy\" === this.type) {\r\n                        m = c;\r\n                        k = e;\r\n                        g = 0.5;\r\n                        r = (l - k) / a / 3;\r\n                        for (var n = 0; n < r; n++)\r\n                            this.ctx.bezierCurveTo(m +\r\n                                g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a), k += 3 * a, g *= -1;\r\n                        this.ctx.bezierCurveTo(m + g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a);\r\n                        m = h;\r\n                        g *= -1;\r\n                        this.ctx.lineTo(m, k);\r\n                        for (n = 0; n < r; n++)\r\n                            this.ctx.bezierCurveTo(m + g * a, k - a, m + g * a, k - 2 * a, m, k - 3 * a), k -= 3 * a, g *= -1;\r\n                    }\r\n                    else {\r\n                        if (\"zigzag\" === this.type) {\r\n                            g = -1;\r\n                            k = e + a;\r\n                            m = c + a;\r\n                            r = (l - k) / a / 2;\r\n                            for (n = 0; n < r; n++)\r\n                                this.ctx.lineTo(m, k), m += 2 * g * a, k += 2 * a, g *= -1;\r\n                            this.ctx.lineTo(m, k);\r\n                            m += h - c;\r\n                            for (n = 0; n < r + 1; n++)\r\n                                this.ctx.lineTo(m, k), m += 2 * g * a, k -= 2 * a, g *= -1;\r\n                            this.ctx.lineTo(m + g * a, k + a);\r\n                        }\r\n                    }\r\n                else if (\"left\" === this.scaleBreaks.parent._position || \"right\" ===\r\n                    this.scaleBreaks.parent._position)\r\n                    if (e = 1 === p % 2 ? (e.y << 0) + 0.5 : e.y << 0, l = 1 === p % 2 ? (c.y << 0) + 0.5 : c.y << 0, \"left\" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, h = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, h = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = { x1: c, y1: e - p / 2, x2: h, y2: l + p / 2 }, this.ctx.moveTo(c, e), \"straight\" === this.type || \"left\" === this.scaleBreaks.parent._position && 0 >= a || \"right\" === this.scaleBreaks.parent._position && 0 <= a)\r\n                        this.ctx.lineTo(h, e), this.ctx.lineTo(h, l),\r\n                            this.ctx.lineTo(c, l);\r\n                    else if (\"wavy\" === this.type) {\r\n                        m = c;\r\n                        k = e;\r\n                        g = 0.5;\r\n                        r = (h - m) / a / 3;\r\n                        for (n = 0; n < r; n++)\r\n                            this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k), m += 3 * a, g *= -1;\r\n                        this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k);\r\n                        k = l;\r\n                        g *= -1;\r\n                        this.ctx.lineTo(m, k);\r\n                        for (n = 0; n < r; n++)\r\n                            this.ctx.bezierCurveTo(m - a, k + g * a, m - 2 * a, k + g * a, m - 3 * a, k), m -= 3 * a, g *= -1;\r\n                    }\r\n                    else if (\"zigzag\" === this.type) {\r\n                        g = 1;\r\n                        k = e - a;\r\n                        m = c + a;\r\n                        r = (h - m) / a / 2;\r\n                        for (n = 0; n < r; n++)\r\n                            this.ctx.lineTo(m, k), k += 2 * g * a, m += 2 * a, g *= -1;\r\n                        this.ctx.lineTo(m, k);\r\n                        k += l - e;\r\n                        for (n = 0; n < r + 1; n++)\r\n                            this.ctx.lineTo(m, k), k += 2 * g * a, m -= 2 * a, g *= -1;\r\n                        this.ctx.lineTo(m + a, k + g * a);\r\n                    }\r\n                0 < p && this.ctx.stroke();\r\n                this.ctx.closePath();\r\n                this.ctx.globalAlpha = this.fillOpacity;\r\n                this.ctx.globalCompositeOperation = \"destination-over\";\r\n                this.ctx.fill();\r\n                this.ctx.restore();\r\n                this.ctx.globalAlpha = b;\r\n                this.ctx = f;\r\n            }\r\n        };\r\n        oa(fa, Y);\r\n        fa.prototype.createUserOptions = function (a) {\r\n            if (\"undefined\" !== typeof a || this.options._isPlaceholder) {\r\n                var f = 0;\r\n                this.parent.options._isPlaceholder && this.parent.createUserOptions();\r\n                this.options._isPlaceholder || (Da(this.parent.stripLines), f =\r\n                    this.parent.options.stripLines.indexOf(this.options));\r\n                this.options = \"undefined\" === typeof a ? {} : a;\r\n                this.parent.options.stripLines[f] = this.options;\r\n            }\r\n        };\r\n        fa.prototype.render = function () {\r\n            this.ctx.save();\r\n            var a = this.parent.getPixelCoordinatesOnAxis(this.value), f = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);\r\n            if (0 < f) {\r\n                var b = null === this.opacity ? 1 : this.opacity;\r\n                this.ctx.strokeStyle = this.color;\r\n                this.ctx.beginPath();\r\n                var c = this.ctx.globalAlpha;\r\n                this.ctx.globalAlpha =\r\n                    b;\r\n                S(this.id);\r\n                var e, g, h, l;\r\n                this.ctx.lineWidth = f;\r\n                this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, f));\r\n                if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\r\n                    e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, h = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = { x1: e - f / 2, y1: h, x2: g + f / 2, y2: l };\r\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\r\n                    h = l = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds =\r\n                        { x1: e, y1: h - f / 2, x2: g, y2: l + f / 2 };\r\n                this.ctx.moveTo(e, h);\r\n                this.ctx.lineTo(g, l);\r\n                this.ctx.stroke();\r\n                this.ctx.globalAlpha = c;\r\n            }\r\n            this.ctx.restore();\r\n        };\r\n        oa(ha, Y);\r\n        ha.prototype.render = function (a, f) {\r\n            var b, c, e, g, h = null, l = h = null, m = \"\";\r\n            if (!this.valueFormatString)\r\n                if (\"dateTime\" === this.parent.valueType)\r\n                    this.valueFormatString = this.parent.valueFormatString;\r\n                else {\r\n                    var k = 0, k = \"xySwapped\" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) /\r\n                        Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);\r\n                    this.valueFormatString = C.generateValueFormatString(this.parent.range, k);\r\n                }\r\n            var l = null === this.opacity ? 1 : this.opacity, k = Math.abs(\"pixel\" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), r = this.chart.overlaidCanvasCtx, p = r.globalAlpha;\r\n            r.globalAlpha = l;\r\n            r.beginPath();\r\n            r.strokeStyle = this.color;\r\n            r.lineWidth = k;\r\n            r.save();\r\n            this.labelFontSize = y(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize;\r\n            if (\"left\" === this.parent._position || \"right\" === this.parent._position)\r\n                this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize;\r\n            else if (\"top\" === this.parent._position || \"bottom\" === this.parent._position)\r\n                this.labelMaxWidth =\r\n                    y(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize;\r\n            0 < k && r.setLineDash && r.setLineDash(G(this.lineDashType, k));\r\n            l = new ka(r, { x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 }, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight,\r\n                angle: this.labelAngle, text: m, horizontalAlign: \"left\", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: \"middle\" });\r\n            if (this.snapToDataPoint) {\r\n                var n = 0, h = [];\r\n                if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\r\n                    var d = null;\r\n                    if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\r\n                        n = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: f });\r\n                    else if (\"left\" === this.parent._position || \"right\" ===\r\n                        this.parent._position)\r\n                        n = this.parent.convertPixelToValue({ y: f });\r\n                    for (var q = 0; q < this.parent.dataSeries.length; q++)\r\n                        (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\r\n                    d = null;\r\n                    if (0 === h.length)\r\n                        return;\r\n                    h.sort(function (a, b) { return a.distance - b.distance; });\r\n                    d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));\r\n                    q = 0;\r\n                    if (\"rangeBar\" === h[0].dataSeries.type || \"error\" === h[0].dataSeries.type)\r\n                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[q].dataPoint.y[0])), s = 0, n = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\r\n                    else if (\"stackedBar\" === h[0].dataSeries.type)\r\n                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), v = s = 0, n = q = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(a -\r\n                                        this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);\r\n                    else if (\"stackedBar100\" === h[0].dataSeries.type)\r\n                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), u = v = s = 0, n = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ?\r\n                                    h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);\r\n                    else\r\n                        for (d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = q = s = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s,\r\n                                    q = n);\r\n                    m = h[q];\r\n                    if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\r\n                        b = 0;\r\n                        if (\"rangeBar\" === this.parent.dataSeries[q].type || \"error\" === this.parent.dataSeries[q].type) {\r\n                            d = Math.abs(a - this.parent.convertValueToPixel(m.dataPoint.y[0]));\r\n                            for (n = s = 0; n < m.dataPoint.y.length; n++)\r\n                                s = Math.abs(a - this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);\r\n                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;\r\n                            l.text = this.labelFormatter ?\r\n                                this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y[b] }) : y(this.options.label) ? X(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                        }\r\n                        else if (\"stackedBar\" === this.parent.dataSeries[q].type) {\r\n                            d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));\r\n                            v = s = 0;\r\n                            for (n = q; 0 <= n; n--)\r\n                                v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);\r\n                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 :\r\n                                this.parent.convertValueToPixel(v) << 0;\r\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? X(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                        }\r\n                        else if (\"stackedBar100\" === this.parent.dataSeries[q].type) {\r\n                            d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));\r\n                            u = v = s = 0;\r\n                            for (n = q; 0 <= n; n--)\r\n                                v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x,\r\n                                    u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);\r\n                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) + 0.5 : this.parent.convertValueToPixel(u) << 0;\r\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: u }) : y(this.options.label) ? X(u, this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                        }\r\n                        else\r\n                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) <<\r\n                                0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? X(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                        b = c = h;\r\n                        e = this.chart.plotArea.y1;\r\n                        g = this.chart.plotArea.y2;\r\n                        this.bounds = { x1: b - k / 2, y1: e, x2: c + k / 2, y2: g };\r\n                        l.x = b - l.measureText().width / 2;\r\n                        l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 &&\r\n                            (l.x = this.chart.bounds.x1);\r\n                        l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2;\r\n                    }\r\n                    else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\r\n                        e = g = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;\r\n                        b = this.chart.plotArea.x1;\r\n                        c = this.chart.plotArea.x2;\r\n                        this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };\r\n                        u = !1;\r\n                        if (this.parent.labels)\r\n                            for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)\r\n                                if (this.parent.labels[n])\r\n                                    u =\r\n                                        !0;\r\n                                else {\r\n                                    u = !1;\r\n                                    break;\r\n                                }\r\n                        if (u) {\r\n                            if (\"axisX\" === this.parent.type)\r\n                                for (n = this.parent.convertPixelToValue({ y: f }), d = null, q = 0; q < this.parent.dataSeries.length; q++)\r\n                                    (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? d.dataPoint.label : this.label);\r\n                        }\r\n                        else\r\n                            \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\r\n                                axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? X(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);\r\n                        l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;\r\n                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ?\r\n                            l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\r\n                        \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\r\n                    }\r\n                }\r\n                else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\r\n                    n = this.parent.convertPixelToValue({ x: a });\r\n                    for (q = 0; q < this.parent.dataSeries.length; q++)\r\n                        (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\r\n                    if (0 === h.length)\r\n                        return;\r\n                    h.sort(function (a, b) { return a.distance - b.distance; });\r\n                    m = h[0];\r\n                    b = c = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;\r\n                    e = this.chart.plotArea.y1;\r\n                    g = this.chart.plotArea.y2;\r\n                    this.bounds = { x1: b - k / 2, y1: e, x2: c + k / 2, y2: g };\r\n                    u = !1;\r\n                    if (this.parent.labels)\r\n                        for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)\r\n                            if (this.parent.labels[n])\r\n                                u =\r\n                                    !0;\r\n                            else {\r\n                                u = !1;\r\n                                break;\r\n                            }\r\n                    if (u) {\r\n                        if (\"axisX\" === this.parent.type)\r\n                            for (n = this.parent.convertPixelToValue({ x: a }), d = null, q = 0; q < this.parent.dataSeries.length; q++)\r\n                                (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? d.dataPoint.label : this.label);\r\n                    }\r\n                    else\r\n                        \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\r\n                            axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.x }) : y(this.options.label) ? X(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);\r\n                    l.x = b - l.measureText().width / 2;\r\n                    l.x + l.width > this.chart.bounds.x2 && (l.x =\r\n                        this.chart.bounds.x2 - l.width);\r\n                    l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\r\n                    \"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\r\n                }\r\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\r\n                    !y(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (n = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a }));\r\n                    for (q = 0; q < this.parent.dataSeries.length; q++)\r\n                        (d =\r\n                            this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));\r\n                    if (0 === h.length)\r\n                        return;\r\n                    h.sort(function (a, b) { return a.distance - b.distance; });\r\n                    q = 0;\r\n                    if (\"rangeColumn\" === h[0].dataSeries.type || \"rangeArea\" === h[0].dataSeries.type || \"error\" === h[0].dataSeries.type || \"rangeSplineArea\" === h[0].dataSeries.type || \"candlestick\" === h[0].dataSeries.type || \"ohlc\" === h[0].dataSeries.type || \"boxAndWhisker\" === h[0].dataSeries.type)\r\n                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y[0])),\r\n                            n = s = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\r\n                    else if (\"stackedColumn\" === h[0].dataSeries.type || \"stackedArea\" === h[0].dataSeries.type)\r\n                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = v = s = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m <\r\n                                    h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);\r\n                    else if (\"stackedColumn100\" === h[0].dataSeries.type || \"stackedArea100\" === h[0].dataSeries.type)\r\n                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = u = v = s = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])),\r\n                                        s < d && (d = s, q = n);\r\n                            else\r\n                                v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);\r\n                    else\r\n                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = s = 0; n < h.length; n++)\r\n                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)\r\n                                for (m = 0; m < h[n].dataPoint.y.length; m++)\r\n                                    s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);\r\n                            else\r\n                                s = Math.abs(f -\r\n                                    this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);\r\n                    m = h[q];\r\n                    b = 0;\r\n                    if (\"rangeColumn\" === this.parent.dataSeries[q].type || \"rangeArea\" === this.parent.dataSeries[q].type || \"error\" === this.parent.dataSeries[q].type || \"rangeSplineArea\" === this.parent.dataSeries[q].type || \"candlestick\" === this.parent.dataSeries[q].type || \"ohlc\" === this.parent.dataSeries[q].type || \"boxAndWhisker\" === this.parent.dataSeries[q].type) {\r\n                        d = Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[0]));\r\n                        for (n = s = 0; n < m.dataPoint.y.length; n++)\r\n                            s =\r\n                                Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);\r\n                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;\r\n                        l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y[b] }) : y(this.options.label) ? X(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                    }\r\n                    else if (\"stackedColumn\" === this.parent.dataSeries[q].type ||\r\n                        \"stackedArea\" === this.parent.dataSeries[q].type) {\r\n                        d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));\r\n                        v = s = 0;\r\n                        for (n = q; 0 <= n; n--)\r\n                            v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);\r\n                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 : this.parent.convertValueToPixel(v) << 0;\r\n                        l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? X(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                    }\r\n                    else if (\"stackedColumn100\" === this.parent.dataSeries[q].type || \"stackedArea100\" === this.parent.dataSeries[q].type) {\r\n                        d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));\r\n                        v = s = 0;\r\n                        for (n = q; 0 <= n; n--)\r\n                            v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);\r\n                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) +\r\n                            0.5 : this.parent.convertValueToPixel(u) << 0;\r\n                        l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: u }) : y(this.options.label) ? X(u, this.valueFormatString, this.chart._cultureInfo) : this.label;\r\n                    }\r\n                    else\r\n                        \"waterfall\" === this.parent.dataSeries[q].type ? (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) << 0, l.text =\r\n                            this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: m.dataSeries.dataPointEOs[m.index].cumulativeSum }) : y(this.options.label) ? X(m.dataSeries.dataPointEOs[m.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options,\r\n                            crosshair: this.options, value: m.dataPoint.y }) : y(this.options.label) ? X(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label);\r\n                    e = g = h;\r\n                    b = this.chart.plotArea.x1;\r\n                    c = this.chart.plotArea.x2;\r\n                    this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };\r\n                    l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;\r\n                    l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\r\n                    \"left\" === this.parent._position ?\r\n                        l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\r\n                }\r\n                h = null;\r\n                (\"bottom\" === this.parent._position || \"top\" === this.parent._position) && (b >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && c <= this.parent.convertValueToPixel(this.parent.viewportMaximum)) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));\r\n                (\"left\" === this.parent._position ||\r\n                    \"right\" === this.parent._position) && (g >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && e <= this.parent.convertValueToPixel(this.parent.viewportMinimum)) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));\r\n            }\r\n            else {\r\n                if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\r\n                    b = c = h = 1 === r.lineWidth % 2 ? (a << 0) + 0.5 : a << 0, e = this.chart.plotArea.y1, g = this.chart.plotArea.y2, this.bounds = { x1: b - k / 2, y1: e, x2: c + k /\r\n                            2, y2: g };\r\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\r\n                    e = g = h = 1 === r.lineWidth % 2 ? (f << 0) + 0.5 : f << 0, b = this.chart.plotArea.x1, c = this.chart.plotArea.x2, this.bounds = { x1: b, y1: e - k / 2, x2: c, y2: g + k / 2 };\r\n                if (\"xySwapped\" === this.chart.plotInfo.axisPlacement)\r\n                    if (\"left\" === this.parent._position || \"right\" === this.parent._position) {\r\n                        u = !1;\r\n                        if (this.parent.labels)\r\n                            for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)\r\n                                if (this.parent.labels[n])\r\n                                    u = !0;\r\n                                else {\r\n                                    u = !1;\r\n                                    break;\r\n                                }\r\n                        if (u) {\r\n                            if (\"axisX\" === this.parent.type)\r\n                                for (n =\r\n                                    this.parent.convertPixelToValue({ y: f }), d = null, q = 0; q < this.parent.dataSeries.length; q++)\r\n                                    (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? d.dataPoint.label : this.label);\r\n                        }\r\n                        else\r\n                            \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options,\r\n                                value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? X(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label);\r\n                        l.y = f + l.fontSize / 2 - l.measureText().height /\r\n                            2 + 2;\r\n                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);\r\n                        \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\r\n                    }\r\n                    else {\r\n                        if (\"bottom\" === this.parent._position || \"top\" === this.parent._position)\r\n                            l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\r\n                                axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? X(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = b - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), \"bottom\" === this.parent._position && (l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2), \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 -\r\n                                l.height + l.fontSize / 2 + 2);\r\n                    }\r\n                else if (\"bottom\" === this.parent._position || \"top\" === this.parent._position) {\r\n                    u = !1;\r\n                    m = \"\";\r\n                    if (this.parent.labels)\r\n                        for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)\r\n                            if (this.parent.labels[n])\r\n                                u = !0;\r\n                            else {\r\n                                u = !1;\r\n                                break;\r\n                            }\r\n                    if (u) {\r\n                        if (\"axisX\" === this.parent.type)\r\n                            for (n = this.parent.convertPixelToValue({ x: a }), d = null, q = 0; q < this.parent.dataSeries.length; q++)\r\n                                (d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart,\r\n                                    axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? d.dataPoint.label : this.label);\r\n                    }\r\n                    else\r\n                        \"dateTime\" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(a) }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label : \"number\" === this.parent.valueType && (l.text = this.labelFormatter ?\r\n                            this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : \"\" }) : y(this.options.label) ? X(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label);\r\n                    l.x = b - l.measureText().width / 2;\r\n                    l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);\r\n                    l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);\r\n                    \"bottom\" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 +\r\n                        l.fontSize / 2 + 2 : \"top\" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2);\r\n                }\r\n                else if (\"left\" === this.parent._position || \"right\" === this.parent._position)\r\n                    l.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: this.parent.convertPixelToValue(f) }) : y(this.options.label) ? X(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label, l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y -\r\n                        l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2), \"left\" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : \"right\" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);\r\n                0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke());\r\n                r.restore();\r\n                !y(l.text) && (\"number\" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0);\r\n            }\r\n            r.globalAlpha =\r\n                p;\r\n        };\r\n        oa(Z, Y);\r\n        Z.prototype._initialize = function () {\r\n            if (this.enabled) {\r\n                this.container = document.createElement(\"div\");\r\n                this.container.setAttribute(\"class\", \"canvasjs-chart-tooltip\");\r\n                this.container.style.position = \"absolute\";\r\n                this.container.style.height = \"auto\";\r\n                this.container.style.boxShadow = \"1px 1px 2px 2px rgba(0,0,0,0.1)\";\r\n                this.container.style.zIndex = \"1000\";\r\n                this.container.style.pointerEvents = \"none\";\r\n                this.container.style.display = \"none\";\r\n                var a;\r\n                a = '<div style=\" width: auto;height: auto;min-width: 50px;';\r\n                a += \"line-height: auto;\";\r\n                a += \"margin: 0px 0px 0px 0px;\";\r\n                a += \"padding: 5px;\";\r\n                a += \"font-family: Calibri, Arial, Georgia, serif;\";\r\n                a += \"font-weight: normal;\";\r\n                a += \"font-style: \" + (v ? \"italic;\" : \"normal;\");\r\n                a += \"font-size: 14px;\";\r\n                a += \"color: #000000;\";\r\n                a += \"text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);\";\r\n                a += \"text-align: left;\";\r\n                a += \"border: 2px solid gray;\";\r\n                a += v ? \"background: rgba(255,255,255,.9);\" : \"background: rgb(255,255,255);\";\r\n                a += \"text-indent: 0px;\";\r\n                a += \"white-space: nowrap;\";\r\n                a += \"border-radius: 5px;\";\r\n                a += \"-moz-user-select:none;\";\r\n                a += \"-khtml-user-select: none;\";\r\n                a += \"-webkit-user-select: none;\";\r\n                a += \"-ms-user-select: none;\";\r\n                a += \"user-select: none;\";\r\n                v || (a += \"filter: alpha(opacity = 90);\", a += \"filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');\");\r\n                a += '} \"> Sample Tooltip</div>';\r\n                this.container.innerHTML = a;\r\n                this.contentDiv = this.container.firstChild;\r\n                this.container.style.borderRadius = this.contentDiv.style.borderRadius;\r\n                this.chart._canvasJSContainer.appendChild(this.container);\r\n            }\r\n        };\r\n        Z.prototype.mouseMoveHandler = function (a, f) {\r\n            this._lastUpdated &&\r\n                4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, f));\r\n        };\r\n        Z.prototype._updateToolTip = function (a, f, b) {\r\n            b = \"undefined\" === typeof b ? !0 : b;\r\n            this.container || this._initialize();\r\n            this.enabled || this.hide();\r\n            if (!this.chart.disableToolTip) {\r\n                if (\"undefined\" === typeof a || \"undefined\" === typeof f) {\r\n                    if (isNaN(this._prevX) || isNaN(this._prevY))\r\n                        return;\r\n                    a = this._prevX;\r\n                    f = this._prevY;\r\n                }\r\n                else\r\n                    this._prevX = a, this._prevY = f;\r\n                var c = null, e = null, g = [], h = 0;\r\n                if (this.shared &&\r\n                    this.enabled && \"none\" !== this.chart.plotInfo.axisPlacement) {\r\n                    if (\"xySwapped\" === this.chart.plotInfo.axisPlacement) {\r\n                        var l = [];\r\n                        if (this.chart.axisX)\r\n                            for (var m = 0; m < this.chart.axisX.length; m++) {\r\n                                for (var h = this.chart.axisX[m].convertPixelToValue({ y: f }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++)\r\n                                    (k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\r\n                                k = null;\r\n                            }\r\n                        if (this.chart.axisX2)\r\n                            for (m = 0; m < this.chart.axisX2.length; m++) {\r\n                                h =\r\n                                    this.chart.axisX2[m].convertPixelToValue({ y: f });\r\n                                k = null;\r\n                                for (c = 0; c < this.chart.axisX2[m].dataSeries.length; c++)\r\n                                    (k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\r\n                                k = null;\r\n                            }\r\n                    }\r\n                    else {\r\n                        l = [];\r\n                        if (this.chart.axisX)\r\n                            for (m = 0; m < this.chart.axisX.length; m++)\r\n                                for (h = this.chart.axisX[m].convertPixelToValue({ x: a }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++)\r\n                                    (k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\r\n                        if (this.chart.axisX2)\r\n                            for (m = 0; m < this.chart.axisX2.length; m++)\r\n                                for (h = this.chart.axisX2[m].convertPixelToValue({ x: a }), k = null, c = 0; c < this.chart.axisX2[m].dataSeries.length; c++)\r\n                                    (k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));\r\n                    }\r\n                    if (0 === l.length)\r\n                        return;\r\n                    l.sort(function (a, b) { return a.distance - b.distance; });\r\n                    b = l[0];\r\n                    for (c = 0; c < l.length; c++)\r\n                        l[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() && g.push(l[c]);\r\n                    l = null;\r\n                }\r\n                else {\r\n                    if (k = this.chart.getDataPointAtXY(a, f, b))\r\n                        this.currentDataPointIndex = k.dataPointIndex, this.currentSeriesIndex = k.dataSeries.index;\r\n                    else if (v)\r\n                        if (k = Xa(a, f, this.chart._eventManager.ghostCtx), 0 < k && \"undefined\" !== typeof this.chart._eventManager.objectMap[k]) {\r\n                            k = this.chart._eventManager.objectMap[k];\r\n                            if (\"legendItem\" === k.objectType)\r\n                                return;\r\n                            this.currentSeriesIndex = k.dataSeriesIndex;\r\n                            this.currentDataPointIndex = 0 <=\r\n                                k.dataPointIndex ? k.dataPointIndex : -1;\r\n                        }\r\n                        else\r\n                            this.currentDataPointIndex = -1;\r\n                    else\r\n                        this.currentDataPointIndex = -1;\r\n                    if (0 <= this.currentSeriesIndex) {\r\n                        e = this.chart.data[this.currentSeriesIndex];\r\n                        k = {};\r\n                        if (0 <= this.currentDataPointIndex)\r\n                            c = e.dataPoints[this.currentDataPointIndex], k.dataSeries = e, k.dataPoint = c, k.index = this.currentDataPointIndex, k.distance = Math.abs(c.x - h), \"waterfall\" === e.type && (k.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);\r\n                        else {\r\n                            if (!this.enabled || \"line\" !== e.type && \"stepLine\" !== e.type && \"spline\" !== e.type && \"area\" !== e.type && \"stepArea\" !== e.type && \"splineArea\" !== e.type && \"stackedArea\" !== e.type && \"stackedArea100\" !== e.type && \"rangeArea\" !== e.type && \"rangeSplineArea\" !== e.type && \"candlestick\" !== e.type && \"ohlc\" !== e.type && \"boxAndWhisker\" !== e.type)\r\n                                return;\r\n                            h = e.axisX.convertPixelToValue({ x: a });\r\n                            k = e.getDataPointAtX(h, b);\r\n                            k.dataSeries = e;\r\n                            this.currentDataPointIndex = k.index;\r\n                            c = k.dataPoint;\r\n                        }\r\n                        if (!y(k.dataPoint.y))\r\n                            if (k.dataSeries.axisY)\r\n                                if (0 < k.dataPoint.y.length) {\r\n                                    for (c =\r\n                                        b = 0; c < k.dataPoint.y.length; c++)\r\n                                        k.dataPoint.y[c] < k.dataSeries.axisY.viewportMinimum ? b-- : k.dataPoint.y[c] > k.dataSeries.axisY.viewportMaximum && b++;\r\n                                    b < k.dataPoint.y.length && b > -k.dataPoint.y.length && g.push(k);\r\n                                }\r\n                                else\r\n                                    \"column\" === e.type || \"bar\" === e.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && g.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && g.push(k) : \"bubble\" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[k.index]].size /\r\n                                        2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - b && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + b && g.push(k)) : \"waterfall\" === e.type ? (b = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && b++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(k)) : (0 <= k.dataSeries.type.indexOf(\"100\") || \"stackedColumn\" === e.type || \"stackedBar\" === e.type || k.dataPoint.y >=\r\n                                        k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && g.push(k);\r\n                            else\r\n                                g.push(k);\r\n                    }\r\n                }\r\n                if (0 < g.length && (this.highlightObjects(g), this.enabled))\r\n                    if (b = \"\", b = this.getToolTipInnerHTML({ entries: g }), null !== b) {\r\n                        this.contentDiv.innerHTML = b;\r\n                        b = !1;\r\n                        \"none\" === this.container.style.display && (b = !0, this.container.style.display = \"block\");\r\n                        try {\r\n                            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? \"rgba(255,255,255,.9)\" : \"rgb(255,255,255)\", this.borderColor = \"waterfall\" === g[0].dataSeries.type ?\r\n                                this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : 0 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : \"error\" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color :\r\n                                g[0].dataSeries._colorSet[e.index % g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + \"px\" : \"2px\", this.contentDiv.style.borderRadius =\r\n                                this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + \"px\" : \"5px\", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + \"px\" : \"14px\", this.contentDiv.style.color = this.fontColor ? this.fontColor : \"#000000\", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : \"Calibri, Arial, Georgia, serif;\", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : \"normal\", this.contentDiv.style.fontStyle =\r\n                                this.fontStyle ? this.fontStyle : v ? \"italic\" : \"normal\";\r\n                        }\r\n                        catch (q) { }\r\n                        \"pie\" === g[0].dataSeries.type || \"doughnut\" === g[0].dataSeries.type || \"funnel\" === g[0].dataSeries.type || \"pyramid\" === g[0].dataSeries.type || \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" === g[0].dataSeries.type || \"stackedBar100\" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);\r\n                        0 > a && (a += this.container.clientWidth +\r\n                            20);\r\n                        a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));\r\n                        f = 1 !== g.length || this.shared || \"line\" !== g[0].dataSeries.type && \"stepLine\" !== g[0].dataSeries.type && \"spline\" !== g[0].dataSeries.type && \"area\" !== g[0].dataSeries.type && \"stepArea\" !== g[0].dataSeries.type && \"splineArea\" !== g[0].dataSeries.type ? \"bar\" === g[0].dataSeries.type || \"rangeBar\" === g[0].dataSeries.type || \"stackedBar\" ===\r\n                            g[0].dataSeries.type || \"stackedBar100\" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : f : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y);\r\n                        f = -f + 10;\r\n                        0 < f + this.container.clientHeight + 5 && (f -= f + this.container.clientHeight + 5 - 0);\r\n                        this.fixMozTransitionDelay(a, f);\r\n                        !this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);\r\n                        this.container.style.left = a + \"px\";\r\n                        this.container.style.bottom = f + \"px\";\r\n                    }\r\n                    else\r\n                        this.hide(!1);\r\n            }\r\n        };\r\n        Z.prototype.highlightObjects = function (a) {\r\n            var f = this.chart.overlaidCanvasCtx;\r\n            this.chart.resetOverlayedCanvas();\r\n            f.clearRect(0, 0, this.chart.width, this.chart.height);\r\n            f.save();\r\n            var b = this.chart.plotArea, c = 0;\r\n            f.beginPath();\r\n            f.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);\r\n            f.clip();\r\n            for (b = 0; b < a.length; b++) {\r\n                var e = a[b];\r\n                if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && \"dataPoint\" === e.objectType) {\r\n                    var c = this.chart.data[e.dataSeriesIndex], g = c.dataPoints[e.dataPointIndex], h = e.dataPointIndex;\r\n                    !1 === g.highlightEnabled || !0 !== c.highlightEnabled && !0 !== g.highlightEnabled || (\"line\" === c.type || \"stepLine\" === c.type || \"spline\" === c.type || \"scatter\" === c.type || \"area\" === c.type || \"stepArea\" === c.type || \"splineArea\" === c.type || \"stackedArea\" === c.type || \"stackedArea100\" === c.type || \"rangeArea\" === c.type || \"rangeSplineArea\" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 *\r\n                        g.size), ia.drawMarkers([g]), \"undefined\" !== typeof e.y2 && (g = c.getMarkerProperties(h, e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || \"#FFFFFF\", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ia.drawMarkers([g]))) : \"bubble\" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = \"white\", g.borderColor = \"white\", f.globalAlpha = 0.3, ia.drawMarkers([g]), f.globalAlpha = 1) : \"column\" === c.type || \"stackedColumn\" ===\r\n                        c.type || \"stackedColumn100\" === c.type || \"bar\" === c.type || \"rangeBar\" === c.type || \"stackedBar\" === c.type || \"stackedBar100\" === c.type || \"rangeColumn\" === c.type || \"waterfall\" === c.type ? W(f, e.x1, e.y1, e.x2, e.y2, \"white\", 0, null, !1, !1, !1, !1, 0.3) : \"pie\" === c.type || \"doughnut\" === c.type ? qa(f, e.center, e.radius, \"white\", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : \"funnel\" === c.type || \"pyramid\" === c.type ? ra(f, e.funnelSection, 0.3, \"white\") : \"candlestick\" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness,\r\n                        c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), f.lineTo(e.x3 - c, Math.min(e.y1, e.y4)), f.stroke(), f.beginPath(), f.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), f.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), f.stroke(), W(f, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), \"transparent\", 2 * e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1) : \"ohlc\" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness, c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, e.y2), f.lineTo(e.x3 -\r\n                        c, e.y3), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y1), f.lineTo(e.x1, e.y1), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4), f.lineTo(e.x2, e.y4), f.stroke(), f.globalAlpha = 1) : \"boxAndWhisker\" === c.type ? (f.save(), f.globalAlpha = 1, f.strokeStyle = e.stemColor, f.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (f.beginPath(), f.moveTo(e.x3, e.y2 + e.borderThickness / 2), f.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), f.lineTo(e.x3, e.y3 - e.borderThickness / 2), f.stroke()),\r\n                        f.beginPath(), W(f, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), \"transparent\", e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1, f.strokeStyle = e.whiskerColor, f.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (f.beginPath(), f.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), f.stroke(), f.beginPath(), f.moveTo(Math.floor(e.x3 -\r\n                        e.whiskerLength / 2), e.y1), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), f.stroke()), f.globalAlpha = 1, f.strokeStyle = e.lineColor, f.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (f.beginPath(), f.moveTo(e.x1, e.y5), f.lineTo(e.x2, e.y5), f.stroke()), f.restore(), f.globalAlpha = 1) : \"error\" === c.type && z(f, e.x1, e.y1, e.x2, e.y2, \"white\", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));\r\n                }\r\n            }\r\n            f.restore();\r\n            f.globalAlpha = 1;\r\n            f.beginPath();\r\n        };\r\n        Z.prototype.getToolTipInnerHTML = function (a) {\r\n            a = a.entries;\r\n            for (var f = null, b = null, c = null, e = 0, g = \"\", h = !0, l = 0; l < a.length; l++)\r\n                if (a[l].dataSeries.toolTipContent || a[l].dataPoint.toolTipContent) {\r\n                    h = !1;\r\n                    break;\r\n                }\r\n            if (h && (this.content && \"function\" === typeof this.content || this.contentFormatter))\r\n                a = { chart: this.chart, toolTip: this.options, entries: a }, f = this.contentFormatter ? this.contentFormatter(a) : this.content(a);\r\n            else if (this.shared && \"none\" !== this.chart.plotInfo.axisPlacement) {\r\n                for (var m = null, k = \"\", l = 0; l < a.length; l++)\r\n                    b = a[l].dataSeries, c = a[l].dataPoint, e = a[l].index, g = \"\", 0 === l && (h && !this.content) && (this.chart.axisX &&\r\n                        0 < this.chart.axisX.length ? k += \"undefined\" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] : \"{x}\" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (k += \"undefined\" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : \"{x}\"), k += \"</br>\", k = this.chart.replaceKeywordsWithValue(k, c, b, e)), null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent || (\"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" ===\r\n                        b.type || \"splineArea\" === b.type || \"column\" === b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ?\r\n                        this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}\", m = b.axisXIndex) : \"bubble\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\") :\r\n                        \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}\") : \"candlestick\" ===\r\n                            b.type || \"ohlc\" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\") : \"boxAndWhisker\" ===\r\n                            b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + \"<br/>\" : \"X:{axisXIndex}<br/>\" : \"\"), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\"),\r\n                        null === f && (f = \"\"), !0 === this.reversed ? (f = this.chart.replaceKeywordsWithValue(g, c, b, e) + f, l < a.length - 1 && (f = \"</br>\" + f)) : (f += this.chart.replaceKeywordsWithValue(g, c, b, e), l < a.length - 1 && (f += \"</br>\")));\r\n                null !== f && (f = k + f);\r\n            }\r\n            else {\r\n                b = a[0].dataSeries;\r\n                c = a[0].dataPoint;\r\n                e = a[0].index;\r\n                if (null === c.toolTipContent || \"undefined\" === typeof c.toolTipContent && null === b.options.toolTipContent)\r\n                    return null;\r\n                \"line\" === b.type || \"stepLine\" === b.type || \"spline\" === b.type || \"area\" === b.type || \"stepArea\" === b.type || \"splineArea\" === b.type || \"column\" ===\r\n                    b.type || \"bar\" === b.type || \"scatter\" === b.type || \"stackedColumn\" === b.type || \"stackedColumn100\" === b.type || \"stackedBar\" === b.type || \"stackedBar100\" === b.type || \"stackedArea\" === b.type || \"stackedArea100\" === b.type || \"waterfall\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}\" : \"bubble\" === b.type ? g = c.toolTipContent ?\r\n                    c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}\" : \"pie\" === b.type || \"doughnut\" === b.type || \"funnel\" === b.type || \"pyramid\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" :\r\n                    \"'color:{color};'\") + \"\\\"'>\" + (c.name ? \"{name}:</span>&nbsp;&nbsp;\" : c.label ? \"{label}:</span>&nbsp;&nbsp;\" : \"</span>\") + \"{y}\" : \"rangeColumn\" === b.type || \"rangeBar\" === b.type || \"rangeArea\" === b.type || \"rangeSplineArea\" === b.type || \"error\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \" :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}\" :\r\n                    \"candlestick\" === b.type || \"ohlc\" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}\" : \"boxAndWhisker\" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent :\r\n                        this.content && \"function\" !== typeof this.content ? this.content : \"<span style='\\\"\" + (this.options.fontColor ? \"\" : \"'color:{color};'\") + \"\\\"'>\" + (c.label ? \"{label}\" : \"{x}\") + \"</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}\");\r\n                null === f && (f = \"\");\r\n                f += this.chart.replaceKeywordsWithValue(g, c, b, e);\r\n            }\r\n            return f;\r\n        };\r\n        Z.prototype.enableAnimation = function () { if (!this.container.style.WebkitTransition) {\r\n            var a = this.getContainerTransition(this.containerTransitionDuration);\r\n            this.container.style.WebkitTransition = a;\r\n            this.container.style.MsTransition = a;\r\n            this.container.style.transition = a;\r\n            this.container.style.MozTransition = this.mozContainerTransition;\r\n        } };\r\n        Z.prototype.disableAnimation = function () {\r\n            this.container.style.WebkitTransition && (this.container.style.WebkitTransition =\r\n                \"\", this.container.style.MozTransition = \"\", this.container.style.MsTransition = \"\", this.container.style.transition = \"\");\r\n        };\r\n        Z.prototype.hide = function (a) { this.container && (this.container.style.display = \"none\", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, (\"undefined\" === typeof a || a) && this.chart.resetOverlayedCanvas()); };\r\n        Z.prototype.show = function (a, f, b) { this._updateToolTip(a, f, \"undefined\" === typeof b ? !1 : b); };\r\n        Z.prototype.fixMozTransitionDelay = function (a, f) {\r\n            if (20 < this.chart._eventManager.lastObjectId)\r\n                this.mozContainerTransition =\r\n                    this.getContainerTransition(0);\r\n            else {\r\n                var b = parseFloat(this.container.style.left), b = isNaN(b) ? 0 : b, c = parseFloat(this.container.style.bottom), c = isNaN(c) ? 0 : c;\r\n                10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - f, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);\r\n            }\r\n        };\r\n        Z.prototype.getContainerTransition = function (a) { return \"left \" + a + \"s ease-out 0s, bottom \" + a + \"s ease-out 0s\"; };\r\n        ea.prototype.reset = function () {\r\n            this.lastObjectId = 0;\r\n            this.objectMap = [];\r\n            this.rectangularRegionEventSubscriptions =\r\n                [];\r\n            this.previousDataPointEventObject = null;\r\n            this.eventObjects = [];\r\n            v && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());\r\n        };\r\n        ea.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId; };\r\n        ea.prototype.mouseEventHandler = function (a) {\r\n            if (\"mousemove\" === a.type || \"click\" === a.type) {\r\n                var f = [], b = Pa(a), c = null;\r\n                if ((c = this.chart.getObjectAtXY(b.x, b.y, !1)) && \"undefined\" !== typeof this.objectMap[c])\r\n                    if (c = this.objectMap[c], \"dataPoint\" === c.objectType) {\r\n                        var e = this.chart.data[c.dataSeriesIndex], g = e.dataPoints[c.dataPointIndex], h = c.dataPointIndex;\r\n                        c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };\r\n                        c.eventContext = { context: g, userContext: g, mouseover: \"mouseover\", mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };\r\n                        f.push(c);\r\n                        c = this.objectMap[e.id];\r\n                        c.eventParameter = { x: b.x, y: b.y, dataPoint: g, dataSeries: e.options, dataPointIndex: h, dataSeriesIndex: e.index, chart: this.chart };\r\n                        c.eventContext = { context: e, userContext: e.options, mouseover: \"mouseover\",\r\n                            mousemove: \"mousemove\", mouseout: \"mouseout\", click: \"click\" };\r\n                        f.push(this.objectMap[e.id]);\r\n                    }\r\n                    else\r\n                        \"legendItem\" === c.objectType && (e = this.chart.data[c.dataSeriesIndex], g = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = { x: b.x, y: b.y, dataSeries: e.options, dataPoint: g, dataPointIndex: c.dataPointIndex, dataSeriesIndex: c.dataSeriesIndex, chart: this.chart }, c.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: \"itemmouseover\", mousemove: \"itemmousemove\", mouseout: \"itemmouseout\",\r\n                            click: \"itemclick\" }, f.push(c));\r\n                e = [];\r\n                for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {\r\n                    g = !0;\r\n                    for (c = 0; c < f.length; c++)\r\n                        if (f[c].id === this.mouseoveredObjectMaps[b].id) {\r\n                            g = !1;\r\n                            break;\r\n                        }\r\n                    g ? this.fireEvent(this.mouseoveredObjectMaps[b], \"mouseout\", a) : e.push(this.mouseoveredObjectMaps[b]);\r\n                }\r\n                this.mouseoveredObjectMaps = e;\r\n                for (b = 0; b < f.length; b++) {\r\n                    e = !1;\r\n                    for (c = 0; c < this.mouseoveredObjectMaps.length; c++)\r\n                        if (f[b].id === this.mouseoveredObjectMaps[c].id) {\r\n                            e = !0;\r\n                            break;\r\n                        }\r\n                    e || (this.fireEvent(f[b], \"mouseover\", a), this.mouseoveredObjectMaps.push(f[b]));\r\n                    \"click\" === a.type ? this.fireEvent(f[b], \"click\", a) : \"mousemove\" === a.type && this.fireEvent(f[b], \"mousemove\", a);\r\n                }\r\n            }\r\n        };\r\n        ea.prototype.fireEvent = function (a, f, b) {\r\n            if (a && f) {\r\n                var c = a.eventParameter, e = a.eventContext, g = a.eventContext.userContext;\r\n                g && (e && g[e[f]]) && g[e[f]].call(g, c);\r\n                \"mouseout\" !== f ? g.cursor && g.cursor !== b.target.style.cursor && (b.target.style.cursor = g.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);\r\n                \"click\" === f && (\"dataPoint\" === a.objectType && this.chart.pieDoughnutClickHandler) &&\r\n                    this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\r\n                \"click\" === f && (\"dataPoint\" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c);\r\n            }\r\n        };\r\n        ja.prototype.animate = function (a, f, b, c, e) {\r\n            var g = this;\r\n            this.chart.isAnimating = !0;\r\n            e = e || I.easing.linear;\r\n            b && this.animations.push({ startTime: (new Date).getTime() + (a ? a : 0), duration: f, animationCallback: b, onComplete: c });\r\n            for (a = []; 0 < this.animations.length;)\r\n                if (f = this.animations.shift(),\r\n                    b = (new Date).getTime(), c = 0, f.startTime <= b && (c = e(Math.min(b - f.startTime, f.duration), 0, 1, f.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(f), f.animationCallback(c), 1 <= c && f.onComplete)\r\n                    f.onComplete();\r\n            this.animations = a;\r\n            0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () { g.animate.call(g); }) : this.chart.isAnimating = !1;\r\n        };\r\n        ja.prototype.cancelAllAnimations = function () {\r\n            this.animations = [];\r\n            this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);\r\n            this.animationRequestId = null;\r\n            this.chart.isAnimating = !1;\r\n        };\r\n        var I = { yScaleAnimation: function (a, f) { if (0 !== a) {\r\n                var b = f.dest, c = f.source.canvas, e = f.animationBase;\r\n                b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / ga, a * b.canvas.height / ga);\r\n            } }, xScaleAnimation: function (a, f) { if (0 !== a) {\r\n                var b = f.dest, c = f.source.canvas, e = f.animationBase;\r\n                b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / ga, b.canvas.height / ga);\r\n            } }, xClipAnimation: function (a, f) {\r\n                if (0 !== a) {\r\n                    var b = f.dest, c = f.source.canvas;\r\n                    b.save();\r\n                    0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / ga, c.height / ga);\r\n                    b.restore();\r\n                }\r\n            }, fadeInAnimation: function (a, f) { if (0 !== a) {\r\n                var b = f.dest, c = f.source.canvas;\r\n                b.save();\r\n                b.globalAlpha = a;\r\n                b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / ga, b.canvas.height / ga);\r\n                b.restore();\r\n            } }, easing: { linear: function (a, f, b, c) { return b * a / c + f; }, easeOutQuad: function (a, f, b, c) { return -b * (a /= c) * (a - 2) + f; }, easeOutQuart: function (a, f, b, c) { return -b * ((a = a / c - 1) * a * a * a - 1) + f; }, easeInQuad: function (a, f, b, c) { return b * (a /= c) * a + f; }, easeInQuart: function (a, f, b, c) { return b * (a /= c) * a * a * a + f; } } }, ia = { drawMarker: function (a, f, b, c, e, g, h, l) {\r\n                if (b) {\r\n                    var m = 1;\r\n                    b.fillStyle = g ? g : \"#000000\";\r\n                    b.strokeStyle = h ? h : \"#000000\";\r\n                    b.lineWidth = l ? l : 0;\r\n                    b.setLineDash && b.setLineDash(G(\"solid\", l));\r\n                    \"circle\" === c ? (b.moveTo(a, f), b.beginPath(), b.arc(a, f, e / 2, 0, 2 * Math.PI, !1), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m))) : \"square\" === c ? (b.beginPath(), b.rect(a - e / 2, f - e / 2, e, e), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha =\r\n                        0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m))) : \"triangle\" === c ? (b.beginPath(), b.moveTo(a - e / 2, f + e / 2), b.lineTo(a + e / 2, f + e / 2), b.lineTo(a, f - e / 2), b.closePath(), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = \"black\", b.stroke(), b.globalAlpha = m)), b.beginPath()) : \"cross\" === c && (b.strokeStyle = g, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, f - e / 2), b.lineTo(a + e / 2, f + e / 2), b.stroke(), b.moveTo(a + e / 2, f - e / 2), b.lineTo(a - e / 2, f + e / 2), b.stroke());\r\n                }\r\n            }, drawMarkers: function (a) {\r\n                for (var f = 0; f < a.length; f++) {\r\n                    var b = a[f];\r\n                    ia.drawMarker(b.x, b.y, b.ctx, b.type, b.size, b.color, b.borderColor, b.borderThickness);\r\n                }\r\n            } };\r\n        return s;\r\n    }();\r\n    La.Chart.version = \"v2.1.3 GA\";\r\n})();\r\n/*\r\n  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.\r\n\r\n  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/\r\n  Licensed under the Apache License, Version 2.0\r\n*/\r\ndocument.createElement(\"canvas\").getContext || function () {\r\n    function V() { return this.context_ || (this.context_ = new C(this)); }\r\n    function W(a, b, c) { var g = M.call(arguments, 2); return function () { return a.apply(b, g.concat(M.call(arguments))); }; }\r\n    function N(a) { return String(a).replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\"); }\r\n    function O(a) {\r\n        a.namespaces.g_vml_ || a.namespaces.add(\"g_vml_\", \"urn:schemas-microsoft-com:vml\", \"#default#VML\");\r\n        a.namespaces.g_o_ || a.namespaces.add(\"g_o_\", \"urn:schemas-microsoft-com:office:office\", \"#default#VML\");\r\n        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = \"ex_canvas_\", a.cssText = \"canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}\");\r\n    }\r\n    function X(a) {\r\n        var b = a.srcElement;\r\n        switch (a.propertyName) {\r\n            case \"width\":\r\n                b.getContext().clearRect();\r\n                b.style.width = b.attributes.width.nodeValue + \"px\";\r\n                b.firstChild.style.width = b.clientWidth + \"px\";\r\n                break;\r\n            case \"height\": b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + \"px\", b.firstChild.style.height = b.clientHeight +\r\n                \"px\";\r\n        }\r\n    }\r\n    function Y(a) { a = a.srcElement; a.firstChild && (a.firstChild.style.width = a.clientWidth + \"px\", a.firstChild.style.height = a.clientHeight + \"px\"); }\r\n    function D() { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; }\r\n    function t(a, b) { for (var c = D(), g = 0; 3 > g; g++)\r\n        for (var e = 0; 3 > e; e++) {\r\n            for (var f = 0, d = 0; 3 > d; d++)\r\n                f += a[g][d] * b[d][e];\r\n            c[g][e] = f;\r\n        } return c; }\r\n    function P(a, b) {\r\n        b.fillStyle = a.fillStyle;\r\n        b.lineCap = a.lineCap;\r\n        b.lineJoin = a.lineJoin;\r\n        b.lineWidth = a.lineWidth;\r\n        b.miterLimit = a.miterLimit;\r\n        b.shadowBlur = a.shadowBlur;\r\n        b.shadowColor = a.shadowColor;\r\n        b.shadowOffsetX =\r\n            a.shadowOffsetX;\r\n        b.shadowOffsetY = a.shadowOffsetY;\r\n        b.strokeStyle = a.strokeStyle;\r\n        b.globalAlpha = a.globalAlpha;\r\n        b.font = a.font;\r\n        b.textAlign = a.textAlign;\r\n        b.textBaseline = a.textBaseline;\r\n        b.arcScaleX_ = a.arcScaleX_;\r\n        b.arcScaleY_ = a.arcScaleY_;\r\n        b.lineScale_ = a.lineScale_;\r\n    }\r\n    function Q(a) { var b = a.indexOf(\"(\", 3), c = a.indexOf(\")\", b + 1), b = a.substring(b + 1, c).split(\",\"); if (4 != b.length || \"a\" != a.charAt(3))\r\n        b[3] = 1; return b; }\r\n    function E(a, b, c) { return Math.min(c, Math.max(b, a)); }\r\n    function F(a, b, c) {\r\n        0 > c && c++;\r\n        1 < c && c--;\r\n        return 1 > 6 * c ? a + 6 * (b - a) * c :\r\n            1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;\r\n    }\r\n    function G(a) {\r\n        if (a in H)\r\n            return H[a];\r\n        var b, c = 1;\r\n        a = String(a);\r\n        if (\"#\" == a.charAt(0))\r\n            b = a;\r\n        else if (/^rgb/.test(a)) {\r\n            c = Q(a);\r\n            b = \"#\";\r\n            for (var g, e = 0; 3 > e; e++)\r\n                g = -1 != c[e].indexOf(\"%\") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];\r\n            c = +c[3];\r\n        }\r\n        else if (/^hsl/.test(a)) {\r\n            e = c = Q(a);\r\n            b = parseFloat(e[0]) / 360 % 360;\r\n            0 > b && b++;\r\n            g = E(parseFloat(e[1]) / 100, 0, 1);\r\n            e = E(parseFloat(e[2]) / 100, 0, 1);\r\n            if (0 == g)\r\n                g = e = b = e;\r\n            else {\r\n                var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d = 2 * e - f;\r\n                g = F(d, f, b + 1 / 3);\r\n                e = F(d, f, b);\r\n                b = F(d, f, b - 1 / 3);\r\n            }\r\n            b = \"#\" +\r\n                v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];\r\n            c = c[3];\r\n        }\r\n        else\r\n            b = Z[a] || a;\r\n        return H[a] = { color: b, alpha: c };\r\n    }\r\n    function C(a) {\r\n        this.m_ = D();\r\n        this.mStack_ = [];\r\n        this.aStack_ = [];\r\n        this.currentPath_ = [];\r\n        this.fillStyle = this.strokeStyle = \"#000\";\r\n        this.lineWidth = 1;\r\n        this.lineJoin = \"miter\";\r\n        this.lineCap = \"butt\";\r\n        this.miterLimit = 1 * q;\r\n        this.globalAlpha = 1;\r\n        this.font = \"10px sans-serif\";\r\n        this.textAlign = \"left\";\r\n        this.textBaseline = \"alphabetic\";\r\n        this.canvas = a;\r\n        var b = \"width:\" + a.clientWidth + \"px;height:\" + a.clientHeight + \"px;overflow:hidden;position:absolute\", c = a.ownerDocument.createElement(\"div\");\r\n        c.style.cssText = b;\r\n        a.appendChild(c);\r\n        b = c.cloneNode(!1);\r\n        b.style.backgroundColor = \"red\";\r\n        b.style.filter = \"alpha(opacity=0)\";\r\n        a.appendChild(b);\r\n        this.element_ = c;\r\n        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;\r\n    }\r\n    function R(a, b, c, g) { a.currentPath_.push({ type: \"bezierCurveTo\", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: g.x, y: g.y }); a.currentX_ = g.x; a.currentY_ = g.y; }\r\n    function S(a, b) {\r\n        var c = G(a.strokeStyle), g = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth;\r\n        1 > e && (c *= e);\r\n        b.push(\"<g_vml_:stroke\", ' opacity=\"', c, '\"', ' joinstyle=\"', a.lineJoin, '\"', ' miterlimit=\"', a.miterLimit, '\"', ' endcap=\"', $[a.lineCap] || \"square\", '\"', ' weight=\"', e, 'px\"', ' color=\"', g, '\" />');\r\n    }\r\n    function T(a, b, c, g) {\r\n        var e = a.fillStyle, f = a.arcScaleX_, d = a.arcScaleY_, k = g.x - c.x, n = g.y - c.y;\r\n        if (e instanceof w) {\r\n            var h = 0, l = g = 0, u = 0, m = 1;\r\n            if (\"gradient\" == e.type_) {\r\n                h = e.x1_ / f;\r\n                c = e.y1_ / d;\r\n                var p = s(a, e.x0_ / f, e.y0_ / d), h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;\r\n                0 > h && (h += 360);\r\n                1E-6 > h && (h = 0);\r\n            }\r\n            else\r\n                p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q,\r\n                    n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;\r\n            f = e.colors_;\r\n            f.sort(function (a, b) { return a.offset - b.offset; });\r\n            d = f.length;\r\n            p = f[0].color;\r\n            c = f[d - 1].color;\r\n            k = f[0].alpha * a.globalAlpha;\r\n            a = f[d - 1].alpha * a.globalAlpha;\r\n            for (var n = [], r = 0; r < d; r++) {\r\n                var t = f[r];\r\n                n.push(t.offset * m + u + \" \" + t.color);\r\n            }\r\n            b.push('<g_vml_:fill type=\"', e.type_, '\"', ' method=\"none\" focus=\"100%\"', ' color=\"', p, '\"', ' color2=\"', c, '\"', ' colors=\"', n.join(\",\"), '\"', ' opacity=\"', a, '\"', ' g_o_:opacity2=\"', k, '\"', ' angle=\"', h, '\"', ' focusposition=\"', g, \",\", l, '\" />');\r\n        }\r\n        else\r\n            e instanceof\r\n                I ? k && n && b.push(\"<g_vml_:fill\", ' position=\"', -c.x / k * f * f, \",\", -c.y / n * d * d, '\"', ' type=\"tile\"', ' src=\"', e.src_, '\" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color=\"', e.color, '\" opacity=\"', e.alpha * a.globalAlpha, '\" />'));\r\n    }\r\n    function s(a, b, c) { a = a.m_; return { x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r, y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r }; }\r\n    function z(a, b, c) {\r\n        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] *\r\n            b[1][0]))));\r\n    }\r\n    function w(a) { this.type_ = a; this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0; this.colors_ = []; }\r\n    function I(a, b) { if (!a || 1 != a.nodeType || \"IMG\" != a.tagName)\r\n        throw new A(\"TYPE_MISMATCH_ERR\"); if (\"complete\" != a.readyState)\r\n        throw new A(\"INVALID_STATE_ERR\"); switch (b) {\r\n        case \"repeat\":\r\n        case null:\r\n        case \"\":\r\n            this.repetition_ = \"repeat\";\r\n            break;\r\n        case \"repeat-x\":\r\n        case \"repeat-y\":\r\n        case \"no-repeat\":\r\n            this.repetition_ = b;\r\n            break;\r\n        default: throw new A(\"SYNTAX_ERR\");\r\n    } this.src_ = a.src; this.width_ = a.width; this.height_ = a.height; }\r\n    function A(a) { this.code = this[a]; this.message = a + \": DOM Exception \" + this.code; }\r\n    var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;\r\n    navigator.userAgent.match(/MSIE ([\\d.]+)?/);\r\n    var M = Array.prototype.slice;\r\n    O(document);\r\n    var U = { init: function (a) { a = a || document; a.createElement(\"canvas\"); a.attachEvent(\"onreadystatechange\", W(this.init_, this, a)); }, init_: function (a) { a = a.getElementsByTagName(\"canvas\"); for (var b = 0; b < a.length; b++)\r\n            this.initElement(a[b]); }, initElement: function (a) {\r\n            if (!a.getContext) {\r\n                a.getContext =\r\n                    V;\r\n                O(a.ownerDocument);\r\n                a.innerHTML = \"\";\r\n                a.attachEvent(\"onpropertychange\", X);\r\n                a.attachEvent(\"onresize\", Y);\r\n                var b = a.attributes;\r\n                b.width && b.width.specified ? a.style.width = b.width.nodeValue + \"px\" : a.width = a.clientWidth;\r\n                b.height && b.height.specified ? a.style.height = b.height.nodeValue + \"px\" : a.height = a.clientHeight;\r\n            }\r\n            return a;\r\n        } };\r\n    U.init();\r\n    for (var v = [], d = 0; 16 > d; d++)\r\n        for (var B = 0; 16 > B; B++)\r\n            v[16 * d + B] = d.toString(16) + B.toString(16);\r\n    var Z = { aliceblue: \"#F0F8FF\", antiquewhite: \"#FAEBD7\", aquamarine: \"#7FFFD4\", azure: \"#F0FFFF\", beige: \"#F5F5DC\",\r\n        bisque: \"#FFE4C4\", black: \"#000000\", blanchedalmond: \"#FFEBCD\", blueviolet: \"#8A2BE2\", brown: \"#A52A2A\", burlywood: \"#DEB887\", cadetblue: \"#5F9EA0\", chartreuse: \"#7FFF00\", chocolate: \"#D2691E\", coral: \"#FF7F50\", cornflowerblue: \"#6495ED\", cornsilk: \"#FFF8DC\", crimson: \"#DC143C\", cyan: \"#00FFFF\", darkblue: \"#00008B\", darkcyan: \"#008B8B\", darkgoldenrod: \"#B8860B\", darkgray: \"#A9A9A9\", darkgreen: \"#006400\", darkgrey: \"#A9A9A9\", darkkhaki: \"#BDB76B\", darkmagenta: \"#8B008B\", darkolivegreen: \"#556B2F\", darkorange: \"#FF8C00\", darkorchid: \"#9932CC\", darkred: \"#8B0000\",\r\n        darksalmon: \"#E9967A\", darkseagreen: \"#8FBC8F\", darkslateblue: \"#483D8B\", darkslategray: \"#2F4F4F\", darkslategrey: \"#2F4F4F\", darkturquoise: \"#00CED1\", darkviolet: \"#9400D3\", deeppink: \"#FF1493\", deepskyblue: \"#00BFFF\", dimgray: \"#696969\", dimgrey: \"#696969\", dodgerblue: \"#1E90FF\", firebrick: \"#B22222\", floralwhite: \"#FFFAF0\", forestgreen: \"#228B22\", gainsboro: \"#DCDCDC\", ghostwhite: \"#F8F8FF\", gold: \"#FFD700\", goldenrod: \"#DAA520\", grey: \"#808080\", greenyellow: \"#ADFF2F\", honeydew: \"#F0FFF0\", hotpink: \"#FF69B4\", indianred: \"#CD5C5C\", indigo: \"#4B0082\",\r\n        ivory: \"#FFFFF0\", khaki: \"#F0E68C\", lavender: \"#E6E6FA\", lavenderblush: \"#FFF0F5\", lawngreen: \"#7CFC00\", lemonchiffon: \"#FFFACD\", lightblue: \"#ADD8E6\", lightcoral: \"#F08080\", lightcyan: \"#E0FFFF\", lightgoldenrodyellow: \"#FAFAD2\", lightgreen: \"#90EE90\", lightgrey: \"#D3D3D3\", lightpink: \"#FFB6C1\", lightsalmon: \"#FFA07A\", lightseagreen: \"#20B2AA\", lightskyblue: \"#87CEFA\", lightslategray: \"#778899\", lightslategrey: \"#778899\", lightsteelblue: \"#B0C4DE\", lightyellow: \"#FFFFE0\", limegreen: \"#32CD32\", linen: \"#FAF0E6\", magenta: \"#FF00FF\", mediumaquamarine: \"#66CDAA\",\r\n        mediumblue: \"#0000CD\", mediumorchid: \"#BA55D3\", mediumpurple: \"#9370DB\", mediumseagreen: \"#3CB371\", mediumslateblue: \"#7B68EE\", mediumspringgreen: \"#00FA9A\", mediumturquoise: \"#48D1CC\", mediumvioletred: \"#C71585\", midnightblue: \"#191970\", mintcream: \"#F5FFFA\", mistyrose: \"#FFE4E1\", moccasin: \"#FFE4B5\", navajowhite: \"#FFDEAD\", oldlace: \"#FDF5E6\", olivedrab: \"#6B8E23\", orange: \"#FFA500\", orangered: \"#FF4500\", orchid: \"#DA70D6\", palegoldenrod: \"#EEE8AA\", palegreen: \"#98FB98\", paleturquoise: \"#AFEEEE\", palevioletred: \"#DB7093\", papayawhip: \"#FFEFD5\",\r\n        peachpuff: \"#FFDAB9\", peru: \"#CD853F\", pink: \"#FFC0CB\", plum: \"#DDA0DD\", powderblue: \"#B0E0E6\", rosybrown: \"#BC8F8F\", royalblue: \"#4169E1\", saddlebrown: \"#8B4513\", salmon: \"#FA8072\", sandybrown: \"#F4A460\", seagreen: \"#2E8B57\", seashell: \"#FFF5EE\", sienna: \"#A0522D\", skyblue: \"#87CEEB\", slateblue: \"#6A5ACD\", slategray: \"#708090\", slategrey: \"#708090\", snow: \"#FFFAFA\", springgreen: \"#00FF7F\", steelblue: \"#4682B4\", tan: \"#D2B48C\", thistle: \"#D8BFD8\", tomato: \"#FF6347\", turquoise: \"#40E0D0\", violet: \"#EE82EE\", wheat: \"#F5DEB3\", whitesmoke: \"#F5F5F5\", yellowgreen: \"#9ACD32\" }, H = {}, L = {}, $ = { butt: \"flat\", round: \"round\" }, d = C.prototype;\r\n    d.clearRect = function () { this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null); this.element_.innerHTML = \"\"; };\r\n    d.beginPath = function () { this.currentPath_ = []; };\r\n    d.moveTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: \"moveTo\", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y; };\r\n    d.lineTo = function (a, b) { var c = s(this, a, b); this.currentPath_.push({ type: \"lineTo\", x: c.x, y: c.y }); this.currentX_ = c.x; this.currentY_ = c.y; };\r\n    d.bezierCurveTo =\r\n        function (a, b, c, g, e, f) { e = s(this, e, f); a = s(this, a, b); c = s(this, c, g); R(this, a, c, e); };\r\n    d.quadraticCurveTo = function (a, b, c, g) { a = s(this, a, b); c = s(this, c, g); g = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) }; R(this, g, { x: g.x + (c.x - this.currentX_) / 3, y: g.y + (c.y - this.currentY_) / 3 }, c); };\r\n    d.arc = function (a, b, c, g, e, f) {\r\n        c *= q;\r\n        var d = f ? \"at\" : \"wa\", k = a + K(g) * c - r, n = b + J(g) * c - r;\r\n        g = a + K(e) * c - r;\r\n        e = b + J(e) * c - r;\r\n        k != g || f || (k += 0.125);\r\n        a = s(this, a, b);\r\n        k = s(this, k, n);\r\n        g = s(this, g, e);\r\n        this.currentPath_.push({ type: d,\r\n            x: a.x, y: a.y, radius: c, xStart: k.x, yStart: k.y, xEnd: g.x, yEnd: g.y });\r\n    };\r\n    d.rect = function (a, b, c, g) { this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath(); };\r\n    d.strokeRect = function (a, b, c, g) { var e = this.currentPath_; this.beginPath(); this.moveTo(a, b); this.lineTo(a + c, b); this.lineTo(a + c, b + g); this.lineTo(a, b + g); this.closePath(); this.stroke(); this.currentPath_ = e; };\r\n    d.fillRect = function (a, b, c, g) {\r\n        var e = this.currentPath_;\r\n        this.beginPath();\r\n        this.moveTo(a, b);\r\n        this.lineTo(a + c, b);\r\n        this.lineTo(a +\r\n            c, b + g);\r\n        this.lineTo(a, b + g);\r\n        this.closePath();\r\n        this.fill();\r\n        this.currentPath_ = e;\r\n    };\r\n    d.createLinearGradient = function (a, b, c, g) { var e = new w(\"gradient\"); e.x0_ = a; e.y0_ = b; e.x1_ = c; e.y1_ = g; return e; };\r\n    d.createRadialGradient = function (a, b, c, g, e, f) { var d = new w(\"gradientradial\"); d.x0_ = a; d.y0_ = b; d.r0_ = c; d.x1_ = g; d.y1_ = e; d.r1_ = f; return d; };\r\n    d.drawImage = function (a, b) {\r\n        var c, g, e, d, r, y, n, h;\r\n        e = a.runtimeStyle.width;\r\n        d = a.runtimeStyle.height;\r\n        a.runtimeStyle.width = \"auto\";\r\n        a.runtimeStyle.height = \"auto\";\r\n        var l = a.width, u = a.height;\r\n        a.runtimeStyle.width =\r\n            e;\r\n        a.runtimeStyle.height = d;\r\n        if (3 == arguments.length)\r\n            c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u;\r\n        else if (5 == arguments.length)\r\n            c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u;\r\n        else if (9 == arguments.length)\r\n            r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8];\r\n        else\r\n            throw Error(\"Invalid number of arguments\");\r\n        var m = s(this, c, g), p = [];\r\n        p.push(\" <g_vml_:group\", ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' coordorigin=\"0,0\"', ' style=\"width:', 10, \"px;height:\", 10, \"px;position:absolute;\");\r\n        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {\r\n            var t = [];\r\n            t.push(\"M11=\", this.m_[0][0], \",\", \"M12=\", this.m_[1][0], \",\", \"M21=\", this.m_[0][1], \",\", \"M22=\", this.m_[1][1], \",\", \"Dx=\", k(m.x / q), \",\", \"Dy=\", k(m.y / q), \"\");\r\n            var v = s(this, c + e, g), w = s(this, c, g + d);\r\n            c = s(this, c + e, g + d);\r\n            m.x = x.max(m.x, v.x, w.x, c.x);\r\n            m.y = x.max(m.y, v.y, w.y, c.y);\r\n            p.push(\"padding:0 \", k(m.x / q), \"px \", k(m.y / q), \"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(\", t.join(\"\"), \", sizingmethod='clip');\");\r\n        }\r\n        else\r\n            p.push(\"top:\", k(m.y / q), \"px;left:\", k(m.x / q), \"px;\");\r\n        p.push(' \">', '<g_vml_:image src=\"', a.src, '\"', ' style=\"width:', q * e, \"px;\", \" height:\", q * d, 'px\"', ' cropleft=\"', r / l, '\"', ' croptop=\"', y / u, '\"', ' cropright=\"', (l - r - n) / l, '\"', ' cropbottom=\"', (u - y - h) / u, '\"', \" />\", \"</g_vml_:group>\");\r\n        this.element_.insertAdjacentHTML(\"BeforeEnd\", p.join(\"\"));\r\n    };\r\n    d.stroke = function (a) {\r\n        var b = [];\r\n        b.push(\"<g_vml_:shape\", ' filled=\"', !!a, '\"', ' style=\"position:absolute;width:', 10, \"px;height:\", 10, 'px;\"', ' coordorigin=\"0,0\"', ' coordsize=\"', 10 * q, \",\", 10 * q, '\"', ' stroked=\"', !a, '\"', ' path=\"');\r\n        for (var c = { x: null, y: null }, d = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {\r\n            var f = this.currentPath_[e];\r\n            switch (f.type) {\r\n                case \"moveTo\":\r\n                    b.push(\" m \", k(f.x), \",\", k(f.y));\r\n                    break;\r\n                case \"lineTo\":\r\n                    b.push(\" l \", k(f.x), \",\", k(f.y));\r\n                    break;\r\n                case \"close\":\r\n                    b.push(\" x \");\r\n                    f = null;\r\n                    break;\r\n                case \"bezierCurveTo\":\r\n                    b.push(\" c \", k(f.cp1x), \",\", k(f.cp1y), \",\", k(f.cp2x), \",\", k(f.cp2y), \",\", k(f.x), \",\", k(f.y));\r\n                    break;\r\n                case \"at\":\r\n                case \"wa\": b.push(\" \", f.type, \" \", k(f.x - this.arcScaleX_ * f.radius), \",\", k(f.y - this.arcScaleY_ *\r\n                    f.radius), \" \", k(f.x + this.arcScaleX_ * f.radius), \",\", k(f.y + this.arcScaleY_ * f.radius), \" \", k(f.xStart), \",\", k(f.yStart), \" \", k(f.xEnd), \",\", k(f.yEnd));\r\n            }\r\n            if (f) {\r\n                if (null == c.x || f.x < c.x)\r\n                    c.x = f.x;\r\n                if (null == d.x || f.x > d.x)\r\n                    d.x = f.x;\r\n                if (null == c.y || f.y < c.y)\r\n                    c.y = f.y;\r\n                if (null == d.y || f.y > d.y)\r\n                    d.y = f.y;\r\n            }\r\n        }\r\n        b.push(' \">');\r\n        a ? T(this, b, c, d) : S(this, b);\r\n        b.push(\"</g_vml_:shape>\");\r\n        this.element_.insertAdjacentHTML(\"beforeEnd\", b.join(\"\"));\r\n    };\r\n    d.fill = function () { this.stroke(!0); };\r\n    d.closePath = function () { this.currentPath_.push({ type: \"close\" }); };\r\n    d.save = function () {\r\n        var a = {};\r\n        P(this, a);\r\n        this.aStack_.push(a);\r\n        this.mStack_.push(this.m_);\r\n        this.m_ = t(D(), this.m_);\r\n    };\r\n    d.restore = function () { this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop()); };\r\n    d.translate = function (a, b) { z(this, t([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1); };\r\n    d.rotate = function (a) { var b = K(a); a = J(a); z(this, t([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1); };\r\n    d.scale = function (a, b) { this.arcScaleX_ *= a; this.arcScaleY_ *= b; z(this, t([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0); };\r\n    d.transform = function (a, b, c, d, e, f) {\r\n        z(this, t([[a,\r\n                b, 0], [c, d, 0], [e, f, 1]], this.m_), !0);\r\n    };\r\n    d.setTransform = function (a, b, c, d, e, f) { z(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0); };\r\n    d.drawText_ = function (a, b, c, d, e) {\r\n        var f = this.m_;\r\n        d = 0;\r\n        var r = 1E3, t = 0, n = [], h;\r\n        h = this.font;\r\n        if (L[h])\r\n            h = L[h];\r\n        else {\r\n            var l = document.createElement(\"div\").style;\r\n            try {\r\n                l.font = h;\r\n            }\r\n            catch (u) { }\r\n            h = L[h] = { style: l.fontStyle || \"normal\", variant: l.fontVariant || \"normal\", weight: l.fontWeight || \"normal\", size: l.fontSize || 10, family: l.fontFamily || \"sans-serif\" };\r\n        }\r\n        var l = h, m = this.element_;\r\n        h = {};\r\n        for (var p in l)\r\n            h[p] = l[p];\r\n        p = parseFloat(m.currentStyle.fontSize);\r\n        m = parseFloat(l.size);\r\n        \"number\" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf(\"px\") ? h.size = m : -1 != l.size.indexOf(\"em\") ? h.size = p * m : -1 != l.size.indexOf(\"%\") ? h.size = p / 100 * m : -1 != l.size.indexOf(\"pt\") ? h.size = m / 0.75 : h.size = p;\r\n        h.size *= 0.981;\r\n        p = h.style + \" \" + h.variant + \" \" + h.weight + \" \" + h.size + \"px \" + h.family;\r\n        m = this.element_.currentStyle;\r\n        l = this.textAlign.toLowerCase();\r\n        switch (l) {\r\n            case \"left\":\r\n            case \"center\":\r\n            case \"right\": break;\r\n            case \"end\":\r\n                l = \"ltr\" == m.direction ? \"right\" : \"left\";\r\n                break;\r\n            case \"start\":\r\n                l = \"rtl\" == m.direction ? \"right\" :\r\n                    \"left\";\r\n                break;\r\n            default: l = \"left\";\r\n        }\r\n        switch (this.textBaseline) {\r\n            case \"hanging\":\r\n            case \"top\":\r\n                t = h.size / 1.75;\r\n                break;\r\n            case \"middle\": break;\r\n            default:\r\n            case null:\r\n            case \"alphabetic\":\r\n            case \"ideographic\":\r\n            case \"bottom\": t = -h.size / 2.25;\r\n        }\r\n        switch (l) {\r\n            case \"right\":\r\n                d = 1E3;\r\n                r = 0.05;\r\n                break;\r\n            case \"center\": d = r = 500;\r\n        }\r\n        b = s(this, b + 0, c + t);\r\n        n.push('<g_vml_:line from=\"', -d, ' 0\" to=\"', r, ' 0.05\" ', ' coordsize=\"100 100\" coordorigin=\"0 0\"', ' filled=\"', !e, '\" stroked=\"', !!e, '\" style=\"position:absolute;width:1px;height:1px;\">');\r\n        e ? S(this, n) : T(this, n, { x: -d, y: 0 }, { x: r, y: h.size });\r\n        e = f[0][0].toFixed(3) + \",\" + f[1][0].toFixed(3) + \",\" + f[0][1].toFixed(3) + \",\" + f[1][1].toFixed(3) + \",0,0\";\r\n        b = k(b.x / q) + \",\" + k(b.y / q);\r\n        n.push('<g_vml_:skew on=\"t\" matrix=\"', e, '\" ', ' offset=\"', b, '\" origin=\"', d, ' 0\" />', '<g_vml_:path textpathok=\"true\" />', '<g_vml_:textpath on=\"true\" string=\"', N(a), '\" style=\"v-text-align:', l, \";font:\", N(p), '\" /></g_vml_:line>');\r\n        this.element_.insertAdjacentHTML(\"beforeEnd\", n.join(\"\"));\r\n    };\r\n    d.fillText = function (a, b, c, d) { this.drawText_(a, b, c, d, !1); };\r\n    d.strokeText = function (a, b, c, d) { this.drawText_(a, b, c, d, !0); };\r\n    d.measureText = function (a) { this.textMeasureEl_ || (this.element_.insertAdjacentHTML(\"beforeEnd\", '<span style=\"position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;\"></span>'), this.textMeasureEl_ = this.element_.lastChild); var b = this.element_.ownerDocument; this.textMeasureEl_.innerHTML = \"\"; this.textMeasureEl_.style.font = this.font; this.textMeasureEl_.appendChild(b.createTextNode(a)); return { width: this.textMeasureEl_.offsetWidth }; };\r\n    d.clip = function () { };\r\n    d.arcTo = function () { };\r\n    d.createPattern = function (a, b) { return new I(a, b); };\r\n    w.prototype.addColorStop = function (a, b) { b = G(b); this.colors_.push({ offset: a, color: b.color, alpha: b.alpha }); };\r\n    d = A.prototype = Error();\r\n    d.INDEX_SIZE_ERR = 1;\r\n    d.DOMSTRING_SIZE_ERR = 2;\r\n    d.HIERARCHY_REQUEST_ERR = 3;\r\n    d.WRONG_DOCUMENT_ERR = 4;\r\n    d.INVALID_CHARACTER_ERR = 5;\r\n    d.NO_DATA_ALLOWED_ERR = 6;\r\n    d.NO_MODIFICATION_ALLOWED_ERR = 7;\r\n    d.NOT_FOUND_ERR = 8;\r\n    d.NOT_SUPPORTED_ERR = 9;\r\n    d.INUSE_ATTRIBUTE_ERR = 10;\r\n    d.INVALID_STATE_ERR = 11;\r\n    d.SYNTAX_ERR = 12;\r\n    d.INVALID_MODIFICATION_ERR =\r\n        13;\r\n    d.NAMESPACE_ERR = 14;\r\n    d.INVALID_ACCESS_ERR = 15;\r\n    d.VALIDATION_ERR = 16;\r\n    d.TYPE_MISMATCH_ERR = 17;\r\n    G_vmlCanvasManager = U;\r\n    CanvasRenderingContext2D = C;\r\n    CanvasGradient = w;\r\n    CanvasPattern = I;\r\n    DOMException = A;\r\n}();\r\n/*jshint ignore:end*/ \r\n",null]}